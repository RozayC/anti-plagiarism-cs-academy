ExerciseID,Name,CollectionNumber,StarterCode,SampleSolution,ExerciseType,Points
1890,Position and Size Checkpoint 4,1.1.2.1,"# Move this rectangle to match the solution canvas.
### (HINT: Change the left-top to (50, 50)!)
### Fix Your Code Here ###
Rect(150, 150, 100, 100)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Move this rectangle to match the solution canvas.
Rect(50, 50, 100, 100)
",regular,1
1892,Position and Size Checkpoint 6,1.1.2.1,"# Match the solution!
### (HINT: This has an error!)
### Fix Your Code Here ###
Rect(50 100 150 200)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Match the solution!
Rect(50, 100, 150, 200)
",regular,1
1891,Position and Size Checkpoint 5,1.1.2.1,"# Match the solution!
### (HINT: This has an error!)
### Fix Your Code Here ###
rect(50, 100, 150, 200)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Match the solution!
Rect(50, 100, 150, 200)
",regular,1
1897,Cat face,1.1.3,"# Use the Inspector to help draw the cat's head.
### (HINT: None of the rectangles in this image overlap, except on the borders.)
### (HINT: The cat's forehead and chin are each one big rectangle. The eyes are
#          made by drawing three rectangles that connect the forehead and chin.)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Use the Inspector to help draw the cat's head.
# Draw the head.
Rect(100, 150, 200, 65)
Rect(100, 250, 200, 80)
Rect(100, 215, 40, 35)
Rect(175, 215, 50, 35)
Rect(260, 215, 40, 35)

# Draw the eyes.
Rect(155, 230, 15, 15)
Rect(230, 230, 15, 15)

# Draw the ears.
Rect(100, 120, 40, 30)
Rect(100, 85, 15, 35)
Rect(260, 120, 40, 30)
Rect(285, 85, 15, 35)
",regular,2
1894,Draw three rectangles,1.1.3,"# Draw three rectangles to match the solution.
### (HINT: Use the Inspector to find the left, top, width, and height!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw three rectangles to match the solution.
Rect(0, 200, 100, 200)
Rect(100, 0, 300, 200)
Rect(200, 300, 200, 100)
",regular,1
1896,Serious Face,1.1.3,"# Draw two eyes and a mouth to create a serious face.
### (HINT: Use the Inspector to find the left, top, width, and height!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw two eyes and a mouth to create a serious face.
# Eyes
Rect(100, 120, 30, 80)
Rect(270, 120, 30, 80)

# Mouth
Rect(150, 300, 100, 10)
Rect(180, 320, 40, 20)
",regular,1
1893,Draw two rectangles,1.1.3,"# Draw two rectangles to match the solution.
### (HINT: Use the Inspector to find the left, top, width, and height!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw two rectangles to match the solution.
Rect(0, 200, 200, 200)
Rect(200, 0, 200, 200)
",regular,1
1895,Pickaxe,1.1.3,"# Draw the handle using 4 rectangles and then draw the pick.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the handle using 4 rectangles and then draw the pick.
# Handle
Rect(125, 125, 75, 75)
Rect(200, 200, 75, 75)
Rect(275, 275, 75, 75)
Rect(50, 50, 40, 40)

# Pick
Rect(100, 50, 200, 40)
Rect(50, 100, 40, 200)
",regular,2
1898,Fills and Borders Checkpoint 1,1.2.1.1,"# Fix this code to draw a green square!
### (HINT: Use Rect to draw a square!)
### (HINT: This has an error!)
### Fix Your Code Here ###
Rect(150, 150, 100, 100, 'green')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(150, 150, 100, 100, fill='green')
",regular,1
1899,Fills and Borders Checkpoint 2,1.2.1.1,"# Fix the error in this code so it draws a 100x100
# brown square centered in the canvas.

### (HINT: Use Rect to draw a square!)
### (HINT: This has two errors!)
### Fix Your Code Here ###
Rect(fill=brown, 150, 150, 100, 100)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(150, 150, 100, 100, fill='brown')
",regular,1
1900,Fills and Borders Checkpoint 3,1.2.1.1,"# Draw a rectangle that creates a colorful background!
### (HINT: Remember to use the inspector to find properties of the shapes,
#          including the colors and borders!)
### (HINT: The corners of the Rect should be the corners of the Canvas.)
### Place Your Code Here ###
# Rect()

# Draw the three other Rects in the correct order to get the solution.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw a rectangle that creates a colorful background!
Rect(0, 0, 400, 400, fill='lightSalmon')

# Draw the other Rects in the correct order.
Rect(40, 20, 160, 160, fill='dodgerBlue')
Rect(120, 100, 160, 200, fill='lightGreen')
Rect(200, 220, 160, 160, fill='dodgerBlue')
",regular,1
1902,Fix the flag of Chad,1.2.2,"# This code 'looks right', but it contains an error: the blue rectangle is too
# large! The autograder will not accept it until the blue rectangle is not
# overlapped by the yellow and red rectangles.
### Fix Your Code Here ###
Rect(50, 100, 300, 200, fill='blue')

# This correctly draws the yellow and red rectangles.
### (HINT: To see the problem using the canvas, try commenting the two lines of
#          code below using a '#' mark and running the code so that only the blue
#          rectangle is drawn. Be sure to uncomment the lines when you want to
#          draw the whole flag again!)
Rect(150, 100, 100, 200, fill='yellow')
Rect(250, 100, 100, 200, fill='red')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# This code 'looks right', but it contains an error: the blue rectangle is too
# large! The autograder will not accept it until the blue rectangle is not
# overlapped by the yellow and red rectangles.
Rect(50, 100, 100, 200, fill='blue')

# This correctly draws the yellow and red rectangles.
Rect(150, 100, 100, 200, fill='yellow')
Rect(250, 100, 100, 200, fill='red')
",regular,1
1901,Flag of Mali,1.2.2,"# Draw the flag of Mali.
### (HINT: To draw the border, use a Rect with a fill of None and the Inspector
#          to find the borderWidth.)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draws the stripes of the flag.
Rect(50, 100, 100, 200, fill='forestGreen')
Rect(150, 100, 100, 200, fill='gold')
Rect(250, 100, 100, 200, fill='red')

# Draws the border around the flag on top of the stripes.
Rect(50, 100, 300, 200, fill=None, border='black', borderWidth=5)
",regular,1
1903,Flag of Ireland,1.2.2,"# Draw the flag of Ireland!
### (HINT: To draw the border, use Rect with a fill of None and the Inspector to
#          find the borderWidth.)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the flag of Ireland!
# Draws the stripes of the flag.
Rect(50, 100, 100, 200, fill='green')
Rect(250, 100, 100, 200, fill='orange')

# Draws the border around the flag on top of the stripes.
Rect(50, 100, 300, 200, fill=None, border='black', borderWidth=5)
",regular,1
1904,Flag of Sweden,1.2.2,"# Draw the flag of Sweden. Be sure to use the Inspector!
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the flag of Sweden. Be sure to use the Inspector!
Rect(50, 100, 300, 200, fill='steelBlue')
Rect(50, 180, 300, 40, fill='gold')
Rect(140, 100, 40, 200, fill='gold')
",regular,2
1906,Colors and Gradients Checkpoint 4,1.2.3.1,"# Edit only the start values of these 4 rectangles so their gradients
# match the solution.
### Modify Your Code Here ###
Rect( 40, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
Rect(125, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
Rect(210, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
Rect(295, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect( 40, 50, 70, 70, fill=gradient('red', 'blue', start='right-bottom'))
Rect(125, 50, 70, 70, fill=gradient('red', 'blue', start='top'))
Rect(210, 50, 70, 70, fill=gradient('red', 'blue', start='left-bottom'))
Rect(295, 50, 70, 70, fill=gradient('red', 'blue', start='right'))
",regular,1
1907,Colors and Gradients Checkpoint 5,1.2.3.1,"# Edit the gradients below to match the solution!
### Modify Your Code Here ###
Rect( 40, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
Rect(125, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
Rect(210, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
Rect(295, 50, 70, 70, fill=gradient('red', 'blue', start='left'))
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect( 40, 50, 70, 70, fill=gradient('hotPink', 'yellow', 'blue', start='left'))
Rect(125, 50, 70, 70, fill=gradient('red', 'yellow', 'hotPink', 'yellow', 'red',
                                    start='left-bottom'))
Rect(210, 50, 70, 70, fill=gradient('hotPink', 'blue', start='left-top'))
Rect(295, 50, 70, 70, fill=gradient('red', 'orange', 'yellow', 'blue'))
",regular,1
1905,Colors and Gradients Checkpoint 3,1.2.3.1,"# Edit the fill of this rectangle so it matches the red and yellow radial gradient
# in the solution.
### Modify Your Code Here ###
Rect(150, 150, 100, 100)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(150, 150, 100, 100, fill=gradient('red', 'yellow'))
",regular,1
1908,Hazy sun,1.2.4,"# Draw the solution image.
### (HINT: There are only two rectangles in the solution and
#          both have gradients!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the solution image.
# The top rectangle draws the sky and the sun.
Rect(0, 0, 400, 300, fill=gradient('gold', 'skyBlue', 'steelBlue'))

# The bottom rectangle draws the grass.
Rect(0, 300, 400, 100, fill=gradient('seaGreen', 'paleGreen', start='bottom'))
",regular,1
1909,Diamond pickaxe,1.2.4,"# Make the handle wood colored.
### Modify Your Code Here ###
Rect(125, 125, 75, 75)
Rect(200, 200, 75, 75)
Rect(275, 275, 75, 75)
Rect(50, 50, 40, 40)

# Give the pickaxe a diamond gradient!
### Modify Your Code Here ###
Rect(100, 50, 200, 40)
Rect(50, 100, 40, 200)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Make the handle wood colored.
Rect(125, 125, 75, 75, fill=gradient('peru', 'maroon'))
Rect(200, 200, 75, 75, fill=gradient('peru', 'maroon'))
Rect(275, 275, 75, 75, fill=gradient('peru', 'maroon'))
Rect(50, 50, 40, 40, fill=gradient('peru', 'maroon'))

# Give the pickaxe a diamond gradient!
Rect(100, 50, 200, 40, fill=gradient('royalBlue', 'deepSkyBlue', 'dodgerBlue',
                                     start='top'))
Rect(50, 100, 40, 200, fill=gradient('royalBlue', 'deepSkyBlue', 'dodgerBlue',
                                     start='left'))
",regular,1
1910,Nine gradients,1.2.4,"# Here is some starter code: the following rectangles are in the right locations
# for the top row, but they still need gradient fills.
### Modify Your Code Here ###
Rect(25, 25, 100, 100, fill='blue')
Rect(150, 25, 100, 100, fill='blue')
Rect(275, 25, 100, 100, fill='blue')

# Here is the first of the three rectangles in the middle row.
### Modify & Place Your Code Here ###
Rect(25, 150, 100, 100, fill='blue')

# Here is the first of the three rectangles in the bottom row.
### Modify & Place Your Code Here ###
Rect(25, 275, 100, 100, fill='blue')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the top row.
Rect(25, 25, 100, 100, fill=gradient('red', 'yellow', start='left-top'))
Rect(150, 25, 100, 100, fill=gradient('red', 'yellow', start='top'))
Rect(275, 25, 100, 100, fill=gradient('red', 'yellow', start='right-top'))

# Draw the middle row.
Rect(25, 150, 100, 100, fill=gradient('red', 'yellow', start='left'))
Rect(150, 150, 100, 100, fill=gradient('red', 'yellow'))
Rect(275, 150, 100, 100, fill=gradient('red', 'yellow', start='right'))

# Draw the bottom row.
Rect(25, 275, 100, 100, fill=gradient('red', 'yellow', start='left-bottom'))
Rect(150, 275, 100, 100, fill=gradient('red', 'yellow', start='bottom'))
Rect(275, 275, 100, 100, fill=gradient('red', 'yellow', start='right-bottom'))
",regular,1
1911,Orange juice,1.2.4,"# Draw the background.
### Place Your Code Here ###

# Draw the glass and the orange juice.
### Place Your Code Here ###

# Draw the ice cubes.
### Place Your Code Here ###

# Draw the straw.
### (HINT: The straw uses 2 rectangles that only overlap on the edges.)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the background.
Rect(0, 0, 400, 400, fill=gradient('turquoise', 'paleTurquoise'))

# Draw the glass and the orange juice.
Rect(110, 100, 180, 250, fill='azure')
Rect(120, 150, 160, 190, fill=gradient('gold', 'yellow', start='bottom'))

# Draw the ice cubes.
Rect(130, 170, 40, 40, fill=rgb(255, 255, 200))
Rect(190, 200, 30, 30, fill=rgb(255, 255, 200))

# Draw the straw.
Rect(240, 60, 10, 270,
     fill=gradient('orange', 'orange', 'orange', 'red', start='bottom'))
Rect(240, 50, 50, 10, fill='red')
",regular,2
1913,Opacity Checkpoint 2,1.2.5.1,"# Draw the 5 Rects in the solution.
### (HINT: If you aren't sure what order the Rects should be in, try an ordering
#          and see if it looks right. If not, try another order!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the 5 Rects in the solution.
# Draw the top left and bottom right Rects first, with an opacity.
Rect(0, 0, 200, 200, fill='lime', opacity=50)
Rect(200, 200, 200, 200, fill='aqua', opacity=50)

# Then draw the middle Rect with no opacity.
Rect(50, 50, 300, 300, fill='midnightBlue')

# Finally, draw the bottom left and top right Rects, again with opacity.
Rect(200, 0, 200, 200, fill='red', opacity=50)
Rect(0, 200, 200, 200, fill='deepPink', opacity=50)
",regular,1
1912,Opacity Checkpoint 1,1.2.5.1,"# Edit the opacity of the 4 blue rectangles so the drawing matches the solution.
### Modify Your Code Here ###
Rect( 20, 70, 360, 30, fill='yellow')
Rect( 40, 50, 70, 70, fill='blue')
Rect(125, 50, 70, 70, fill='blue')
Rect(210, 50, 70, 70, fill='blue')
Rect(295, 50, 70, 70, fill='blue')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect( 20, 70, 360, 30, fill='yellow')
Rect( 40, 50, 70, 70, fill='blue', opacity=50)
Rect(125, 50, 70, 70, fill='blue', opacity=75)
Rect(210, 50, 70, 70, fill='blue')
Rect(295, 50, 70, 70, fill='blue', opacity=25)
",regular,1
1914,Glasses,1.2.6,"# face
Rect(0, 0, 400, 400, fill='papayaWhip')

# eyes
Rect(55, 150, 80, 30)
Rect(265, 150, 80, 30)

# mouth
Rect(150, 300, 100, 10)
Rect(180, 320, 40, 20)

# Use 3 rectangles to draw the glasses.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# face
Rect(0, 0, 400, 400, fill='papayaWhip')

# eyes
Rect(55, 150, 80, 30)
Rect(265, 150, 80, 30)

# mouth
Rect(150, 300, 100, 10)
Rect(180, 320, 40, 20)

# Use 3 rectangles to draw the glasses.
Rect(20, 130, 150, 100, fill='saddleBrown', border='maroon', opacity=60)
Rect(230, 130, 150, 100, fill='saddleBrown', border='maroon', opacity=60)
Rect(170, 175, 60, 10, fill='maroon')
",regular,1
1915,Opaque frame,1.2.6,"# four red rectangles
Rect(0, 0, 400, 50, fill='red', opacity=50)
Rect(0, 0, 50, 400, fill='red', opacity=50)
Rect(350, 0, 50, 400, fill='red', opacity=50)
Rect(0, 350, 400, 50, fill='red', opacity=50)

# Draw 4 blue rectangles on top of the red rectangles.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# four red rectangles
Rect(0, 0, 400, 50, fill='red', opacity=50)
Rect(0, 0, 50, 400, fill='red', opacity=50)
Rect(350, 0, 50, 400, fill='red', opacity=50)
Rect(0, 350, 400, 50, fill='red', opacity=50)

# Draw 4 blue rectangles on top of the red rectangles.
Rect(0, 25, 400, 100, fill='blue', opacity=50)
Rect(25, 0, 100, 400, fill='blue', opacity=50)
Rect(275, 0, 100, 400, fill='blue', opacity=50)
Rect(0, 275, 400, 100, fill='blue', opacity=50)
",regular,1
1916,Stained glass window,1.2.6,"# background
Rect(0, 0, 400, 400, fill='deepSkyBlue')

# house
Rect(0, 275, 400, 125, fill='silver')
Rect(110, 70, 180, 205, fill='saddleBrown')
Rect(145, 105, 30, 40, fill='lightSkyBlue', border='black')
Rect(225, 105, 30, 40, fill='lightSkyBlue', border='black')
Rect(145, 165, 30, 40, fill='lightSkyBlue', border='black')
Rect(225, 165, 30, 40, fill='lightSkyBlue', border='black')
Rect(177, 215, 45, 60, fill='darkRed')
Rect(0, 0, 400, 400, fill=None, border='wheat', borderWidth=40)

# frame
Rect(40, 40, 320, 320, fill=None, border='black', borderWidth=10)

# Draw the stained glass window.
### (HINT: There should be nine rectangles.)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='deepSkyBlue')

# house
Rect(0, 275, 400, 125, fill='silver')
Rect(110, 70, 180, 205, fill='saddleBrown')
Rect(145, 105, 30, 40, fill='lightSkyBlue', border='black')
Rect(225, 105, 30, 40, fill='lightSkyBlue', border='black')
Rect(145, 165, 30, 40, fill='lightSkyBlue', border='black')
Rect(225, 165, 30, 40, fill='lightSkyBlue', border='black')
Rect(177, 215, 45, 60, fill='darkRed')
Rect(0, 0, 400, 400, fill=None, border='wheat', borderWidth=40)

# frame
Rect(40, 40, 320, 320, fill=None, border='black', borderWidth=10)

# Draw the stained glass window.
Rect(50, 50, 100, 100, fill='red', border='black', opacity=50)
Rect(50, 150, 100, 100, fill='yellow', border='black', opacity=50)
Rect(150, 50, 100, 100, fill='yellow', border='black', opacity=50)
Rect(50, 250, 100, 100, fill='darkTurquoise', border='black', opacity=50)
Rect(150, 150, 100, 100, fill='darkTurquoise', border='black', opacity=50)
Rect(250, 50, 100, 100, fill='darkTurquoise', border='black', opacity=50)
Rect(150, 250, 100, 100, fill='dodgerBlue', border='black', opacity=50)
Rect(250, 150, 100, 100, fill='dodgerBlue', border='black', opacity=50)
Rect(250, 250, 100, 100, fill='blueViolet', border='black', opacity=50)
",regular,2
1917,"Rectangles, Ovals, Circles, and Lines Checkpoint 1",1.3.1.1,"# Without changing the green rectangle, move the
# gold oval so it is centered inside the rectangle.
### Modify Your Code Here ###
Rect(200, 200, 150, 50, fill='green')
Oval(200, 200, 150, 50, fill='gold')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(200, 200, 150, 50, fill='green')
Oval(275, 225, 150, 50, fill='gold')
",regular,1
1918,"Rectangles, Ovals, Circles, and Lines Checkpoint 2",1.3.1.1,"# Draw the oval that fills the left half of the canvas from top to bottom.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Oval(100, 200, 200, 400, fill=gradient('blue', 'cyan'), border='black',
     borderWidth=5)
",regular,1
1919,"Rectangles, Ovals, Circles, and Lines Checkpoint 4",1.3.1.1,"# Draw a 300x300 navy square centered at (200, 200) and a cyan circle
# centered inside that square with a radius that just fills the square.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(50, 50, 300, 300, fill='navy')
Circle(200, 200, 150, fill='cyan')
",regular,1
1920,"Rectangles, Ovals, Circles, and Lines Checkpoint 5",1.3.1.1,"Oval(200, 200, 300, 100, fill='orange')

### (HINT: Use the inspector to find the lineWidth!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Oval(200, 200, 300, 100, fill='orange')
Line(50, 200, 200, 150, lineWidth=10)
",regular,1
1923,Midnight sky,1.3.2,"# background
Rect(0, 0, 400, 400)

# Draw the rest of the night sky!
### (HINT: The rings of Saturn are drawn using a circle with a fill of None and
#          a border!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400)

# saturn with rings
Circle(50, 50, 35, fill=None, border='white', opacity=30)
Circle(50, 50, 30, fill=gradient('peru', 'wheat'))

# venus
Circle(150, 100, 25, fill=gradient('crimson', 'lightSalmon', start='left-bottom'),
       opacity=70)

# shooting star
Line(100, 200, 275, 125, fill=gradient('black', 'white', start='right'),
     lineWidth=3)

# moon
Circle(250, 250, 60, fill=gradient('black', 'grey', start='left'))

# clouds
Oval(150, 275, 100, 50, fill=gradient('black', 'grey', start='left'), opacity=90)
Oval(125, 300, 100, 50, fill=gradient('black', 'grey', start='left'), opacity=90)
Oval(200, 300, 100, 50, fill=gradient('black', 'grey', start='right'), opacity=90)
",regular,2
1925,Cube,1.3.2,"# front face of the cube
Rect(70, 150, 200, 200, fill=None, border='limeGreen')

# Draw the rest of the cube using lines.
### (HINT: The gradients use a start of left or right.)
### (HINT: Use dashes to add depth to the cube and distinguish the 'back' of the
#          cube from the 'front'.)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# front face of the cube
Rect(70, 150, 200, 200, fill=None, border='limeGreen')

# Draw the rest of the cube using lines.
Line(130, 70, 330, 70, fill='darkViolet')
Line(330, 70, 330, 270, fill='darkViolet')
Line(70, 150, 130, 70, fill=gradient('limeGreen', 'darkViolet', start='left'))
Line(270, 350, 330, 270, fill=gradient('limeGreen', 'darkViolet', start='left'))
Line(270, 150, 330, 70, fill=gradient('limeGreen', 'darkViolet', start='left'))

# Use dashes to distinguish the back part of the cube from the front.
Line(70, 350, 130, 270, fill=gradient('limeGreen', 'darkViolet', start='left'),
     dashes=True)
Line(130, 270, 330, 270, fill='darkViolet', dashes=True)
Line(130, 270, 130, 70, fill='darkViolet', dashes=True)
",regular,2
1924,Sunny road,1.3.2,"# sky
Rect(0, 0, 400, 250, fill=gradient('deepSkyBlue', 'lightSkyBlue', start='top'))

# grass
Rect(0, 250, 400, 150, fill=gradient('lawnGreen', 'green', 'lawnGreen',
                                     'lawnGreen', 'green', start='top'))

# The center line in the road is missing. Add it in!
Rect(0, 275, 400, 100, fill=gradient('darkGray', 'dimGray', start='top'))
### (HINT: The road divider should be a dashed line.)
### Place Your Code Here ###

# car 1
Rect(20, 270, 70, 30, fill=gradient('crimson', 'darkRed', start='top'))
Rect(30, 250, 50, 20, fill=gradient('red', 'crimson', start='top'))
Circle(35, 300, 10)
Circle(75, 300, 10)

# car 2
Rect(300, 330, 70, 30, fill=gradient('darkOrange', 'orangeRed', start='top'))
Rect(310, 310, 50, 20, fill=gradient('orange', 'darkOrange', start='top'))
Circle(315, 360, 10)
Circle(355, 360, 10)

# Fix the rays of the sun so that they are dashed.
### Fix Your Code Here ###
Circle(0, 0, 70, fill=gradient('orange', 'yellow'))
Line(10, 75, 10, 155, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5)
Line(35, 70, 75, 140, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5)
Line(55, 55, 125, 100, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5)
Line(70, 30, 145, 50, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5)
Line(75, 5, 155, 5, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# sky
Rect(0, 0, 400, 250, fill=gradient('deepSkyBlue', 'lightSkyBlue', start='top'))

# grass
Rect(0, 250, 400, 150, fill=gradient('lawnGreen', 'green', 'lawnGreen',
                                     'lawnGreen', 'green', start='top'))

# The center line in the road is missing. Add it in!
Rect(0, 275, 400, 100, fill=gradient('darkGray', 'dimGray', start='top'))
Line(0, 325, 400, 325, fill='white', lineWidth=3, dashes=True)

# car 1
Rect(20, 270, 70, 30, fill=gradient('crimson', 'darkRed', start='top'))
Rect(30, 250, 50, 20, fill=gradient('red', 'crimson', start='top'))
Circle(35, 300, 10)
Circle(75, 300, 10)

# car 2
Rect(300, 330, 70, 30, fill=gradient('darkOrange', 'orangeRed', start='top'))
Rect(310, 310, 50, 20, fill=gradient('orange', 'darkOrange', start='top'))
Circle(315, 360, 10)
Circle(355, 360, 10)

# Fix the rays of the sun so that they are dashed.
Circle(0, 0, 70, fill=gradient('orange', 'yellow'))
Line(10, 75, 10, 155, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5, dashes=True)
Line(35, 70, 75, 140, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5, dashes=True)
Line(55, 55, 125, 100, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5, dashes=True)
Line(70, 30, 145, 50, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5, dashes=True)
Line(75, 5, 155, 5, fill=gradient('yellow',  'skyBlue', start='top'),
     lineWidth=5, dashes=True)
",regular,1
1921,Rainbow!,1.3.2,"# This background is given to you.
Rect(0, 0, 400, 400, fill='lightSkyBlue')

# Draw the rainbow using circles and gradients.
### Place Your Code Here ###

# Now draw grass that covers the bottom half of the circles.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Change the background.
Rect(0, 0, 400, 400, fill='lightSkyBlue')

# Draw the rainbow using circles and gradients.
Circle(200, 300, 200, fill=gradient('white', 'red', 'white', start='top'))
Circle(200, 300, 170, fill=gradient('white', 'orange', 'white', start='top'))
Circle(200, 300, 140, fill=gradient('white', 'yellow', 'white', start='top'))
Circle(200, 300, 110, fill=gradient('white', 'green', 'white', start='top'))
Circle(200, 300, 80, fill=gradient('white', 'blue', 'white', start='top'))
Circle(200, 300, 50, fill=gradient('white', 'indigo', 'white', start='top'))
Circle(200, 300, 20, fill=gradient('white', 'violet', 'white', start='top'))

# Now draw grass that covers the bottom half of the circles.
Rect(0, 300, 400, 100, fill=gradient('limeGreen', 'forestGreen', start='top'))
",regular,1
1922,Fix the Soccer field,1.3.2,"# background
Rect(0, 0, 400, 400, fill='forestGreen')

# This code 'looks right', but it contains an error: the outline of the field
# is drawn using four lines! The autograder will not accept it unless the
# outline is drawn using a rectangle.
### (HINT: One rectangle can draw the same field outline as these four lines!)
### Fix Your Code Here ###
Line(50, 100, 350, 100, fill='white')
Line(50, 100, 50, 300, fill='white')
Line(350, 100, 350, 300, fill='white')
Line(50, 300, 350, 300, fill='white')

# penalty box
Circle(85, 200, 25, fill=None, border='white')
Circle(315, 200, 25, fill=None, border='white')
Rect(50, 150, 50, 100, fill='forestGreen', border='white')
Rect(300, 150, 50, 100, fill='forestGreen', border='white')

# center field
Line(200, 100, 200, 300, fill='white')
Circle(200, 200, 25, fill=None, border='white')

# goals
Rect(40, 180, 20, 40, fill='white')
Rect(340, 180, 20, 40, fill='white')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='forestGreen')

# Draws a Rect so that now the autograder recognizes the solution!
Rect(50, 100, 300, 200, fill=None, border='white')

# penalty box
Circle(85, 200, 25, fill=None, border='white')
Circle(315, 200, 25, fill=None, border='white')
Rect(50, 150, 50, 100, fill='forestGreen', border='white')
Rect(300, 150, 50, 100, fill='forestGreen', border='white')

# center field
Line(200, 100, 200, 300, fill='white')
Circle(200, 200, 25, fill=None, border='white')

# goals
Rect(40, 180, 20, 40, fill='white')
Rect(340, 180, 20, 40, fill='white')
",regular,1
1927,Stick person comic,1.3.4,"### There is a lot of code here, so look for the green highlighted lines
### to find where you need to add your code.

Line(200, 0, 200, 400)
Line(0, 200, 400, 200)

# left-top panel
# Uncomment the two lines of code below and fix them so they draw the title.
### Modify Your Code Here ###
# Label('THE TALE OF', 125, 50)
# Label('A PROGRAMMER')

# right-top panel
# Drawing order: speech bubble, computer, stick person 1, stick person 2

# Draw the speech for the top right corner using a label.
### Modify Your Code Here ###
# Label('I do not get your code')

Oval(300, 40, 175, 50, fill=None, border='black')
Line(320, 65, 340, 90)
Line(330, 65, 340, 90)

Rect(200, 120, 10, 50, fill='grey', border='black')
Rect(200, 175, 25, 10, fill='grey', border='black')

Rect(242, 150, 16, 50, fill='lightSkyBlue', border='black')
Line(255, 155, 215, 170)
Circle(250, 135, 15, fill='white', border='black')
Circle(244, 135, 2)

Line(340, 140, 310, 130)
Line(310, 130, 340, 110)
Rect(332, 135, 16, 65, fill='lightGreen', border='black')
Circle(340, 120, 15, fill='white', border='black')
Circle(334, 120, 2)

# left-bottom panel
# Drawing order: speech bubble, computer, stick person 1, stick person 2

# Draw the speech for the bottom left corner using a label.
### Modify Your Code Here ###
# Label()

Oval(100, 240, 120, 50, fill=None, border='black')
Line(80, 265, 70, 290)
Line(90, 265, 70, 290)

Rect(0, 320, 10, 50, fill='grey', border='black')
Rect(0, 375, 25, 10, fill='grey', border='black')

Rect(42, 350, 16, 80, fill='lightSkyBlue', border='black')
Circle(50, 335, 15, fill='white', border='black')
Circle(56, 335, 2)

Rect(132, 335, 16, 80, fill='lightGreen', border='black')
Circle(140, 320, 15, fill='white', border='black')
Circle(134, 320, 2)

# right-bottom panel
# Drawing order: speech bubble, computer, stick person 1, stick person 2

# Draw the speech for the bottom right corner using a label.
### Modify Your Code Here ###
# Label()

Oval(300, 240, 150, 50, fill=None, border='black')
Line(280, 265, 270, 290)
Line(290, 265, 270, 290)

Rect(200, 320, 10, 50, fill='grey', border='black')
Rect(200, 375, 25, 10, fill='grey', border='black')

Line(250, 360, 215, 325)
Line(250, 360, 285, 325)
Rect(242, 350, 16, 80, fill='lightSkyBlue', border='black')
Circle(250, 335, 15, fill='white', border='black')
Line(245, 335, 260, 335, lineWidth=3, dashes=(3, 8))

Line(340, 320, 340, 400)
Rect(332, 335, 16, 80, fill='lightGreen', border='black')
Circle(340, 320, 15, fill='white', border='black')
Line(330, 320, 350, 320, dashes=(5, 7))
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

### There is a lot of code here, so look for the green highlighted lines
### to find where you need to add your code.

Line(200, 0, 200, 400)
Line(0, 200, 400, 200)

# left-top panel
Label('THE TALE OF', 100, 75, fill='lightSkyBlue', size=20, italic=True,
      bold=True)
Label('A PROGRAMMER', 100, 125, fill='lightSkyBlue', size=20, italic=True,
      bold=True)

# right-top panel
# Drawing order: speech bubble, computer, stick person 1, stick person 2

# Draw the speech for the top right corner using a label.
Label('I do not get your code', 300, 40, font='monospace')

Oval(300, 40, 175, 50, fill=None, border='black')
Line(320, 65, 340, 90)
Line(330, 65, 340, 90)

Rect(200, 120, 10, 50, fill='grey', border='black')
Rect(200, 175, 25, 10, fill='grey', border='black')

Rect(242, 150, 16, 50, fill='lightSkyBlue', border='black')
Line(255, 155, 215, 170)
Circle(250, 135, 15, fill='white', border='black')
Circle(244, 135, 2)

Line(340, 140, 310, 130)
Line(310, 130, 340, 110)
Rect(332, 135, 16, 65, fill='lightGreen', border='black')
Circle(340, 120, 15, fill='white', border='black')
Circle(334, 120, 2)

# left-bottom panel
# Drawing order: speech bubble, computer, stick person 1, stick person 2

# Draw the speech for the bottom left corner using a label.
Label('Neither do I', 100, 240, font='monospace')

Oval(100, 240, 120, 50, fill=None, border='black')
Line(80, 265, 70, 290)
Line(90, 265, 70, 290)

Rect(0, 320, 10, 50, fill='grey', border='black')
Rect(0, 375, 25, 10, fill='grey', border='black')

Rect(42, 350, 16, 80, fill='lightSkyBlue', border='black')
Circle(50, 335, 15, fill='white', border='black')
Circle(56, 335, 2)

Rect(132, 335, 16, 80, fill='lightGreen', border='black')
Circle(140, 320, 15, fill='white', border='black')
Circle(134, 320, 2)

# right-bottom panel
# Drawing order: speech bubble, computer, stick person 1, stick person 2

# Draw the speech for the bottom right corner using a label.
Label('But it works!!', 300, 240, font='monospace')

Oval(300, 240, 150, 50, fill=None, border='black')
Line(280, 265, 270, 290)
Line(290, 265, 270, 290)

Rect(200, 320, 10, 50, fill='grey', border='black')
Rect(200, 375, 25, 10, fill='grey', border='black')

Line(250, 360, 215, 325)
Line(250, 360, 285, 325)
Rect(242, 350, 16, 80, fill='lightSkyBlue', border='black')
Circle(250, 335, 15, fill='white', border='black')
Line(245, 335, 260, 335, lineWidth=3, dashes=(3, 8))

Line(340, 320, 340, 400)
Rect(332, 335, 16, 80, fill='lightGreen', border='black')
Circle(340, 320, 15, fill='white', border='black')
Line(330, 320, 350, 320, dashes=(5, 7))
",regular,2
1926,Target,1.3.4,"# draw the target
Circle(200, 150, 100, fill='red')
Circle(200, 150, 70, fill='white')
Circle(200, 150, 35, fill='red')

# You are given the target. Use Label to add the name and complete the logo.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# draw the target
Circle(200, 150, 100, fill='red')
Circle(200, 150, 70, fill='white')
Circle(200, 150, 35, fill='red')

# You are given the target. Use Label to add the name and complete the logo.
Label('TARGET', 200, 300, fill='red', size=65, bold=True)
",regular,1
1928,Nametag,1.3.4,"# Draws the background.
Rect(0, 0, 400, 400, fill=gradient('silver', 'black', start='left-top'))

# Draws the nametag rope and card.
Line(200, 95, 275, -15, fill='crimson', lineWidth=35)
Rect(25, 75, 350, 275, fill=gradient('red', 'orange', 'yellow', 'limeGreen',
                                     'blue', 'purple', start='bottom'))
Line(200, 95, 145, -15, fill='red', lineWidth=35)
Oval(200, 95, 85, 15, fill='grey')

# Draws the blank name-writing section.
Rect(50, 190, 300, 120, fill='white')
Rect(65, 175, 270, 150, fill='white')
Circle(65, 190, 15, fill='white')
Circle(65, 310, 15, fill='white')
Circle(335, 190, 15, fill='white')
Circle(335, 310, 15, fill='white')

# Add the labels to finish the nametag.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draws the background.
Rect(0, 0, 400, 400, fill=gradient('silver', 'black', start='left-top'))

# Draws the nametag rope and card.
Line(200, 95, 275, -15, fill='crimson', lineWidth=35)
Rect(25, 75, 350, 275, fill=gradient('red', 'orange', 'yellow', 'limeGreen',
                                     'blue', 'purple', start='bottom'))
Line(200, 95, 145, -15, fill='red', lineWidth=35)
Oval(200, 95, 85, 15, fill='grey')

# Draws the blank name-writing section.
Rect(50, 190, 300, 120, fill='white')
Rect(65, 175, 270, 150, fill='white')
Circle(65, 190, 15, fill='white')
Circle(65, 310, 15, fill='white')
Circle(335, 190, 15, fill='white')
Circle(335, 310, 15, fill='white')

# Add the labels to finish the nametag.
Label('Hello, my name is', 200, 140, fill='white', size=35, bold=True)
Label('Python', 200, 250, border='black', size=75, bold=True,
      fill=gradient('limeGreen', 'yellow', 'orange', start='top'))
",regular,1
1932,Stars,1.3.6,"# The circle is provided for you.
Circle(200, 200, 200, fill='lemonChiffon')

# Draw the four stars and use the Inspector to find the roundness values.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# The circle is provided for you.
Circle(200, 200, 200, fill='lemonChiffon')

# Draw the four stars and use the Inspector to find the roundness values.
Star(200, 200, 200, 6, fill='lightSalmon', roundness=80)
Star(200, 200, 200, 6, fill='lightCyan', roundness=60)
Star(200, 200, 200, 6, fill='lavender', roundness=40)
Star(200, 200, 200, 6, fill='rosyBrown', roundness=20)
",regular,2
1930,Captain America,1.3.6,"# Create Captain America's shield!
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Create Captain America's shield
Circle(200, 200, 150, fill=gradient('red', 'darkRed', start='left'))
Circle(200, 200, 120, fill=gradient('white', 'darkGrey', start='left'))
Circle(200, 200, 90, fill=gradient('red', 'darkRed', start='left'))
Circle(200, 200, 60, fill=gradient('blue', 'darkBlue', start='left'))
Star(200, 200, 60, 5, fill=gradient('white', 'darkGrey', start='left'))
",regular,1
1929,Flag of Aruba,1.3.6,"# Draw the flag of Aruba.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the flag of Aruba.
Rect(50, 100, 300, 200, fill=rgb(51, 153, 204))
Rect(50, 260, 300, 10, fill='yellow')
Rect(50, 240, 300, 10, fill='yellow')

Star(100, 150, 30, 4, fill='red', border='white')

Label('Aruba', 200, 50, size=30)
",regular,1
1931,Regular polygons,1.3.6,"# Draws a background and the circle on the left.
Rect(0, 0, 400, 400, fill='orchid')
Circle(100, 200, 150, fill='crimson', border='black')

# Draw the polygons.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draws a background and the circle on the left.
Rect(0, 0, 400, 400, fill='orchid')
Circle(100, 200, 150, fill='crimson', border='black')

# Draw the polygons.
RegularPolygon(150, 200, 125, 6, fill='indigo', border='black')
RegularPolygon(200, 200, 100, 5, fill='royalBlue', border='black')
RegularPolygon(250, 200, 75, 4, fill='springGreen', border='black')
RegularPolygon(300, 200, 50, 3, fill='yellow', border='black')
",regular,1
1933,Polygons Checkpoint 1,1.3.7.1,"# Draw a polygon to match the solution canvas!
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Polygon(200, 0, 0, 200, 200, 400, 400, 200, fill='gold')
",regular,1
1935,Diamond,1.3.8,"# draws a background
Rect(0, 0, 400, 400, fill=gradient('powderBlue', 'lightCyan', start='top'))

# Create the outer shape of the diamond using one Polygon.
### Place Your Code Here ###

# Create the brighter inner part of the diamond using a Polygon.
### Place Your Code Here ###

# Create the cut Lines.
### Place Your Code Here ###

# Finish by adding a sparkle to the diamond!
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# draws a background
Rect(0, 0, 400, 400, fill=gradient('powderBlue', 'lightCyan', start='top'))

# Create the outer shape of the diamond using a Polygon.
Polygon(60, 150, 100, 100, 300, 100, 340, 150, 200, 300,
        fill=gradient('white', 'lightBlue'), border='black', borderWidth=4)

# Create the brighter inner part of the diamond using a Polygon.
Polygon(200, 100, 125, 150, 200, 300, 275, 150, fill='azure', border='black')

# Create the cut lines.
Line(60, 150, 340, 150)
Line(100, 100, 125, 150)
Line(300, 100, 275, 150)

# Finish by adding a sparkle to the diamond!
Star(265, 120, 15, 6, fill='white', roundness=15)
",regular,2
1934,Scotty dog,1.3.8,"# Draws the Scotty Dog head.
Polygon(130, 60, 150, 140, 150, 70, 170, 130, 260, 130, 220, 150, 325, 160,
        315, 260, 290, 240, 210, 240, 210, 270, 250, 310, 180, 380, 80, 280,
        130, 205)

# Draw the scarf around the neck.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draws the Scotty Dog head.
Polygon(130, 60, 150, 140, 150, 70, 170, 130, 260, 130, 220, 150, 325, 160,
        315, 260, 290, 240, 210, 240, 210, 270, 250, 310, 180, 380, 80, 280,
        130, 205)

# Draw the scarf around the neck.
Polygon(130, 205, 210, 270, 250, 310, 80, 280, fill='red')
",regular,1
1936,Monarch,1.3.8,"# background
Rect(0, 0, 400, 400, fill=gradient('white', 'skyBlue'))

# wings
Polygon(200, 115, 130, 240, 270, 240, fill='orange')
Polygon(190, 100, 200, 80, 210, 100, 210, 285, 200, 330, 190, 285)
Circle(290, 130, 80)
Circle(110, 130, 80)
Oval(270, 240, 150, 100)
Oval(130, 240, 150, 100)

# dots
Circle(99, 68, 7, fill='white')
Circle(301, 68, 7, fill='white')
Circle(69, 85, 7, fill='white')
Circle(331, 85, 7, fill='white')
Circle(50, 111, 7, fill='white')
Circle(350, 111, 7, fill='white')

# antennae
Line(195, 92, 174, 57)
Line(205, 92, 226, 57)

# top half of the pattern
Polygon(220, 150, 255, 85, 280, 75, 275, 100, fill='orange')
Polygon(240, 165, 275, 115, 330, 100, 300, 140, fill='orange')
Polygon(260, 180, 295, 155, 330, 155, 310, 185, fill='orange')

# Finish the top half of the pattern.
### Place Your Code Here ###

# bottom half of the pattern
Polygon(80, 225, 120, 210, 160, 230, 115, 240, fill='white')
Polygon(180, 250, 125, 245, 105, 270, 145, 270, fill='white')
Polygon(75, 250, 80, 235, 110, 245, 95, 265, fill='white')

# Finish the bottom half of the pattern.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('white', 'skyBlue'))

# wings
Polygon(200, 115, 130, 240, 270, 240, fill='orange')
Polygon(190, 100, 200, 80, 210, 100, 210, 285, 200, 330, 190, 285)
Circle(290, 130, 80)
Circle(110, 130, 80)
Oval(270, 240, 150, 100)
Oval(130, 240, 150, 100)

# dots
Circle(99, 68, 7, fill='white')
Circle(301, 68, 7, fill='white')
Circle(69, 85, 7, fill='white')
Circle(331, 85, 7, fill='white')
Circle(50, 111, 7, fill='white')
Circle(350, 111, 7, fill='white')

# antennae
Line(195, 92, 174, 57)
Line(205, 92, 226, 57)

# top half of the pattern
Polygon(220, 150, 255, 85, 280, 75, 275, 100, fill='orange')
Polygon(240, 165, 275, 115, 330, 100, 300, 140, fill='orange')
Polygon(260, 180, 295, 155, 330, 155, 310, 185, fill='orange')

# Finish the top half of the pattern.
Polygon(180, 150, 145, 85, 120, 75, 125, 100, fill='orange')
Polygon(160, 165, 125, 115, 70, 100, 100, 140, fill='orange')
Polygon(140, 180, 105, 155, 70, 155, 90, 185, fill='orange')

# bottom half of the pattern
Polygon(80, 225, 120, 210, 160, 230, 115, 240, fill='white')
Polygon(180, 250, 125, 245, 105, 270, 145, 270, fill='white')
Polygon(75, 250, 80, 235, 110, 245, 95, 265, fill='white')

# Finish the bottom half of the pattern.
Polygon(320, 225, 280, 210, 240, 230, 285, 240, fill='white')
Polygon(220, 250, 275, 245, 295, 270, 255, 270, fill='white')
Polygon(325, 250, 320, 235, 290, 245, 305, 265, fill='white')
",regular,1
1938,Flag of Antigua and Barbuda,1.4,"# Draw the flag of Antigua and Barbuda!
### (HINT: Use the Inspector to find the left and top of the three rectangles
#          hiding behind the two crimson polygons.)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the flag of Antigua and Barbuda!
Rect(0, 0, 400, 400, fill='powderBlue')

Label('Antigua and Barbuda', 200, 80, size=30)
Rect(50, 120, 300, 80)

Star(200, 200, 50, 15, fill='gold')
Rect(50, 200, 300, 40, fill='royalBlue')
Rect(50, 240, 300, 80, fill='white')

Polygon(50, 120, 50, 320, 200, 320, fill='crimson')
Polygon(350, 120, 350, 320, 200, 320, fill='crimson')
",regular,1
1942,Sailboat,1.4,"# background
Rect(0, 0, 400, 400, fill='wheat')

# Draw the picture shadow.
### (HINT: This should be a RegularPolygon, like the sky.)
### Place Your Code Here ###

# Draw the sky and sun.
### Place Your Code Here ###

# Draw the boat hull, left sail, and right sail.
### Place Your Code Here ###

# Draw the sea.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='wheat')

# Picture shadow.
### (HINT: This should be a RegularPolygon, like the sky.)
RegularPolygon(210, 210, 180, 7, fill='tan')

# sky and sun
RegularPolygon(200, 200, 180, 7, fill='powderBlue')
Circle(270, 200, 65, fill='orangeRed', opacity=70)
Circle(270, 200, 55, fill=gradient('orange', 'orangeRed'))

# Draw the boat hull, left sail, and right sail.
Polygon(60, 205, 90, 240, 160, 240, 190, 205, fill='dimGray')
Polygon(130, 145, 130, 205, 190, 205, fill='limeGreen')
Polygon(60, 205, 125, 205, 125, 135, fill='forestGreen')

# Draw the sea.
Polygon(25, 240, 120, 365, 280, 365, 375, 240, fill='cadetBlue')
",regular,2
1947,Owl,1.4,"# Draw the owl.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='paleGreen')

# body
Circle(200, 250, 140, fill='saddleBrown')
Circle(200, 150, 140, fill='saddleBrown')

# face
Circle(130, 150, 70, fill='tan')
Circle(270, 150, 70, fill='tan')
Oval(200, 175, 260, 130, fill='tan')

# ears
Polygon(275, 30, 320, 20, 325, 90, fill='saddleBrown')
Polygon(125, 30, 80, 20, 75, 90, fill='saddleBrown')

# nose
Polygon(200, 190, 210, 210, 200, 230, 190, 210, fill='goldenrod')

# wings
Polygon(330, 200, 305, 310, 330, 340, 355, 310, fill='goldenrod')
Polygon(70, 200, 45, 310, 70, 340, 95, 310, fill='goldenrod')

# eyes
Circle(150, 130, 35, fill='white')
Circle(250, 130, 35, fill='white')
Circle(150, 130, 10)
Circle(250, 130, 10)
",regular,3
1937,London and Chicago,1.4,"# London Underground
### Place Your Code Here ###

# Chicago CTA
### (HINT: There are two circles and the blue circle shouldn't have a border!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# London Underground
Circle(200, 100, 90, fill=None, border='red', borderWidth=25)
Rect(90, 80, 220, 40, fill='navy')
Label('UNDERGROUND', 200, 100, fill='white', size=25, bold=True)

# Chicago CTA
Circle(200, 300, 85, fill=None, border='red', borderWidth=10)
Circle(200, 300, 70, fill='blue')
Label('cta', 200, 300, fill='white', size=80, bold=True, italic=True)
",regular,1
1939,Poggendorf illusion,1.4,"# First, draw the actual illusion.
### Place Your Code Here ###

# Now, draw a repeat of the illusion, but making the rectangle partly
# transparent, so we can see what's really going on underneath.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# First, draw the actual illusion.
Line(0, 0, 100, 200)
Line(100, 200, 200, 400, fill='red')
Line(100, 185, 200, 385, fill='blue')
Rect(85, 0, 30, 400, fill='grey')

# Now, draw a repeat of the illusion, but making the rectangle partly
# transparent, so we can see what's really going on underneath.
Line(200, 0, 300, 200)
Line(300, 200, 400, 400, fill='red')
Line(300, 185, 400, 385, fill='blue')
Rect(285, 0, 30, 400, fill='grey', opacity=50)
",regular,1
1946,Mickey,1.4,"# Draw the background.
### Place Your Code Here ###

# Draw the head.
### Place Your Code Here ###

# Draw Mickey's mouth.
### (HINT: His mouth is composed of four lines, and three ovals.
#          The peachpuff and salmon ovals hide part of the black oval.)
### Place Your Code Here ###

# Draw Mickey's eyes and nose.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('fireBrick', 'red', start='top'))

# Draw the head.
Circle(200, 200, 100)
Circle(100, 100, 50)
Circle(300, 100, 50)
Oval(230, 190, 70, 120, fill='peachPuff')
Oval(170, 190, 70, 120, fill='peachPuff')
Oval(200, 260, 160, 80, fill='peachPuff')

# Draw Mickey's mouth.
Line(175, 265, 150, 250, fill='peru')
Line(225, 265, 250, 250, fill='peru')
Line(145, 260, 160, 240, fill='peru')
Line(255, 260, 240, 240, fill='peru')
Oval(200, 270, 50, 50)
Oval(200, 245, 80, 50, fill='peachPuff')
Oval(200, 285, 40, 20, fill='salmon')

# Draw Mickey's eyes and nose.
Oval(170, 185, 30, 70, fill='white')
Oval(230, 185, 30, 70, fill='white')
Oval(165, 195, 20, 30)
Oval(225, 195, 20, 30)
Oval(200, 230, 40, 20)
Oval(195, 227.5, 10, 5, fill='white')
",regular,3
1944,A new perspective,1.4,"# background
Rect(0, 0, 400, 400, fill=gradient('white', 'navy'))

# Draw the perspective lines next.
### Place Your Code Here ###

# Draw the ninja here.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('white', 'navy'))

# Draw the perspective lines next.
Line(100, 0, 100, 250)
Line(300, 0, 300, 250)
Line(100, 250, 0, 400)
Line(300, 250, 400, 400)
Line(100, 250, 300, 250)

# face and mask
Circle(200, 200, 70, fill=gradient('lightBlue', 'royalBlue'))
Oval(200, 195, 140, 50)
Polygon(270, 195, 280, 180, 290, 190)

# ninja eyebrows
Line(190, 170, 160, 165, lineWidth=3)
Line(210, 170, 240, 165, lineWidth=3)

# ninja eyes and pupils
Oval(175, 195, 30, 40, fill='white')
Oval(225, 195, 30, 40, fill='white')
Circle(178, 195, 10)
Circle(222, 195, 10)

# shadow
Oval(200, 315, 100, 30)
",regular,2
1948,Lighthouse,1.4,"# Draw the background.
### Place Your Code Here ###

# Draw the rock behind the lighthouse and its reflection.
### (HINT: There is a point of the rock behind the lighthouse!)
### Place Your Code Here ###

# Draw the lighthouse from the top down.
### Place Your Code Here ###

# Draw the light coming from the lighthouse.
### Place Your Code Here ###

# Draw the rock in front of the lighthouse and its reflection.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 250, fill=gradient('midnightBlue', 'steelBlue', start='top'))
Rect(0, 250, 400, 150, fill=gradient('slateBlue', 'darkSlateBlue', start='top'))

# Draw the rock behind the lighthouse and its reflection.
### (HINT: There is a point of the rock behind the lighthouse!)
Polygon(160, 280, 205, 240, 295, 210, 400, 230, 400, 280,
        fill=gradient('darkSlateBlue', 'darkBlue', start='top'))
Polygon(160, 280, 295, 300, 400, 290, 400, 280,
        fill=gradient('darkSlateBlue', 'darkBlue', start='top'), opacity=20)

# Draw the lighthouse from the top down.
Polygon(200, 120, 185, 130, 215, 130,
        fill=gradient('crimson', 'darkRed', start='bottom'))
Rect(190, 130, 20, 20, fill='crimson')
Rect(195, 130, 10, 20, fill='yellow')
Rect(185, 150, 30, 10, fill='fireBrick')
Polygon(190, 160, 185, 220, 215, 220, 210, 160,
        fill=gradient('crimson', 'darkRed', start='top'))
Rect(203, 190, 5, 10)
Polygon(185, 220, 180, 285, 220, 285, 215, 220,
        fill=gradient('snow', 'darkGray', start='top'))

# Draw the light coming from the lighthouse.
Circle(200, 140, 40, fill=gradient('yellow', 'gold', 'orange', start='top'),
       opacity=10)
Polygon(400, 260, 400, 340, 200, 140,
        fill=gradient('yellow', 'gold', 'orange', start='top'), opacity=30)

# Draw the rock in front of the lighthouse and its reflection.
Polygon(145, 240, 235, 265, 270, 290, 120, 290,
        fill=gradient('darkSlateBlue', 'midnightBlue', start='top'))
Polygon(145, 340, 235, 315, 270, 290, 120, 290,
        fill=gradient('darkSlateBlue', 'midnightBlue', start='top'), opacity=30)
",regular,3
1940,Flag of Rwanda,1.4,"# Draw the flag of Rwanda.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the flag of Rwanda.
Rect(50, 100, 300, 100, fill=rgb(0, 163, 224))
Rect(50, 200, 300, 50, fill=rgb(250, 210, 0))
Rect(50, 250, 300, 50, fill=rgb(0, 111, 61))
Star(300, 150, 35, 24, fill=rgb(243, 173, 30), roundness=30)
Circle(300, 150, 10, fill=None, border=rgb(0, 163, 224))
Label('Rwanda', 200, 50, size=30)
",regular,1
1941,Logos,1.4,"# Instagram
### Place Your Code Here ###

# YouTube
### Place Your Code Here ###

# Microsoft
### Place Your Code Here ###

# Uber
### (HINT: Use a line to connect the outer and inner black sections through the
#          circle!)
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Instagram
Rect(20, 20, 160, 160, fill=None, borderWidth=15,
     border=gradient('darkOrchid', 'red', 'orange', start='right-top'))
Circle(100, 100, 40, fill=None, borderWidth=15,
       border=gradient('darkOrchid', 'orange', start='right-top'))
Circle(150, 50, 10, fill='darkOrchid')

# YouTube
Rect(205, 40, 185, 120, fill='red')
Polygon(270, 70, 270, 130, 330, 100, fill='white')

# Microsoft
Rect(15, 210, 85, 85, fill=rgb(246, 83, 20))
Rect(110, 210, 85, 85, fill=rgb(124, 187, 0))
Rect(15, 305, 85, 85, fill=rgb(0, 161, 241))
Rect(110, 305, 85, 85, fill=rgb(255, 187, 0))

# Uber
Rect(210, 210, 180, 180)
Circle(300, 300, 70, fill='white')
Rect(275, 275, 50, 50)
Line(210, 300, 300, 300, lineWidth=10)
",regular,2
1943,Jellyfish,1.4,"# Draw the background.
### Place Your Code Here ###

# Draw the body.
### (HINT: Use two circles and then a rectangle to cover up the bottom half of
#          the circles.)
### Place Your Code Here ###

# Then, draw the tentacles and the rest of the face.
### (HINT: Use a circle and then a rectangle to create the mouth.)
### Place Your Code Here ###

# Finally, draw the bubbles!
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the background.
Rect(0, 0, 400, 400, fill=rgb(55, 225, 205))

# Draw the body.
Circle(200, 300, 105, fill=rgb(250, 200, 230))
Circle(200, 300,  90, fill=rgb(250, 220, 240))
Rect(95, 300, 210, 100, fill=rgb(55, 225, 205))

# Then, draw the tentacles and the rest of the face.
Rect(120, 300, 20, 80, fill=rgb(250, 220, 240))
Rect(155, 300, 20, 80, fill=rgb(250, 220, 240))
Rect(190, 300, 20, 80, fill=rgb(250, 220, 240))
Rect(225, 300, 20, 80, fill=rgb(250, 220, 240))
Rect(260, 300, 20, 80, fill=rgb(250, 220, 240))

# eyes and pupils
Circle(155, 265, 10)
Circle(245, 265, 10)
Circle(155, 260, 5, fill='grey')
Circle(245, 260, 5, fill='grey')

# mouth
Circle(200, 265, 15, fill=rgb(250, 120, 180))
Rect(185, 250, 30, 15, fill=rgb(250, 220, 240))

# Finally, draw the bubbles!
Circle(120,  60, 40, fill='white', opacity=10)
Circle(120, 140, 30, fill='white', opacity=30)
Circle(120, 200, 20, fill='white', opacity=50)
Circle(120, 240, 10, fill='white', opacity=70)
Circle(120, 270, 5, fill='white', opacity=90)
",regular,2
1945,Android,1.4,"# Draw the head.
### Place Your Code Here ###

# Draw the eyes and then the antennas.
### Place Your Code Here ###

# Draw the main body (with rounded bottom corners).
### Place Your Code Here ###

# Draw the legs.
### Place Your Code Here ###

# Draw the arms.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Draw the head.
Circle(200, 140, 80, fill=rgb(164, 198, 57))
Rect(120, 140, 160, 10, fill='white')

# Draw the eyes and then the antennas.
Circle(160, 105, 5, fill='white')
Circle(240, 105, 5, fill='white')
Line(200, 140, 250, 45, fill=rgb(164, 198, 57))
Line(200, 140, 150, 45, fill=rgb(164, 198, 57))

# Draw the main body (with rounded bottom corners).
Circle(135, 270, 15, fill=rgb(164, 198, 57))
Circle(265, 270, 15, fill=rgb(164, 198, 57))
Rect(120, 150, 160, 120, fill=rgb(164, 198, 57))
Rect(135, 270, 130, 15, fill=rgb(164, 198, 57))

# Draw the legs.
Rect(150, 285, 40, 40, fill=rgb(164, 198, 57))
Circle(170, 325, 20, fill=rgb(164, 198, 57))
Rect(210, 285, 40, 40, fill=rgb(164, 198, 57))
Circle(230, 325, 20, fill=rgb(164, 198, 57))

# Draw the arms.
Rect(70, 165, 40, 80, fill=rgb(164, 198, 57))
Circle(90, 165, 20, fill=rgb(164, 198, 57))
Circle(90, 245, 20, fill=rgb(164, 198, 57))
Rect(290, 165, 40, 80, fill=rgb(164, 198, 57))
Circle(310, 165, 20, fill=rgb(164, 198, 57))
Circle(310, 245, 20, fill=rgb(164, 198, 57))
",regular,3
1952,Painters,1.5,"### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# wall
Rect(0, 0, 400, 400, fill='whiteSmoke')

# paint
Rect(0, 200, 400, 200, fill='mediumPurple')
Oval(330, 210, 150, 110, fill='mediumPurple')
Oval(230, 160, 150, 150, fill='mediumPurple')
Oval(120, 150, 150, 190, fill='mediumPurple')
Oval(70, 210, 200, 150, fill='mediumPurple')

# paint bucket
Rect(35, 370, 30, 30)
Circle(50, 370, 15, fill=None, border='black')
Line(40, 370, 60, 370, fill='darkViolet', lineWidth=4)

# brush on the bottom
Line(145, 260, 145, 220, fill='white', lineWidth=4)
Line(145, 220, 160, 210, fill='white')
Line(145, 220, 130, 210, fill='white')
Line(160, 205, 130, 205, fill='white', lineWidth=8)

# person on the left
Line(80, 400, 90, 320)
Line(125, 400, 120, 320)
Oval(105, 300, 40, 80)
Rect(85, 300, 40, 40)
Circle(105, 245, 20)
Polygon(90, 275, 90, 300, 70, 330)
Polygon(115, 285, 125, 300, 145, 255)

# ladder
Line(320, 400, 300, 95)
Line(360, 400, 340, 95)
Line(340, 400, 320, 95, lineWidth=40, dashes=(2, 15))

# brush on the top
Line(180, 150, 150, 120, fill='white', lineWidth=4)
Line(150, 120, 145, 100, fill='white')
Line(150, 120, 130, 115, fill='white')
Line(125, 115, 145, 95, fill='white', lineWidth=8)

# person on the right
Line(240, 160, 280, 220, lineWidth=40)
Circle(240, 160, 20)
Circle(220, 130, 20)
Polygon(225, 160, 230, 175, 175, 145)
Polygon(250, 145, 305, 155, 260, 160)
Line(285, 210, 325, 265)
Line(270, 225, 275, 280)
",regular,4
1953,Snowflake,1.5,"### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(0, 0, 400, 400, fill='midnightBlue')

Star(200, 200, 200, 12, fill=None, border='azure', roundness=0)
Star(200, 200, 200, 6, fill=None, border='azure', roundness=70)
Star(200, 200, 185, 6, fill='midnightBlue', border='azure', roundness=55)

RegularPolygon(200, 200, 110, 6, fill=None, border='azure')
Star(200, 200, 160, 6, fill=None, border='azure', borderWidth=3, roundness=10)

Star(200, 200, 105, 6, fill='midnightBlue', border='azure', roundness=40)
Star(200, 200, 105, 6, fill=None, border='azure')
Star(200, 200, 70, 6, fill=None, border='azure', roundness=0)
Circle(200, 200, 15, fill='midnightBlue', border='azure')

# give an opacity to the entire snowflake
Star(200, 200, 200, 6,
     fill=gradient('azure', 'midnightBlue', 'azure', start='left-top'),
     opacity=30, roundness=70)
",regular,4
1949,Mike Wazowski,1.5,"### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='crimson')
Line(0, 200, 400, 200, fill='darkRed', lineWidth=400, opacity=20, dashes=(5, 75))

# horns
Polygon(130, 125, 135, 90, 150, 105,
        fill=gradient('whiteSmoke', 'khaki', start='top'))
Polygon(270, 125, 265, 90, 250, 105,
        fill=gradient('whiteSmoke', 'khaki', start='top'))

# arms
Line(112, 240, 105, 265, lineWidth=8,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))
Line(106, 260, 110, 310, lineWidth=8,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))
Line(293, 225, 290, 310, lineWidth=8,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))

# hands
Line(110, 300, 120, 310, lineWidth=8,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))
Line(290, 300, 280, 310, lineWidth=8,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))
Oval(110, 310, 15, 25,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))
Oval(290, 310, 15, 25,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))

# legs
Line(170, 300, 170, 360, lineWidth=15,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))
Line(230, 300, 230, 360, lineWidth=15,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))

# leg cover
Oval(200, 333, 55, 110, fill='crimson')

# feet
Oval(170, 360, 30, 20,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))
Oval(230, 360, 30, 20,
     fill=gradient('mediumSeaGreen', 'greenYellow', start='left'))

# body
Oval(200, 200, 200, 220,
     fill=gradient('greenYellow', 'greenYellow', 'mediumSeaGreen'))

# mouth
Circle(155, 233, 10, fill='darkGreen')
Circle(155, 235, 10, fill='greenYellow')
Circle(245, 233, 10, fill='darkGreen')
Circle(245, 235, 10, fill='greenYellow')
Oval(200, 232, 100, 50, fill='darkGreen')
Oval(200, 230, 100, 50, fill='greenYellow')

# eye
Circle(200, 160, 50, fill='white')
Circle(200, 160, 25, fill=gradient('mediumSeaGreen', 'seaGreen'))
Star(200, 160, 25, 25, fill=gradient('springGreen', 'mediumSeaGreen'),
     roundness=50)
Circle(200, 160, 15)
Circle(190, 150, 5, fill='white')
Circle(180, 150, 2, fill='white')
",regular,4
1951,Sunset,1.5,"### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# sky and sun
Rect(0, 0, 400, 200, fill=gradient('lightSkyBlue', 'pink', 'coral', start='top'))
Circle(200, 200, 70, fill='orange', opacity=50)
Circle(200, 200, 50, fill='gold')

# ocean
Rect(0, 200, 400, 60, fill='dodgerBlue')
Rect(0, 260, 400, 40, fill='deepSkyBlue')
Rect(0, 300, 400, 100, fill='turquoise')

# the sun's reflections on the water
Oval(200, 204, 120, 5, fill='gold', opacity=80)
Oval(165, 210, 80, 5, fill='gold', opacity=70)
Oval(255, 210, 70, 5, fill='gold', opacity=70)
Oval(230, 217, 95, 5, fill='gold', opacity=70)
Oval(190, 223, 60, 5, fill='gold', opacity=60)
Oval(235, 232, 60, 5, fill='gold', opacity=40)
Oval(155, 232, 60, 5, fill='gold', opacity=40)

# foam
Polygon(0, 400, 0, 280, 300, 335, 400, 320, 400, 400, fill='white')

# sand
Polygon(0, 400, 0, 290, 300, 360, 400, 330, 400, 400, fill='wheat')
Polygon(35, 280, 30, 360, 55, 360, 50, 275, 60, 175, 50, 175, fill='sienna')
Polygon(0, 335, 400, 390, 400, 400, 0, 400, fill='burlyWood')

# tree
Star(55, 175, 60, 9, fill='limeGreen', roundness=50)
Circle(20, 185, 7, fill='maroon')
Star(55, 175, 50, 8, fill='green', roundness=50)
Circle(40, 180, 7, fill='maroon')
Circle(40, 200, 7, fill='maroon')
",regular,4
1950,Aurora Borealis,1.5,"### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# back layer to maintain color
Rect(0, 0, 400, 400, fill=gradient('navy', 'darkCyan', start='top'))

# create the stary effect
Line(0, 400, 400, 0, fill='white', lineWidth=600, dashes=(1, 30))
Line(0, 200, 400, 200, fill=gradient('navy', 'darkCyan', start='top'),
     lineWidth=400, dashes=(25, 1))

# create light effect
Rect(0, 0, 400, 300,
     fill=gradient('whiteSmoke', 'darkMagenta', 'chartreuse', 'lightCyan',
                   'darkMagenta', 'royalBlue', start='right-bottom'), opacity=40)

# overlay to give the night time effect
Rect(0, 0, 400, 300, fill=gradient('black', 'darkCyan', start='top'), opacity=50)

# lake background color and reflection color
Rect(0, 300, 400, 100, fill='midnightBlue')
Rect(0, 300, 400, 100,
     fill=gradient('whiteSmoke', 'darkMagenta',
                   'chartreuse', 'lightCyan', 'darkMagenta', 'royalBlue',
                   start='right-bottom'), opacity=20)

# mountain
Polygon(0, 400, 0, 290, 24, 281, 39, 284, 59, 268, 74, 283, 96, 290, 116, 277,
        126, 258, 140, 269, 157, 282, 178, 280, 189, 271, 220, 260, 244, 270,
        265, 265, 279, 245, 305, 228, 343, 198, 380, 158, 395, 170, 400, 150,
        400, 300, 386, 304, 359, 310, 342, 310, 335, 310, 325, 304, 304, 300,
        280, 303, 246, 315, 210, 324, 159, 319, 127, 324, 92, 330, 70, 325, 55,
        320, 60, 330, 82, 347, 93, 361, 118, 375, 185, 375, 199, 372, 211, 363,
        229, 375, 243, 381, 262, 381, 295, 380, 313, 383, 344, 385, 354, 390,
        376, 392, 389, 396, 400, 400)

# slight mountain highlight
Polygon(0, 400, 0, 290, 24, 281, 39, 284, 59, 268, 74, 283, 96, 290, 116, 277,
        126, 258, 140, 269, 157, 282, 178, 280, 189, 271, 220, 260, 244, 270,
        265, 265, 279, 245, 305, 228, 343, 198, 380, 158, 395, 170, 400, 150,
        400, 300, 386, 304, 359, 310, 342, 310, 335, 310, 325, 304, 304, 300,
        280, 303, 246, 315, 210, 324, 159, 319, 127, 324, 92, 330, 70, 325, 55,
        320, 60, 330, 82, 347, 93, 361, 118, 375, 185, 375, 199, 372, 211, 363,
        229, 375, 243, 381, 262, 381, 295, 380, 313, 383, 344, 385, 354, 390,
        376, 392, 389, 396, 400, 400, opacity=50,
        fill=gradient('black', 'midnightBlue', 'darkBlue', start='bottom'))
",regular,4
1959,Creative task 3,1.6.2,# Fill me in!,,creative,30
1954,Giraffe,1.6.2,"# Some of the best art is inspired by nature.
# This is an example of a giraffe eating leaves off
# an Acacia tree in the hot African Savanna.
# Imagine an image of your own favorite scene in nature and draw it!

# sky
Rect(0, 0, 400, 400, fill='lightBlue')

# ground
Rect(0, 350, 400, 50, fill=gradient('lightGreen', 'forestGreen', start='top'))

# sun
Circle(350, 70, 50, fill=gradient('red', 'orange', 'lightBlue', 'lightBlue'))

# clouds
Circle(50, 70, 30, fill='white', opacity=50)
Circle(90, 62, 30, fill='white', opacity=50)
Circle(90, 78, 30, fill='white', opacity=50)
Circle(130, 70, 30, fill='white', opacity=50)

# tree trunk
Line(270, 170, 280, 240, fill='brown', lineWidth=17)
Line(280, 240, 320, 280, fill='brown', lineWidth=17)
Line(320, 280, 330, 350, fill='brown', lineWidth=17)

# tree leaves
Oval(270, 170, 100, 30, fill='green', opacity=90, align='bottom')
Oval(270, 170, 100, 30, fill='green', opacity=90, align='right')
Oval(270, 170, 100, 30, fill='green', opacity=90, align='left')
Oval(270, 170, 100, 30, fill='green', opacity=90, align='top')

# giraffe legs
Line(140, 350, 140, 320, fill='white', lineWidth=8)
Line(100, 350, 100, 320, fill='white', lineWidth=8)
Line(80, 350, 80, 320, fill='white', lineWidth=8)
Line(140, 320, 140, 270,
     fill=gradient('orange', 'brown', 'orange'), lineWidth=8)
Line(100, 320, 100, 290,
     fill=gradient('orange', 'brown', 'orange'), lineWidth=8)
Line(80, 320, 80, 290, fill=gradient('orange', 'brown', 'orange'), lineWidth=8)

# giraffe body
Oval(110, 275, 100, 40, fill=gradient('orange', 'brown', 'orange'),
     rotateAngle=-20)

# giraffe tail
Line(70, 290, 50, 310, fill=gradient('orange', 'brown', 'orange'))

# giraffe neck
Polygon(140, 250, 155, 265, 170, 230, 160, 220,
        fill=gradient('orange', 'brown', 'orange'))
Line(165, 225, 175, 190, fill=gradient('orange', 'brown', 'orange'), lineWidth=10)

# giraffe head
Polygon(170, 170, 175, 190, 210, 180, 210, 175,
        fill=gradient('orange', 'brown', 'orange', start='top'))
Circle(180, 178, 3)

# giraffe ear
Line(170, 170, 160, 160,
     fill=gradient('white', 'brown', start='top'), lineWidth=3)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Some of the best art is inspired by nature.
# This is an example of a giraffe eating leaves off
# an Acacia tree in the hot African Savanna.
# Imagine an image of your own favorite scene in nature and draw it!

# sky
Rect(0, 0, 400, 400, fill='lightBlue')

# ground
Rect(0, 350, 400, 50, fill=gradient('lightGreen', 'forestGreen', start='top'))

# sun
Circle(350, 70, 50, fill=gradient('red', 'orange', 'lightBlue', 'lightBlue'))

# clouds
Circle(50, 70, 30, fill='white', opacity=50)
Circle(90, 62, 30, fill='white', opacity=50)
Circle(90, 78, 30, fill='white', opacity=50)
Circle(130, 70, 30, fill='white', opacity=50)

# tree trunk
Line(270, 170, 280, 240, fill='brown', lineWidth=17)
Line(280, 240, 320, 280, fill='brown', lineWidth=17)
Line(320, 280, 330, 350, fill='brown', lineWidth=17)

# tree leaves
Oval(270, 170, 100, 30, fill='green', opacity=90, align='bottom')
Oval(270, 170, 100, 30, fill='green', opacity=90, align='right')
Oval(270, 170, 100, 30, fill='green', opacity=90, align='left')
Oval(270, 170, 100, 30, fill='green', opacity=90, align='top')

# giraffe legs
Line(140, 350, 140, 320, fill='white', lineWidth=8)
Line(100, 350, 100, 320, fill='white', lineWidth=8)
Line(80, 350, 80, 320, fill='white', lineWidth=8)
Line(140, 320, 140, 270,
     fill=gradient('orange', 'brown', 'orange'), lineWidth=8)
Line(100, 320, 100, 290,
     fill=gradient('orange', 'brown', 'orange'), lineWidth=8)
Line(80, 320, 80, 290, fill=gradient('orange', 'brown', 'orange'), lineWidth=8)

# giraffe body
Oval(110, 275, 100, 40, fill=gradient('orange', 'brown', 'orange'),
     rotateAngle=-20)

# giraffe tail
Line(70, 290, 50, 310, fill=gradient('orange', 'brown', 'orange'))

# giraffe neck
Polygon(140, 250, 155, 265, 170, 230, 160, 220,
        fill=gradient('orange', 'brown', 'orange'))
Line(165, 225, 175, 190, fill=gradient('orange', 'brown', 'orange'), lineWidth=10)

# giraffe head
Polygon(170, 170, 175, 190, 210, 180, 210, 175,
        fill=gradient('orange', 'brown', 'orange', start='top'))
Circle(180, 178, 3)

# giraffe ear
Line(170, 170, 160, 160,
     fill=gradient('white', 'brown', start='top'), lineWidth=3)
",sample,1
1961,Creative task 5,1.6.2,# Fill me in!,,creative,30
1955,Lantern,1.6.2,"# This Creative Task draws a Chinese lantern! Another great place to look
# for your own Creative Task idea is by looking at other cultures.

# background
Rect(0, 0, 400, 400, fill='midnightBlue')

# light
Oval(200, 200, 340, 340, fill='darkSlateGray')

# loop
Oval(200, 100, 20, 100, fill=None, border='red', borderWidth=8)

# lantern's light
Circle(200, 200, 100, fill=gradient('yellow', 'orange', 'red'))

# decorative lantern's outline
Oval(200, 200, 200, 200, fill=None, border='darkRed', borderWidth=8)
Oval(200, 200, 140, 200, fill=None, border='darkRed', borderWidth=8)
Oval(200, 200, 80, 200, fill=None, border='darkRed', borderWidth=8)
Line(200, 100, 200, 300, fill='darkRed', lineWidth=8)

# decorative lantern strings
### (HINT: With dashes, it is only one line of code to get all of the strings!)
Line(166, 350, 234, 350, fill='red', lineWidth=100, dashes=(8, 2))

Rect(120, 100, 160, 40, fill=gradient('red', 'orangeRed', start='top'),
     border='darkRed', borderWidth=8)
Rect(120, 260, 160, 40, fill=gradient('red', 'orangeRed', start='bottom'),
     border='darkRed', borderWidth=8)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# This Creative Task draws a Chinese lantern! Another great place to look
# for your own Creative Task idea is by looking at other cultures.

# background
Rect(0, 0, 400, 400, fill='midnightBlue')

# light
Oval(200, 200, 340, 340, fill='darkSlateGray')

# loop
Oval(200, 100, 20, 100, fill=None, border='red', borderWidth=8)

# lantern's light
Circle(200, 200, 100, fill=gradient('yellow', 'orange', 'red'))

# decorative lantern's outline
Oval(200, 200, 200, 200, fill=None, border='darkRed', borderWidth=8)
Oval(200, 200, 140, 200, fill=None, border='darkRed', borderWidth=8)
Oval(200, 200, 80, 200, fill=None, border='darkRed', borderWidth=8)
Line(200, 100, 200, 300, fill='darkRed', lineWidth=8)

# decorative lantern strings
### (HINT: With dashes, it is only one line of code to get all of the strings!)
Line(166, 350, 234, 350, fill='red', lineWidth=100, dashes=(8, 2))

Rect(120, 100, 160, 40, fill=gradient('red', 'orangeRed', start='top'),
     border='darkRed', borderWidth=8)
Rect(120, 260, 160, 40, fill=gradient('red', 'orangeRed', start='bottom'),
     border='darkRed', borderWidth=8)
",sample,1
1956,Saloon,1.6.2,"# Pictured here is a saloon from the old Wild West. Along with looking to
# Nature and other cultures for ideas, you can draw inspiration from different
# times and places in history.
### (HINT: Notice how all of the Lines are actually dashed Lines. Using dashes
#          allows us to use a lot less code for the same image!)

# background and environment
Rect(0, 0, 400, 250, fill=gradient('lightBlue', 'burlyWood', start='top'))
Rect(0, 250, 400, 150, fill='lemonChiffon')
Polygon(175, 300, 225, 300, 250, 400, 150, 400, fill='navajoWhite')

# bottom building
Rect(100, 150, 200, 150, fill='sienna')
Line(200, 150, 200, 300, fill='burlyWood', lineWidth=200, dashes=(10, 1))

# bottom windows and door
Rect(115, 230, 35, 55, fill='peru', border='brown')
Line(125, 233, 125, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(140, 233, 140, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(250, 230, 35, 55, fill='peru', border='brown')
Line(260, 233, 260, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(275, 233, 275, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(175, 250, 50, 50, fill='saddleBrown', border='sienna')
Line(200, 250, 200, 300, fill='sienna')
Line(185, 265, 185, 285, fill='peru', lineWidth=20, dashes=(2, 1))
Line(215, 265, 215, 285, fill='peru', lineWidth=20, dashes=(2, 1))

# porch
Polygon(100, 220, 300, 220, 325, 245, 75, 245,
        fill=gradient('saddleBrown', 'sienna', start='top'),
        border='saddleBrown')
Rect(80, 300, 240, 10, fill='sienna', border='brown')
Line(85, 245, 85, 300, fill='brown', lineWidth=8, dashes=(14, 1))
Line(315, 245, 315, 300, fill='brown', lineWidth=8, dashes=(14, 1))
Line(140, 245, 140, 300, fill='brown', lineWidth=8, dashes=(14, 1))
Line(260, 245, 260, 300, fill='brown', lineWidth=8, dashes=(14, 1))

# top of building
Rect(125, 75, 150, 75, fill='sienna')
Line(200, 75, 200, 150, fill='burlyWood', lineWidth=150, dashes=(12, 1))
Rect(90, 140, 220, 10, fill='sienna', border='brown')
Rect(120, 65, 160, 10, fill='sienna', border='brown')

# building sign
Rect(150, 80, 100, 50, fill=gradient('peru', 'burlyWood', start='bottom'),
     border='saddleBrown', borderWidth=4)
Label('Saloon', 200, 105, fill='saddleBrown', size=28)

# top windows
Rect(115, 157, 35, 55, fill='peru', border='brown')
Line(125, 160, 125, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(140, 160, 140, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(183, 157, 35, 55, fill='peru', border='brown')
Line(193, 160, 193, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(208, 160, 208, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(250, 157, 35, 55, fill='peru', border='brown')
Line(260, 160, 260, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(275, 160, 275, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Pictured here is a saloon from the old Wild West. Along with looking to
# Nature and other cultures for ideas, you can draw inspiration from different
# times and places in history.
### (HINT: Notice how all of the Lines are actually dashed Lines. Using dashes
#          allows us to use a lot less code for the same image!)

# background and environment
Rect(0, 0, 400, 250, fill=gradient('lightBlue', 'burlyWood', start='top'))
Rect(0, 250, 400, 150, fill='lemonChiffon')
Polygon(175, 300, 225, 300, 250, 400, 150, 400, fill='navajoWhite')

# bottom building
Rect(100, 150, 200, 150, fill='sienna')
Line(200, 150, 200, 300, fill='burlyWood', lineWidth=200, dashes=(10, 1))

# bottom windows and door
Rect(115, 230, 35, 55, fill='peru', border='brown')
Line(125, 233, 125, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(140, 233, 140, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(250, 230, 35, 55, fill='peru', border='brown')
Line(260, 233, 260, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(275, 233, 275, 283, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(175, 250, 50, 50, fill='saddleBrown', border='sienna')
Line(200, 250, 200, 300, fill='sienna')
Line(185, 265, 185, 285, fill='peru', lineWidth=20, dashes=(2, 1))
Line(215, 265, 215, 285, fill='peru', lineWidth=20, dashes=(2, 1))

# porch
Polygon(100, 220, 300, 220, 325, 245, 75, 245,
        fill=gradient('saddleBrown', 'sienna', start='top'),
        border='saddleBrown')
Rect(80, 300, 240, 10, fill='sienna', border='brown')
Line(85, 245, 85, 300, fill='brown', lineWidth=8, dashes=(14, 1))
Line(315, 245, 315, 300, fill='brown', lineWidth=8, dashes=(14, 1))
Line(140, 245, 140, 300, fill='brown', lineWidth=8, dashes=(14, 1))
Line(260, 245, 260, 300, fill='brown', lineWidth=8, dashes=(14, 1))

# top of building
Rect(125, 75, 150, 75, fill='sienna')
Line(200, 75, 200, 150, fill='burlyWood', lineWidth=150, dashes=(12, 1))
Rect(90, 140, 220, 10, fill='sienna', border='brown')
Rect(120, 65, 160, 10, fill='sienna', border='brown')

# building sign
Rect(150, 80, 100, 50, fill=gradient('peru', 'burlyWood', start='bottom'),
     border='saddleBrown', borderWidth=4)
Label('Saloon', 200, 105, fill='saddleBrown', size=28)

# top windows
Rect(115, 157, 35, 55, fill='peru', border='brown')
Line(125, 160, 125, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(140, 160, 140, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(183, 157, 35, 55, fill='peru', border='brown')
Line(193, 160, 193, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(208, 160, 208, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))

Rect(250, 157, 35, 55, fill='peru', border='brown')
Line(260, 160, 260, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
Line(275, 160, 275, 210, fill='saddleBrown', lineWidth=14, dashes=(16, 1))
",sample,1
1957,Creative task 1,1.6.2,# Fill me in!,,creative,30
1958,Creative task 2,1.6.2,# Fill me in!,,creative,30
1960,Creative task 4,1.6.2,# Fill me in!,,creative,30
1962,Collaborative task,1.6.2,# Fill me in!,,creative,30
1966,Minion,2.1.3,"def drawMinion(minionColor):
    # Change the background to use the function parameter as the fill.
    ### Fix Your Code Here ###
    Rect(0, 0, 400, 400, fill='pink')

    # Add code to draw the mouth!
    ### Place Your Code Here ###

    # glasses
    Rect(0, 100, 400, 60)
    Circle(130, 130, 60, fill='snow', border='dimGray', borderWidth=15)
    Circle(270, 130, 60, fill='snow', border='dimGray', borderWidth=15)

    # eyes
    Circle(130, 130, 25, border='saddleBrown', borderWidth=10)
    Circle(270, 130, 25, border='saddleBrown', borderWidth=10)
    Circle(115, 115, 5, fill='white')
    Circle(255, 115, 5, fill='white')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawMinion(minionColor):
    # Change the background to use the function parameter as the fill.
    Rect(0, 0, 400, 400, fill=minionColor)

    # Add code to draw the mouth!
    Oval(200, 300, 170, 80)
    Oval(200, 280, 170, 80, fill=minionColor)

    # glasses
    Rect(0, 100, 400, 60)
    Circle(130, 130, 60, fill='snow', border='dimGray', borderWidth=15)
    Circle(270, 130, 60, fill='snow', border='dimGray', borderWidth=15)

    # eyes
    Circle(130, 130, 25, border='saddleBrown', borderWidth=10)
    Circle(270, 130, 25, border='saddleBrown', borderWidth=10)
    Circle(115, 115, 5, fill='white')
    Circle(255, 115, 5, fill='white')
",regular,2
1965,Bunny with a spot,2.1.3,"def drawBunny(bunnyColor):
    Rect(0, 0, 400, 400, fill=gradient('dodgerBlue', 'deepSkyBlue'))

    # Change the ears below to use the parameter of the function as the fill.
    ### Fix Your Code Here ###
    Oval(155, 110, 60, 170)
    Oval(245, 110, 60, 170)
    Oval(155, 115, 40, 140, fill=gradient('seashell', 'wheat', start='bottom'))
    Oval(245, 115, 40, 140, fill=gradient('seashell', 'wheat', start='bottom'))

    # head
    Oval(200, 230, 200, 160, fill='white')
    Circle(150, 300, 80, fill='white')
    Circle(250, 300, 80, fill='white')

    # nose
    Polygon(180, 310, 220, 310, 200, 350)

    # Draw the spot around the eye.
    ### Place Your Code Here ###

    # eyes
    Oval(150, 275, 30, 50)
    Oval(150, 270, 10, 20, fill='white')
    Oval(250, 275, 30, 50)
    Oval(250, 270, 10, 20, fill='white')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawBunny(bunnyColor):
    Rect(0, 0, 400, 400, fill=gradient('dodgerBlue', 'deepSkyBlue'))

    # Change the ears below to use the parameter of the function as the fill.
    Oval(155, 110, 60, 170, fill=bunnyColor)
    Oval(245, 110, 60, 170, fill=bunnyColor)
    Oval(155, 115, 40, 140, fill=gradient('seashell', 'wheat', start='bottom'))
    Oval(245, 115, 40, 140, fill=gradient('seashell', 'wheat', start='bottom'))

    # head
    Oval(200, 230, 200, 160, fill='white')
    Circle(150, 300, 80, fill='white')
    Circle(250, 300, 80, fill='white')

    # nose
    Polygon(180, 310, 220, 310, 200, 350)

    # Draw the spot around the eye.
    Oval(250, 270, 60, 100, fill=bunnyColor)

    # eyes
    Oval(150, 275, 30, 50)
    Oval(150, 270, 10, 20, fill='white')
    Oval(250, 275, 30, 50)
    Oval(250, 270, 10, 20, fill='white')
",regular,2
1967,Two hexagons,2.1.3,"def drawTwoHexagons(color):
    # Create two hexagons. Use the function parameter for the fill of the
    # top hexagon and the border of the bottom hexagon!
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawTwoHexagons(color):
    # Create two hexagons. Use the function parameter for the fill of the
    # top hexagon and the border of the bottom hexagon!
    RegularPolygon(200, 100, 100, 6, fill=color)
    RegularPolygon(200, 300, 100, 6, fill=None, border=color, borderWidth=8)
",regular,1
1968,Draw flower,2.1.3,"# sky
Rect(0, 0, 400, 400, fill=gradient('dodgerBlue', 'salmon', start='top'))

# grass
Rect(0, 350, 400, 50, fill=gradient('lawnGreen', 'darkGreen', start='top'))

def drawFlower(points):
    # flower stem
    Line(200, 200, 200, 350, fill='lawnGreen', lineWidth=10)

    # Draw a star with the function parameter as the number of points, then
    # draw a circle on top of the star for the flower's center.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# sky
Rect(0, 0, 400, 400, fill=gradient('dodgerBlue', 'salmon', start='top'))

# grass
Rect(0, 350, 400, 50, fill=gradient('lawnGreen', 'darkGreen', start='top'))

def drawFlower(points):
    # flower stem
    Line(200, 200, 200, 350, fill='lawnGreen', lineWidth=10)

    # Draw a star with the function parameter as the number of points, then
    # draw a circle on top of the star for the flower's center.
    Star(200, 200, 60, points,
         fill=gradient('magenta', 'darkViolet', 'royalBlue'))
    Circle(200, 200, 20, fill=gradient('yellow', 'gold'))
",regular,1
1971,Bee and flower,2.1.5,"def beeAndFlower(backgroundColor, flowerColor):
    # The function currently ignores its parameters and always draws the same
    # image. Use the function parameters to replace hardcoded colors below!
    ### Fix Your Code Here ###

    # background
    Rect(0, 0, 400, 400, fill='lightBlue')

    # flower stem and petals
    Oval(197, 350, 85, 200, fill=rgb(75, 155, 100))
    Star(200, 125, 225, 25, fill='pink', roundness=80)
    Star(200, 125, 275, 24, fill='violet', roundness=60)

    # bee body and stripes
    Oval(80, 150, 100, 60,
         fill=gradient('gold', 'gold', 'gold', 'gold', 'black', 'gold', 'black',
                       'gold', 'black', 'gold', start='right'))

    # bee eye and wings
    Circle(110, 140, 3)
    Oval(80, 112, 40, 75, fill=gradient('gainsboro', 'dimGrey', start='top'),
         opacity=60)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def beeAndFlower(backgroundColor, flowerColor):
    # The function currently ignores its parameters and always draws the same
    # image. Use the function parameters to replace hardcoded colors below!

    # background
    Rect(0, 0, 400, 400, fill=backgroundColor)

    # flower stem and petals
    Oval(197, 350, 85, 200, fill=rgb(75, 155, 100))
    Star(200, 125, 225, 25, fill=flowerColor, roundness=80)
    Star(200, 125, 275, 24, fill=flowerColor, roundness=60)

    # bee body and stripes
    Oval(80, 150, 100, 60,
         fill=gradient('gold', 'gold', 'gold', 'gold', 'black', 'gold', 'black',
                       'gold', 'black', 'gold', start='right'))

    # bee eye and wings
    Circle(110, 140, 3)
    Oval(80, 112, 40, 75, fill=gradient('gainsboro', 'dimGrey', start='top'),
         opacity=60)
",regular,2
1970,Colorful nametag,2.1.5,"# background
Rect(0, 0, 400, 400, fill=gradient('silver', 'black', start='left-top'))

# The nameTag function below draws a nameTag, but it does not use the
# function parameters!
def nameTag(name, color1, color2, color3):
    # Fix the nametag rope so that it uses color1 instead of red!
    ### Fix Your Code Here ###
    Line(200, 95, 275, -15, fill='red', lineWidth=35)
    Rect(25, 75, 350, 275, fill=gradient('red', 'orange', 'yellow', 'limeGreen',
                                         'blue', 'purple', start='bottom'))
    Line(200, 95, 145, -15, fill='red', lineWidth=35)
    Oval(200, 95, 85, 15, fill='grey')

    # Draws the blank name-writing section.
    Rect(50, 190, 300, 120, fill='white')
    Rect(65, 175, 270, 150, fill='white')
    Circle(65, 190, 15, fill='white')
    Circle(65, 310, 15, fill='white')
    Circle(335, 190, 15, fill='white')
    Circle(335, 310, 15, fill='white')

    # Modify all of the labels to use the correct parameters.
    ### Fix Your Code Here ###
    Label('Hello, my name is', 200, 140, fill='white', size=35, bold=True)
    Label('Python', 200, 250, border='black', size=75, bold=True,
          fill=gradient('limeGreen', 'yellow', 'orange', start='top'))
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('silver', 'black', start='left-top'))

# The nameTag function below draws a nameTag, but it does not use the
# function parameters!
def nameTag(name, color1, color2, color3):
    # Fix the nametag rope so that it uses color1 instead of red!
    Line(200, 95, 275, -15, fill=color1, lineWidth=35)
    Rect(25, 75, 350, 275, fill=gradient('red', 'orange', 'yellow', 'limeGreen',
                                         'blue', 'purple', start='bottom'))
    Line(200, 95, 145, -15, fill=color1, lineWidth=35)
    Oval(200, 95, 85, 15, fill='grey')

    # Draws the blank name-writing section.
    Rect(50, 190, 300, 120, fill='white')
    Rect(65, 175, 270, 150, fill='white')
    Circle(65, 190, 15, fill='white')
    Circle(65, 310, 15, fill='white')
    Circle(335, 190, 15, fill='white')
    Circle(335, 310, 15, fill='white')

    # Modify all of the labels to use the correct parameters.
    Label('Hello, my name is', 200, 140, fill='white', size=35, bold=True)
    Label(name, 200, 250, border='black', size=75, bold=True,
          fill=gradient(color1, color2, color3, start='top'))
",regular,1
1972,Three stripe flag,2.1.5,"def threeStripeFlag(country, color1, color2, color3):
    # Fix the label so it uses the function parameter: country.
    ### Fix Your Code Here ###
    Label('country', 200, 60, size=40, bold=True)

    # Draw the rectangles and use the correct function parameters for each one!
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def threeStripeFlag(country, color1, color2, color3):
    # Fix the label so it uses the correct function parameter.
    Label(country, 200, 60, size=40, bold=True)

    # Draw the rectangles and use the correct function parameters for each one!
    Rect(50, 100, 100, 200, fill=color1)
    Rect(150, 100, 100, 200, fill=color2)
    Rect(250, 100, 100, 200, fill=color3)
",regular,1
1969,Scoreboard,2.1.5,"# The scoreboard function below draws the scoreboard but currently ignores
# the parameters that would draw the time remaining and the score.
def scoreboard(timeLeft, homeScore, awayScore):
    Rect(0, 0, 400, 400, fill='cornflowerBlue')

    # Display the time remaining.
    ### Fix Your Code Here ###
    Rect(50, 0, 300, 150)
    Rect(35, 0, 330, 165, fill=None, border='white', borderWidth=5)
    Rect(165, 150, 70, 30, fill='cornflowerBlue')
    Label('TIME', 200, 165, fill='white', size=20)
    Label('15:00', 200, 75, fill='goldenrod', size=80, font='monospace',
          bold=True)

    # Display the home team's score.
    ### Place Your Code Here ###
    Label('HOME', 100, 220, fill='white', size=60, font='monospace', bold=True)
    Rect(25, 250, 150, 100)

    # Display the away team's score.
    ### Place Your Code Here ###
    Label('AWAY', 300, 220, fill='white', size=60, font='monospace', bold=True)
    Rect(225, 250, 150, 100)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# The scoreboard function below draws the scoreboard but currently ignores
# the parameters that would draw the time remaining and the score.
def scoreboard(timeLeft, homeScore, awayScore):
    Rect(0, 0, 400, 400, fill='cornflowerBlue')

    # time section
    Rect(50, 0, 300, 150)
    Rect(35, 0, 330, 165, fill=None, border='white', borderWidth=5)
    Rect(165, 150, 70, 30, fill='cornflowerBlue')
    Label('TIME', 200, 165, fill='white', size=20)
    Label(timeLeft, 200, 75, fill='goldenrod', size=80, font='monospace',
          bold=True)

    # home section
    Label('HOME', 100, 220, fill='white', size=60, font='monospace', bold=True)
    Rect(25, 250, 150, 100)
    Label(homeScore, 100, 300, fill='red', size=100, font='monospace', bold=True)

    # away section
    Label('AWAY', 300, 220, fill='white', size=60, font='monospace', bold=True)
    Rect(225, 250, 150, 100)
    Label(awayScore, 300, 300, fill='red', size=100, font='monospace', bold=True)
",regular,1
1974,Splash,2.1.5,"# water
Rect(0, 0, 400, 400, fill=gradient('royalBlue', 'dodgerBlue', start='top'))

# lilypads
Circle(70, 50, 40, fill=gradient('limeGreen', 'forestGreen'))
Circle(350, 175, 30, fill=gradient('limeGreen', 'forestGreen'))
Circle(140, 355, 35, fill=gradient('limeGreen', 'forestGreen'))
Star(105, 30, 35, 3, fill='royalBlue')
Star(140, 390, 30, 3, fill='dodgerBlue')

# flower
Circle(70, 40, 8, fill=gradient('darkOrchid', 'lavender', start='left-bottom'))
Circle(50, 40, 8, fill=gradient('darkOrchid', 'lavender', start='right-bottom'))
Circle(70, 60, 8, fill=gradient('darkOrchid', 'lavender', start='left-top'))
Circle(50, 60, 8, fill=gradient('darkOrchid', 'lavender', start='right-top'))
Circle(60, 38, 8, fill=gradient('darkOrchid', 'lavender', start='bottom'))
Circle(73, 50, 8, fill=gradient('darkOrchid', 'lavender', start='left'))
Circle(60, 62, 8, fill=gradient('darkOrchid', 'lavender', start='top'))
Circle(47, 50, 8, fill=gradient('darkOrchid', 'lavender', start='right'))
Circle(60, 50, 8, fill='gold')

def drawSplash(centerX, centerY):
    # Draw a splash using four circles with different radii and opacities.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# water
Rect(0, 0, 400, 400, fill=gradient('royalBlue', 'dodgerBlue', start='top'))

# lilypads
Circle(70, 50, 40, fill=gradient('limeGreen', 'forestGreen'))
Circle(350, 175, 30, fill=gradient('limeGreen', 'forestGreen'))
Circle(140, 355, 35, fill=gradient('limeGreen', 'forestGreen'))
Star(105, 30, 35, 3, fill='royalBlue')
Star(140, 390, 30, 3, fill='dodgerBlue')

# flower
Circle(70, 40, 8, fill=gradient('darkOrchid', 'lavender', start='left-bottom'))
Circle(50, 40, 8, fill=gradient('darkOrchid', 'lavender', start='right-bottom'))
Circle(70, 60, 8, fill=gradient('darkOrchid', 'lavender', start='left-top'))
Circle(50, 60, 8, fill=gradient('darkOrchid', 'lavender', start='right-top'))
Circle(60, 38, 8, fill=gradient('darkOrchid', 'lavender', start='bottom'))
Circle(73, 50, 8, fill=gradient('darkOrchid', 'lavender', start='left'))
Circle(60, 62, 8, fill=gradient('darkOrchid', 'lavender', start='top'))
Circle(47, 50, 8, fill=gradient('darkOrchid', 'lavender', start='right'))
Circle(60, 50, 8, fill='gold')

def drawSplash(centerX, centerY):
    # Draw a splash with different radii and opacities.
    Circle(centerX, centerY, 80, fill='deepSkyBlue', opacity=30)
    Circle(centerX, centerY, 60, fill='deepSkyBlue', opacity=50)
    Circle(centerX, centerY, 40, fill='deepSkyBlue', opacity=70)
    Circle(centerX, centerY, 20, fill='deepSkyBlue', opacity=90)
",regular,1
1973,Butterfly,2.1.5,"def drawButterfly(wingColor, bodyColor, patternColor1, patternColor2):
    # background
    Rect(0, 0, 400, 400, fill=gradient(patternColor1, patternColor2), opacity=20)

    # Use the function parameters to change the hardcoded colors below.
    ### (HINT: Take a look at how the background is drawn using patternColor1
    #          and patternColor2 above!)
    ### Fix Your Code Here ###

    # wing base shapes and antenna
    Polygon(200, 180, 370, 50, 300, 230, 200, 200, 280, 250, 250, 300, 200, 210)
    Polygon(200, 180, 30, 50, 100, 230, 200, 200, 120, 250, 150, 300, 200, 210)
    Line(200, 180, 210, 160, lineWidth=4)
    Line(200, 180, 190, 160, lineWidth=4)

    # wing patterns
    Polygon(200, 190, 340, 90, 320, 130,
            fill=gradient('darkOrange', 'hotPink', start='left'))
    Polygon(200, 195, 310, 160, 290, 200,
            fill=gradient('darkOrange', 'hotPink'))
    Polygon(210, 215, 250, 275, 265, 250, fill=None, borderWidth=4,
            border=gradient('darkOrange', 'hotPink'))

    Polygon(200, 190, 60, 90, 80, 130,
            fill=gradient('darkOrange', 'hotPink', start='right'))
    Polygon(200, 195, 90, 160, 110, 200,
            fill=gradient('darkOrange', 'hotPink'))
    Polygon(190, 215, 150, 275, 135, 250, fill=None, borderWidth=4,
            border=gradient('darkOrange', 'hotPink'))

    # body and decoration
    Oval(200, 200, 15, 50, fill='yellow')
    Circle(250, 300, 8, fill='yellow')
    Circle(150, 300, 8, fill='yellow')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawButterfly(wingColor, bodyColor, patternColor1, patternColor2):
    # background
    Rect(0, 0, 400, 400, fill=gradient(patternColor1, patternColor2), opacity=20)

    # Use the function parameters to change the hardcoded colors below.

    # wing base shapes and antenna
    Polygon(200, 180, 370, 50, 300, 230, 200, 200,
            280, 250, 250, 300, 200, 210, fill=wingColor)
    Polygon(200, 180, 30, 50, 100, 230, 200, 200,
            120, 250, 150, 300, 200, 210, fill=wingColor)
    Line(200, 180, 210, 160, fill=wingColor, lineWidth=4)
    Line(200, 180, 190, 160, fill=wingColor, lineWidth=4)

    # wing patterns
    Polygon(200, 190, 340, 90, 320, 130,
            fill=gradient(patternColor1, patternColor2, start='left'))
    Polygon(200, 195, 310, 160, 290, 200,
            fill=gradient(patternColor1, patternColor2, start='right'))
    Polygon(210, 215, 250, 275, 265, 250, fill=None, borderWidth=4,
            border=gradient(patternColor1, patternColor2, start='right'))

    Polygon(200, 190, 60, 90, 80, 130,
            fill=gradient(patternColor1, patternColor2, start='right'))
    Polygon(200, 195, 90, 160, 110, 200,
            fill=gradient(patternColor1, patternColor2, start='left'))
    Polygon(190, 215, 150, 275, 135, 250, fill=None, borderWidth=4,
            border=gradient(patternColor1, patternColor2, start='left'))

    # body and decoration
    Oval(200, 200, 15, 50, fill=bodyColor)
    Circle(250, 300, 8, fill=bodyColor)
    Circle(150, 300, 8, fill=bodyColor)
",regular,2
1976,Using and Debugging Events Checkpoint 5,2.2.2.1,"# background
Rect(0, 0, 400, 400, fill='midnightBlue')

def onMousePress(mouseX, mouseY):
    # Draw two circles that are positioned so that they touch each other right
    # where the mouse is.
    ### Fix Your Code Here ###
    Circle(mouseX, mouseY, 20, fill='crimson')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='midnightBlue')

def onMousePress(mouseX, mouseY):
    Circle(mouseX, mouseY - 20, 20, fill='crimson')
    Circle(mouseX, mouseY + 20, 20, fill='crimson')
",regular,1
1975,Using and Debugging Events Checkpoint 4,2.2.2.1,"# background
Rect(0, 0, 400, 400, fill='lightBlue')

Label('Click near here for light circles', 200, 50)
Label('Click near here for dark circles', 200, 350)

def onMousePress(mouseX, mouseY):
    # Add an opacity to the circle below to make it lighter. The opacity
    # should depend on where the mouse was pressed.
    ### (HINT: Divide the mouse position by 4 when setting the opacity. Since
    #          the canvas is 400x400, doing this will keep the opacity between
    #          0 and 100.)
    ### Fix Your Code Here ###
    Circle(mouseX, mouseY, 50, fill='navy')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='lightBlue')

Label('Click near here for light circles', 200, 50)
Label('Click near here for dark circles', 200, 350)

def onMousePress(mouseX, mouseY):
    # Add an opacity to the circle below to make it lighter. The opacity
    # should depend on where the mouse was pressed.
    Circle(mouseX, mouseY, 50, fill='navy', opacity=mouseY/4)
",regular,1
1979,Pushpins,2.2.3,"# background
Rect(0, 0, 400, 400, fill='lightGreen')

def drawRoad(startX, startY, endX, endY):
    Line(startX, startY, endX, endY, fill=rgb(142, 137, 131), lineWidth=4)

def drawRiver(centerX, centerY, width, height):
    Oval(centerX, centerY, width, height,
         fill=gradient('dodgerBlue', 'royalBlue', start='left-top'))
    Oval(centerX, centerY, width - 30, height - 30, fill='lightGreen')

# lake and rivers
Oval(10, 300, 100, 150, fill=gradient('dodgerBlue', 'royalBlue', start='left-top'))
drawRiver(400, 0, 450, 320)
drawRiver(400, 400, 350, 350)

# roads
drawRoad(35, 110, 100, 110)
drawRoad(100, 110, 100, 265)
drawRoad(100, 110, 155, 170)
drawRoad(155, 170, 345, 170)
drawRoad(345, 170, 405, 205)
drawRoad(35, 110, 35, 35)
drawRoad(0, 35, 220, 35)
drawRoad(220, 35, 255, -5)
drawRoad(-5, 180, 185, 335)
drawRoad(185, 335, 405, 335)
drawRoad(100, 265, 60, 360)
drawRoad(60, 360, 60, 405)
drawRoad(295, 405, 295, 80)
drawRoad(295, 80, 220, 35)
drawRoad(295, 80, 405, 80)

def onMousePress(mouseX, mouseY):
    # Draw a pushpin.
    ### (HINT: Don't forget the small circle where the pin goes into the map!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='lightGreen')

def drawRoad(startX, startY, endX, endY):
    Line(startX, startY, endX, endY, fill=rgb(142, 137, 131), lineWidth=4)

def drawRiver(centerX, centerY, width, height):
    Oval(centerX, centerY, width, height,
         fill=gradient('dodgerBlue', 'royalBlue', start='left-top'))
    Oval(centerX, centerY, width - 30, height - 30, fill='lightGreen')

# lake and rivers
Oval(10, 300, 100, 150, fill=gradient('dodgerBlue', 'royalBlue', start='left-top'))
drawRiver(400, 0, 450, 320)
drawRiver(400, 400, 350, 350)

# roads
drawRoad(35, 110, 100, 110)
drawRoad(100, 110, 100, 265)
drawRoad(100, 110, 155, 170)
drawRoad(155, 170, 345, 170)
drawRoad(345, 170, 405, 205)
drawRoad(35, 110, 35, 35)
drawRoad(0, 35, 220, 35)
drawRoad(220, 35, 255, -5)
drawRoad(-5, 180, 185, 335)
drawRoad(185, 335, 405, 335)
drawRoad(100, 265, 60, 360)
drawRoad(60, 360, 60, 405)
drawRoad(295, 405, 295, 80)
drawRoad(295, 80, 220, 35)
drawRoad(295, 80, 405, 80)

def onMousePress(mouseX, mouseY):
    # Draw a pushpin.
    Circle(mouseX, mouseY, 2)
    Line(mouseX, mouseY, mouseX, mouseY - 20)
    Circle(mouseX, mouseY - 20, 5, fill='crimson')
",regular,1
1980,Flower vase,2.2.3,"# background
Rect(0, 0, 400, 400, fill=gradient('ghostWhite', 'powderBlue'))

# vase
Oval(200, 300, 50, 10, fill='limeGreen')
Rect(175, 300, 50, 100, fill='silver')
Oval(200, 370, 100, 135,
     fill=gradient('dimGray', 'silver', 'silver', start='left-bottom'))

def onMousePress(mouseX, mouseY):
    # Draw a flower where you click the mouse and connect its stem to the vase!
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('ghostWhite', 'powderBlue'))

# vase
Oval(200, 300, 50, 10, fill='limeGreen')
Rect(175, 300, 50, 100, fill='silver')
Oval(200, 370, 100, 135,
     fill=gradient('dimGray', 'silver', 'silver', start='left-bottom'))

def onMousePress(mouseX, mouseY):
    # Draw a flower where you click the mouse and connect its stem to the vase!
    Line(200, 300, mouseX, mouseY, fill='limeGreen', lineWidth=5)
    Star(mouseX, mouseY, 20, 6, fill='hotPink', roundness=70)
    Circle(mouseX, mouseY, 8, fill=gradient('orange', 'yellow'))
",regular,1
1978,Plaid maker,2.2.3,"# background
Rect(0, 0, 400, 400,
     fill=gradient('darkBlue', 'teal', 'teal', 'darkGreen', start='left-top'))

def onMousePress(mouseX, mouseY):
    # Draw two lines, one vertical and one horizontal that intersect where
    # the mouse is pressed.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400,
     fill=gradient('darkBlue', 'teal', 'teal', 'darkGreen', start='left-top'))

def onMousePress(mouseX, mouseY):
    # Draw two lines, one vertical and one horizontal that intersect where
    # the mouse is pressed.
    Line(mouseX, 0, mouseX, 400, fill='fireBrick', lineWidth=7, opacity=80)
    Line(0, mouseY, 400, mouseY, fill='fireBrick', lineWidth=7, opacity=80)
",regular,2
1981,Shiny lines,2.2.3,"# background
Rect(0, 0, 400, 400)

def onMousePress(mouseX, mouseY):
    # Draw a line from left-top corner to where the mouse is being clicked.
    ### (HINT: Don't forget about the gradient!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400)

def onMousePress(mouseX, mouseY):
    # Draw a line from left-top corner to where the mouse is being clicked.
    Line(0, 0, mouseX, mouseY, fill=gradient('red', 'black'))
",regular,1
1977,Octahedron,2.2.3,"# background
Rect(0, 0, 400, 400)

def onMousePress(mouseX, mouseY):
    # This code draws four green lines and a circle on each mouse click.
    Line(0, 0, mouseX, mouseY, fill=gradient('black', 'green'))
    Line(0, 400, mouseX, mouseY, fill=gradient('black', 'green'))
    Line(400, 0, mouseX, mouseY, fill=gradient('black', 'green'))
    Line(400, 400, mouseX, mouseY, fill=gradient('black', 'green'))
    Circle(mouseX, mouseY, 5, fill='green')

    # Draw 4 lines and a circle, mirroring the image already drawn.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400)

def onMousePress(mouseX, mouseY):
    # This code draws four green lines and a circle on each mouse click.
    Line(0, 0, mouseX, mouseY, fill=gradient('black', 'green'))
    Line(0, 400, mouseX, mouseY, fill=gradient('black', 'green'))
    Line(400, 0, mouseX, mouseY, fill=gradient('black', 'green'))
    Line(400, 400, mouseX, mouseY, fill=gradient('black', 'green'))
    Circle(mouseX, mouseY, 5, fill='green')

    # Draw 4 lines and a circle, mirroring the image already drawn.
    Line(0, 0, 400 - mouseX, 400 - mouseY, fill=gradient('black', 'lime'))
    Line(400, 0, 400 - mouseX, 400 - mouseY, fill=gradient('black', 'lime'))
    Line(0, 400, 400 - mouseX, 400 - mouseY, fill=gradient('black', 'lime'))
    Line(400, 400, 400 - mouseX, 400 - mouseY, fill=gradient('black', 'lime'))
    Circle(400 - mouseX, 400 - mouseY, 5, fill='lime')
",regular,3
1982,Cross stitch,2.2.3,"# background
Rect(0, 0, 400, 400, fill=gradient('lightCyan', 'lightBlue'))

# message
Label('Click within the frame to make a pattern!', 200, 20, size=20)

# frame
Circle(170, 200, 140, fill='lightYellow', border='tan', borderWidth=20)

# needle
Line(350, 215, 380, 335, fill='darkGrey')
Circle(345, 205, 15, fill=None, border='darkGrey')

# thread
Polygon(315, 315, 325, 315, 325, 300, 310, 300, fill='tan')
Polygon(310, 315, 310, 390, 360, 375, 335, 310, fill='pink')
Line(340, 345, 345, 205, fill='pink')
Polygon(370, 365, 370, 375, 305, 400, 300, 390, fill='tan')

def onMousePress(mouseX, mouseY):
    # Draw a snowflake where the mouse was clicked.
    ### (HINT: The snowflake only uses labels, each with a value of 'X'.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('lightCyan', 'lightBlue'))

# message
Label('Click within the frame to make a pattern!', 200, 20, size=20)

# frame
Circle(170, 200, 140, fill='lightYellow', border='tan', borderWidth=20)

# needle
Line(350, 215, 380, 335, fill='darkGrey')
Circle(345, 205, 15, fill=None, border='darkGrey')

# thread
Polygon(315, 315, 325, 315, 325, 300, 310, 300, fill='tan')
Polygon(310, 315, 310, 390, 360, 375, 335, 310, fill='pink')
Line(340, 345, 345, 205, fill='pink')
Polygon(370, 365, 370, 375, 305, 400, 300, 390, fill='tan')

def onMousePress(mouseX, mouseY):
    # Draw a snowflake where the mouse was clicked.
    Label('X', mouseX, mouseY, fill='lightBlue', size=10)
    Label('X', mouseX - 5, mouseY - 5, fill='lightBlue', size=8)
    Label('X', mouseX + 5, mouseY - 5, fill='lightBlue', size=8)
    Label('X', mouseX - 5, mouseY + 5, fill='lightBlue', size=8)
    Label('X', mouseX + 5, mouseY + 5, fill='lightBlue', size=8)
",regular,2
1985,Popping balloons,2.2.6,"# background
Rect(0, 0, 400, 400, fill='lightSkyBlue')

# string
Line(200, 330, 200, 400, fill='white', lineWidth=5, dashes=True)

# balloon
RegularPolygon(200, 370, 20, 3, fill='crimson')
Oval(200, 185, 300, 340,
     fill=gradient('lightCoral', 'crimson', start='right-top'))

def onMousePress(mouseX, mouseY):
    # Draw the pin.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Pop the balloon.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='lightSkyBlue')

# string
Line(200, 330, 200, 400, fill='white', lineWidth=5, dashes=True)

# balloon
RegularPolygon(200, 370, 20, 3, fill='crimson')
Oval(200, 185, 300, 340,
     fill=gradient('lightCoral', 'crimson', start='right-top'))

def onMousePress(mouseX, mouseY):
    # Draw the pin.
    Line(mouseX, mouseY, mouseX + 40, mouseY - 20, lineWidth=1)
    Circle(mouseX + 40, mouseY - 20, 5, fill='blue')

def onMouseRelease(mouseX, mouseY):
    # Pop the balloon.
    Star(200, 200, 210, 9, fill='grey', roundness=10)
    Star(200, 200, 190, 9, fill='lightSkyBlue', roundness=70)
",regular,2
1987,Ice cream,2.2.6,"# background
Rect(0, 0, 400, 400, fill='skyBlue')

# ice cream cone
Circle(140, 200, 80, fill='pink')
Rect(100, 280, 80, 100,
     fill=gradient('peru', 'peru', 'sandyBrown', 'peru', start='left'))
Polygon(55, 240, 230, 240, 180, 290, 100, 290,
        fill=gradient('peru', 'peru', 'sandyBrown', 'peru', start='left-top'))
Line(100, 350, 180, 350, fill='sandyBrown', lineWidth=60, dashes=(1, 15))
Line(140, 320, 140, 380, fill='sandyBrown', lineWidth=80, dashes=(1, 15))

# first scoop
Circle(75, 240, 20, fill='pink')
Circle(110, 240, 20, fill='pink')
Circle(145, 240, 20, fill='pink')
Circle(175, 240, 20, fill='pink')
Circle(210, 240, 20, fill='pink')

# second scoop
Circle(140, 105, 80, fill='sienna')
Circle(75, 168, 20, fill='sienna')
Circle(110, 168, 20, fill='sienna')
Circle(145, 168, 20, fill='sienna')
Circle(175, 168, 20, fill='sienna')
Circle(210, 168, 20, fill='sienna')

def onMousePress(mouseX, mouseY):
    # Draw the sun and add a label like in the solution.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Draw the ice cream drips.
    ### Place Your Code Here ###

    # Draw a label stating the ice cream is melting.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='skyBlue')

# ice cream cone
Circle(140, 200, 80, fill='pink')
Rect(100, 280, 80, 100,
     fill=gradient('peru', 'peru', 'sandyBrown', 'peru', start='left'))
Polygon(55, 240, 230, 240, 180, 290, 100, 290,
        fill=gradient('peru', 'peru', 'sandyBrown', 'peru', start='left-top'))
Line(100, 350, 180, 350, fill='sandyBrown', lineWidth=60, dashes=(1, 15))
Line(140, 320, 140, 380, fill='sandyBrown', lineWidth=80, dashes=(1, 15))

# first scoop
Circle(75, 240, 20, fill='pink')
Circle(110, 240, 20, fill='pink')
Circle(145, 240, 20, fill='pink')
Circle(175, 240, 20, fill='pink')
Circle(210, 240, 20, fill='pink')

# second scoop
Circle(140, 105, 80, fill='sienna')
Circle(75, 168, 20, fill='sienna')
Circle(110, 168, 20, fill='sienna')
Circle(145, 168, 20, fill='sienna')
Circle(175, 168, 20, fill='sienna')
Circle(210, 168, 20, fill='sienna')

def onMousePress(mouseX, mouseY):
    # Draw the sun and add a label like in the solution.
    Label('The sun is hot!', 300, 340, size=15)
    Circle(360, 40, 100, fill=gradient('orange', 'yellow'))

def onMouseRelease(mouseX, mouseY):
    # Draw the ice cream drips.
    Oval(140, 270, 5, 15, fill='pink')
    Oval(200, 255, 5, 25, fill='pink')
    Oval(85, 255, 10, 35, fill='pink')
    Oval(95, 170, 10, 50, fill='sienna')
    Oval(175, 200, 10, 50, fill='sienna')

    # Draw a label stating the ice cream is melting.
    Label('Your ice cream is melting!', 300, 360, size=15)
",regular,1
1983,Sun and moon,2.2.6,"sky = Rect(0, 0, 400, 400, fill='midnightBlue')

moon = Circle(200, 170, 100, fill='gold')
sun = Circle(175, 140, 100, fill='midnightBlue')

# cloud
Circle(240, 240, 30, fill='white')
Circle(200, 260, 45, fill='white')
Circle(150, 270, 30, fill='white')
Circle(250, 290, 30, fill='white')
Circle(275, 260, 40, fill='white')

def onMousePress(mouseX, mouseY):
    # Make it daytime by changing the fills of the global variables.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Make it nighttime by changing the fills back.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

sky = Rect(0, 0, 400, 400, fill='midnightBlue')

moon = Circle(200, 170, 100, fill='gold')
sun = Circle(175, 140, 100, fill='midnightBlue')

# cloud
Circle(240, 240, 30, fill='white')
Circle(200, 260, 45, fill='white')
Circle(150, 270, 30, fill='white')
Circle(250, 290, 30, fill='white')
Circle(275, 260, 40, fill='white')

def onMousePress(mouseX, mouseY):
    # Make it daytime by changing the fills of the global variables.
    sky.fill = 'skyBlue'
    moon.fill = 'skyBlue'
    sun.fill = gradient('yellow', 'gold')

def onMouseRelease(mouseX, mouseY):
    # Make it nighttime by changing the fills back.
    sky.fill = 'midnightBlue'
    sun.fill = 'midnightBlue'
    moon.fill = 'gold'
",regular,2
1984,The bat cave,2.2.6,"# roof layers
Circle(200, 275, 340,
       fill=gradient(rgb(30, 15, 10), rgb(60, 20, 10), start='top'))
Polygon(0, 35, 20, 30, 40, 10, 70, 0, 330, 0, 365, 25, 400, 30, 400, 70, 0, 70,
        fill=gradient('black', rgb(30, 15, 10), rgb(60, 20, 10), start='top'))
Polygon(0, 70, 70, 30, 115, 20, 165, 0, 255, 0, 315, 15, 370, 60, 400, 70,
        400, 120, 0, 120, fill=gradient('black', rgb(30, 15, 10), rgb(60, 20, 10),
                                        start='top'))
Polygon(0, 110, 33, 73, 95, 45, 155, 25, 240, 20, 340, 55, 365, 85, 400, 100,
        400, 140, 0, 140, fill=gradient('black', rgb(30, 15, 10), rgb(60, 20, 10),
                                        start='top'))

caveBackground = Circle(200, 275, 240, fill=gradient('black', rgb(60, 20, 10)))
caveRoof = Polygon(-20, 140, 58, 75, 140, 38, 200, 30, 275, 45, 320, 65,
                   420, 140, 290, 170, 260, 180, 230, 165, 190, 195, 80, 170,
                   45, 150, fill=gradient('black', rgb(30, 15, 10), start='top'))

# cave floor
Polygon(0, 400, 0, 370, 40, 350, 70, 315, 140, 295, 240, 285, 260, 320, 350, 340,
        400, 380, 400, 400, fill=gradient('black', rgb(80, 30, 15), start='top'))

def drawBat(x, y):
    # body
    Polygon(x, y - 16, x + 6, y, x, y + 7, x - 6, y)

    # ears
    Label('X', x, y + 7, size=20)

    # eyes
    Circle(x - 3, y + 9, 1, fill='red')
    Circle(x + 3, y + 9, 1, fill='red')

# bats
drawBat(75, 175)
drawBat(95, 180)
drawBat(110, 185)
drawBat(160, 190)
drawBat(205, 185)
drawBat(220, 175)
drawBat(280, 175)

# stalagmites
Polygon(100, 325, 105, 310, 110, 290, 115, 270, 120, 265, 125, 270, 120, 290,
        135, 325, fill=gradient(rgb(40, 15, 10), rgb(30, 20, 10),
                                rgb(20, 10, 10), start='top'))
Polygon(250, 360, 260, 345, 260, 325, 255, 305, 260, 302, 270, 305, 275, 335,
        285, 360, fill=gradient(rgb(45, 25, 10), rgb(40, 20, 10),
                                rgb(30, 20, 10), start='top'))

# flashlight
Rect(40, 330, 100, 20, fill='forestGreen')
Polygon(40, 350, 140, 350, 120, 380, 60, 380, fill='green')
Oval(90, 350, 100, 10, fill='forestGreen')
Rect(60, 380, 60, 20, fill='forestGreen')
Oval(90, 380, 60, 6, fill='green')
light = Oval(90, 330, 100, 10, border='forestGreen')

def onMousePress(mouseX, mouseY):
    # Turn the flashlight on and make the cave brighter.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Turn the flashlight off and make the cave darker.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# roof layers
Circle(200, 275, 340,
       fill=gradient(rgb(30, 15, 10), rgb(60, 20, 10), start='top'))
Polygon(0, 35, 20, 30, 40, 10, 70, 0, 330, 0, 365, 25, 400, 30, 400, 70, 0, 70,
        fill=gradient('black', rgb(30, 15, 10), rgb(60, 20, 10), start='top'))
Polygon(0, 70, 70, 30, 115, 20, 165, 0, 255, 0, 315, 15, 370, 60, 400, 70,
        400, 120, 0, 120, fill=gradient('black', rgb(30, 15, 10), rgb(60, 20, 10),
                                        start='top'))
Polygon(0, 110, 33, 73, 95, 45, 155, 25, 240, 20, 340, 55, 365, 85, 400, 100,
        400, 140, 0, 140, fill=gradient('black', rgb(30, 15, 10), rgb(60, 20, 10),
                                        start='top'))

caveBackground = Circle(200, 275, 240, fill=gradient('black', rgb(60, 20, 10)))
caveRoof = Polygon(-20, 140, 58, 75, 140, 38, 200, 30, 275, 45, 320, 65,
                   420, 140, 290, 170, 260, 180, 230, 165, 190, 195, 80, 170,
                   45, 150, fill=gradient('black', rgb(30, 15, 10), start='top'))

# cave floor
Polygon(0, 400, 0, 370, 40, 350, 70, 315, 140, 295, 240, 285, 260, 320, 350, 340,
        400, 380, 400, 400, fill=gradient('black', rgb(80, 30, 15), start='top'))

def drawBat(x, y):
    # body
    Polygon(x, y - 16, x + 6, y, x, y + 7, x - 6, y)

    # ears
    Label('X', x, y + 7, size=20)

    # eyes
    Circle(x - 3, y + 9, 1, fill='red')
    Circle(x + 3, y + 9, 1, fill='red')

# bats
drawBat(75, 175)
drawBat(95, 180)
drawBat(110, 185)
drawBat(160, 190)
drawBat(205, 185)
drawBat(220, 175)
drawBat(280, 175)

# stalagmites
Polygon(100, 325, 105, 310, 110, 290, 115, 270, 120, 265, 125, 270, 120, 290,
        135, 325, fill=gradient(rgb(40, 15, 10), rgb(30, 20, 10),
                                rgb(20, 10, 10), start='top'))
Polygon(250, 360, 260, 345, 260, 325, 255, 305, 260, 302, 270, 305, 275, 335,
        285, 360, fill=gradient(rgb(45, 25, 10), rgb(40, 20, 10),
                                rgb(30, 20, 10), start='top'))

# flashlight
Rect(40, 330, 100, 20, fill='forestGreen')
Polygon(40, 350, 140, 350, 120, 380, 60, 380, fill='green')
Oval(90, 350, 100, 10, fill='forestGreen')
Rect(60, 380, 60, 20, fill='forestGreen')
Oval(90, 380, 60, 6, fill='green')
light = Oval(90, 330, 100, 10, border='forestGreen')

def onMousePress(mouseX, mouseY):
    # Turn the flashlight on and make the cave brighter.
    caveBackground.fill = gradient(rgb(30, 15, 10), 'saddleBrown')
    caveRoof.fill = gradient(rgb(30, 15, 10), rgb(60, 20, 10), start='top')
    light.fill = 'gold'

def onMouseRelease(mouseX, mouseY):
    # Turn the flashlight off and make the cave darker.
    caveBackground.fill = gradient('black', rgb(60, 20, 10))
    caveRoof.fill = gradient('black', rgb(30, 15, 10), start='top')
    light.fill = 'black'
",regular,2
1986,Eat the cookie,2.2.6,"# background
Rect(0, 0, 400, 400, fill='lightSteelBlue')

# cookie
Circle(205, 205, 155, fill='saddleBrown')
Circle(200, 200, 150, fill='peru')

def drawChocoChips(centerX, centerY):
    Circle(centerX, centerY, 10, fill=rgb(90, 35, 15))

# chocolate chips
drawChocoChips(140, 90)
drawChocoChips(215, 150)
drawChocoChips(275, 100)
drawChocoChips(315, 200)
drawChocoChips(270, 300)
drawChocoChips(230, 240)
drawChocoChips(150, 315)
drawChocoChips(150, 245)
drawChocoChips(80, 220)
drawChocoChips(120, 155)
drawChocoChips(190, 200)


def onMouseRelease(mouseX, mouseY):
    # Add code to draw a circular bite.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='lightSteelBlue')

# cookie
Circle(205, 205, 155, fill='saddleBrown')
Circle(200, 200, 150, fill='peru')

def drawChocoChips(centerX, centerY):
    Circle(centerX, centerY, 10, fill=rgb(90, 35, 15))

# chocolate chips
drawChocoChips(140, 90)
drawChocoChips(215, 150)
drawChocoChips(275, 100)
drawChocoChips(315, 200)
drawChocoChips(270, 300)
drawChocoChips(230, 240)
drawChocoChips(150, 315)
drawChocoChips(150, 245)
drawChocoChips(80, 220)
drawChocoChips(120, 155)
drawChocoChips(190, 200)

def onMouseRelease(mouseX, mouseY):
    # Add code to draw a circular bite.
    Circle(mouseX, mouseY, 40, fill='lightSteelBlue')
",regular,1
1989,Camera,2.3.3,"background = Rect(0, 0, 400, 400)

# camera
Rect(90, 135, 40, 15, fill='steelBlue')
Rect(80, 150, 240, 30, fill='white')
Circle(80, 320, 30, fill='white')
Circle(320, 320, 30, fill='white')
Circle(80, 180, 30, fill='white')
Circle(320, 180, 30, fill='white')
Rect(50, 180, 300, 140, fill='skyBlue')
Rect(80, 320, 240, 30, fill='white')
Circle(245, 250, 80, fill='white', border='steelBlue', borderWidth=10)
Circle(245, 250, 50)

# flash
flash = Star(245, 250, 200, 12, fill=gradient('white', 'yellow', 'gold'),
             roundness=30, visible=False)

def onMousePress(mouseX, mouseY):
    # Turn the flash on.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Turn the flash off.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

background = Rect(0, 0, 400, 400)

# camera
Rect(90, 135, 40, 15, fill='steelBlue')
Rect(80, 150, 240, 30, fill='white')
Circle(80, 320, 30, fill='white')
Circle(320, 320, 30, fill='white')
Circle(80, 180, 30, fill='white')
Circle(320, 180, 30, fill='white')
Rect(50, 180, 300, 140, fill='skyBlue')
Rect(80, 320, 240, 30, fill='white')
Circle(245, 250, 80, fill='white', border='steelBlue', borderWidth=10)
Circle(245, 250, 50)

# flash
flash = Star(245, 250, 200, 12, fill=gradient('white', 'yellow', 'gold'),
             roundness=30, visible=False)

def onMousePress(mouseX, mouseY):
    # Turn flash on.
    flash.visible = True
    background.fill = gradient('steelBlue', 'black')

def onMouseRelease(mouseX, mouseY):
    # Turn flash off.
    flash.visible = False
    background.fill = 'black'
",regular,1
1990,Inchworm,2.3.3,"# sky
Rect(0, 0, 400, 325, fill=gradient('powderBlue', 'honeydew', start='top'))

# background grass
Line(220, 325, 210, 290, fill='forestGreen')
Line(222, 325, 220, 287, fill='green')
Line(227, 325, 235, 291, fill='green')
Line(225, 325, 227, 295, fill='forestGreen')
Oval(223, 326, 12, 8, fill=rgb(60, 117, 54))

# bee
Oval(242.5, 75, 5, 10, fill=rgb(224, 255, 255), rotateAngle=30)
Oval(244.5, 80, 5, 10, fill=rgb(224, 255, 255), rotateAngle=90)
Circle(232, 74, 4)
Oval(236, 80, 10, 15, rotateAngle=-30)
Oval(238, 83, 9, 2, fill='gold', rotateAngle=-30)
Oval(236, 80, 11, 2, fill='gold', rotateAngle=-30)
Oval(234, 77, 9, 2, fill='gold', rotateAngle=-30)
Polygon(241, 85, 239, 87, 243, 89)

# Define the global variables wormDown and wormUp.
# wormUp is when the worm bends upwards, and wormDown is when it lays flat.
### Fix Your Code Here ###
# wormDown =
# wormUp =

# flower
Line(275, 325, 275, 165, fill=rgb(112, 166, 74), lineWidth=6)
Star(275, 165, 50, 12, fill=gradient('paleVioletRed', rgb(242, 191, 255)),
     roundness=50)
Star(275, 165, 50, 12, fill=gradient(rgb(209, 157, 193), rgb(242, 191, 255)),
     roundness=50, rotateAngle=15)
Circle(275, 165, 25, fill='sienna')
Oval(290, 250, 20, 40, fill=rgb(112, 166, 74), rotateAngle=45)
Oval(260, 230, 20, 40, fill=rgb(112, 166, 74), rotateAngle=-45)

# grass
Rect(0, 325, 400, 75, fill=rgb(60, 117, 54))
Line(100, 325, 92, 285, fill='green')
Line(102, 325, 100, 290, fill='forestGreen')
Line(105, 325, 106, 295, fill='green')
Line(107, 325, 115, 287, fill='forestGreen')
Oval(103, 325, 12, 6, fill=rgb(60, 117, 54))

def onMousePress(mouseX, mouseY):
    # Switch between wormDown and wormUp by hiding wormDown and showing wormUp.
    ### (HINT: Use the visible property.)
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Switch between wormDown and wormUp by showing wormDown and hiding wormUp.
    ### (HINT: Use the visible property.)
    ### Place Your Code Here ###

    # Move the worm to the right.
    ### (HINT: Change the centerX of both wormUp and wormDown.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# sky
Rect(0, 0, 400, 325, fill=gradient('powderBlue', 'honeydew', start='top'))

# background grass
Line(220, 325, 210, 290, fill='forestGreen')
Line(222, 325, 220, 287, fill='green')
Line(227, 325, 235, 291, fill='green')
Line(225, 325, 227, 295, fill='forestGreen')
Oval(223, 326, 12, 8, fill=rgb(60, 117, 54))

# bee
Oval(242.5, 75, 5, 10, fill=rgb(224, 255, 255), rotateAngle=30)
Oval(244.5, 80, 5, 10, fill=rgb(224, 255, 255), rotateAngle=90)
Circle(232, 74, 4)
Oval(236, 80, 10, 15, rotateAngle=-30)
Oval(238, 83, 9, 2, fill='gold', rotateAngle=-30)
Oval(236, 80, 11, 2, fill='gold', rotateAngle=-30)
Oval(234, 77, 9, 2, fill='gold', rotateAngle=-30)
Polygon(241, 85, 239, 87, 243, 89)

wormDown = Line(25, 322, 75, 322, fill='mediumVioletRed', lineWidth=6)
wormUp = Star(55, 333, 20, 6, fill=None, border='mediumVioletRed',
              borderWidth=6, roundness=80, visible=False)

# flower
Line(275, 325, 275, 165, fill=rgb(112, 166, 74), lineWidth=6)
Star(275, 165, 50, 12, fill=gradient('paleVioletRed', rgb(242, 191, 255)),
     roundness=50)
Star(275, 165, 50, 12, fill=gradient(rgb(209, 157, 193), rgb(242, 191, 255)),
     roundness=50, rotateAngle=15)
Circle(275, 165, 25, fill='sienna')
Oval(290, 250, 20, 40, fill=rgb(112, 166, 74), rotateAngle=45)
Oval(260, 230, 20, 40, fill=rgb(112, 166, 74), rotateAngle=-45)

# grass
Rect(0, 325, 400, 75, fill=rgb(60, 117, 54))
Line(100, 325, 92, 285, fill='green')
Line(102, 325, 100, 290, fill='forestGreen')
Line(105, 325, 106, 295, fill='green')
Line(107, 325, 115, 287, fill='forestGreen')
Oval(103, 325, 12, 6, fill=rgb(60, 117, 54))

def onMousePress(mouseX, mouseY):
    # Switch between wormDown and wormUp by hiding wormDown and showing wormUp.
    wormDown.visible = False
    wormUp.visible = True

def onMouseRelease(mouseX, mouseY):
    # Switch between wormDown and wormUp by showing wormDown and hiding wormUp.
    wormDown.visible = True
    wormUp.visible = False

    # Move the worm to the right.
    wormDown.centerX += 15
    wormUp.centerX += 15
",regular,2
1988,Talking,2.3.3,"# background
Rect(0, 0, 400, 400, fill='lavenderBlush')

# This draws the voice.
voice = Star(140, 215, 75, 8, roundness=10, visible=False)
Rect(80, 135, 75, 160, fill='lavenderBlush')

# face
Oval(30, 140, 230, 350, fill='lightSkyBlue')
Polygon(0, 0, 130, 0, 145, 60, 180, 130, 145, 155, 0, 210, fill='lightSkyBlue')
eye = Circle(80, 50, 15)

mouth = Polygon(150, 185, 80, 185, 95, 225, 140, 250, fill='lavenderBlush',
                visible=False)

def onMousePress(x, y):
    # Open the mouth and talk.
    ### Place Your Code Here ###
    pass

def onMouseRelease(x, y):
    # Close the mouth to stop talking.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='lavenderBlush')

# This draws the voice.
voice = Star(140, 215, 75, 8, roundness=10, visible=False)
Rect(80, 135, 75, 160, fill='lavenderBlush')

# face
Oval(30, 140, 230, 350, fill='lightSkyBlue')
Polygon(0, 0, 130, 0, 145, 60, 180, 130, 145, 155, 0, 210, fill='lightSkyBlue')
eye = Circle(80, 50, 15)

mouth = Polygon(150, 185, 80, 185, 95, 225, 140, 250, fill='lavenderBlush',
                visible=False)

def onMousePress(x, y):
    voice.visible = True
    mouth.visible = True
    eye.radius = 20

def onMouseRelease(x, y):
    voice.visible = False
    mouth.visible = False
    eye.radius = 15
",regular,1
1993,Scotty dog,2.3.4,"# background
app.background = 'lightGrey'

# Define the backlight variable.
### Place Your Code Here ###
# backlight =

# scotty dog
Polygon(130, 60, 150, 140, 150, 70, 170, 130, 260, 130, 220, 150, 325, 160,
        315, 260, 290, 240, 210, 240, 210, 270, 130, 205)
Polygon(125, 220, 208, 314, 180, 340, 80, 280)
Polygon(210, 270, 225, 274, 209, 256, fill=None, border='black')
Polygon(130, 205, 210, 270, 227, 276, 215, 320, 125, 220, fill=None,
        border='black')


def onMousePress(mouseX, mouseY):
    # The height of the backlight should change depending on the mouse.
    # Remember that heights can't be 0!
    ### (HINT: The top of the backlight is always at the top of the canvas.)
    ### (HINT: Add 1 to the mouseY to avoid 0.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
app.background = 'lightGrey'

# Define the backlight variable.
backlight = Rect(200, 0, 400, 50, fill='fireBrick', align='top')

# scotty dog
Polygon(130, 60, 150, 140, 150, 70, 170, 130, 260, 130, 220, 150, 325, 160,
        315, 260, 290, 240, 210, 240, 210, 270, 130, 205)
Polygon(125, 220, 208, 314, 180, 340, 80, 280)
Polygon(210, 270, 225, 274, 209, 256, fill=None, border='black')
Polygon(130, 205, 210, 270, 227, 276, 215, 320, 125, 220, fill=None,
        border='black')


def onMousePress(mouseX, mouseY):
    # The height of the backlight should change depending on the mouse.
    backlight.height = mouseY + 1
",regular,1
1992,Cookie clicker,2.3.4,"# background
app.background = gradient('maroon', 'black')

Label('Cookie Clicker!', 200, 20, fill='white', size=20, bold=True)

# cookie
Circle(200, 200, 105, fill=gradient('burlyWood', 'peru'))

# chocolate chips
Circle(210, 200, 10, fill='saddleBrown')
Circle(160, 130, 10, fill='saddleBrown')
Circle(280, 220, 10, fill='saddleBrown')
Circle(240, 150, 10, fill='saddleBrown')
Circle(140, 255, 10, fill='saddleBrown')
Circle(210, 245, 10, fill='saddleBrown')
Circle(130, 200, 10, fill='saddleBrown')

# Define the variable to count the number of times we clicked.
### Place Your Code Here ###

def onMousePress(mouseX, mouseY):
    # Increase the number of times we clicked on the cookie.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
app.background = gradient('maroon', 'black')

Label('Cookie Clicker!', 200, 20, fill='white', size=20, bold=True)

# cookie
Circle(200, 200, 105, fill=gradient('burlyWood', 'peru'))

# chocolate chips
Circle(210, 200, 10, fill='saddleBrown')
Circle(160, 130, 10, fill='saddleBrown')
Circle(280, 220, 10, fill='saddleBrown')
Circle(240, 150, 10, fill='saddleBrown')
Circle(140, 255, 10, fill='saddleBrown')
Circle(210, 245, 10, fill='saddleBrown')
Circle(130, 200, 10, fill='saddleBrown')

# Define the variable to count the number of times we clicked.
counter = Label(0, 200, 200, fill='white', size=64)

def onMousePress(mouseX, mouseY):
    # Increase the number of times we clicked on the cookie.
    counter.value += 1
",regular,1
1991,Toilet paper,2.3.4,"# This draws the background; the two lines overlap and create a checkerboard
# pattern!
Line(200, 0, 200, 400, fill='lightGrey', lineWidth=400, dashes=True)
Line(0, 200, 400, 200, fill='cornflowerBlue', lineWidth=400, dashes=True,
     opacity=50)

# plunger
Circle(305, 50, 8, fill=gradient('sienna', 'saddleBrown', start='left'))
Rect(297, 50, 16, 290, fill=gradient('sienna', 'saddleBrown', start='left'))
Rect(290, 340, 30, 15, fill=gradient('red', 'maroon', start='left'))
Circle(305, 410, 60, fill=gradient('red', 'maroon', start='left'))
Rect(245, 390, 120, 10, fill=gradient('crimson', 'darkRed', start='left'))

# paper roll
Rect(85, 75, 100, 50, fill='white')
Oval(85, 100, 20, 50, fill='white')
Oval(185, 100, 20, 50, fill='gainsboro')

# holder
Polygon(185, 90, 185, 110, 210, 90, 210, 70, fill='silver')
Polygon(100, 70, 100, 75, 90, 75, fill='silver')

# Define the paper variable.
### (HINT: The toilet paper is a line with a large lineWidth.)
### Fix Your Code Here ###
# paper =

def onMousePress(mouseX, mouseY):
    # Draw a new perforation line across the toilet paper.
    ### (HINT: Use either y1 or y2 of the paper variable to help get the
    #          y values!)
    ### Place Your Code Here ###

    # Make the paper longer.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# This draws the background; the two lines overlap and create a checkerboard
# pattern!
Line(200, 0, 200, 400, fill='lightGrey', lineWidth=400, dashes=True)
Line(0, 200, 400, 200, fill='cornflowerBlue', lineWidth=400, dashes=True,
     opacity=50)

# plunger
Circle(305, 50, 8, fill=gradient('sienna', 'saddleBrown', start='left'))
Rect(297, 50, 16, 290, fill=gradient('sienna', 'saddleBrown', start='left'))
Rect(290, 340, 30, 15, fill=gradient('red', 'maroon', start='left'))
Circle(305, 410, 60, fill=gradient('red', 'maroon', start='left'))
Rect(245, 390, 120, 10, fill=gradient('crimson', 'darkRed', start='left'))

# paper roll
Rect(85, 75, 100, 50, fill='white')
Oval(85, 100, 20, 50, fill='white')
Oval(185, 100, 20, 50, fill='gainsboro')

# holder
Polygon(185, 90, 185, 110, 210, 90, 210, 70, fill='silver')
Polygon(100, 70, 100, 75, 90, 75, fill='silver')

# Define the paper variable.
paper = Line(125, 100, 125, 100, fill='white', lineWidth=100)

def onMousePress(mouseX, mouseY):
    # Draw a new perforation line in the toilet paper.
    Line(paper.x2 - 50, paper.y2 + 25, paper.x2 + 50, paper.y2 + 25,
         lineWidth=1, dashes=True)

    # Add another piece of toilet paper.
    paper.y2 += 50
",regular,2
1994,Lightning,2.4,"# sky and grass
Rect(0, 0, 400, 275, fill=gradient('grey', 'midnightBlue', start='top'))
Rect(0, 275, 400, 50, fill=gradient('green', 'darkGreen', start='top'))
backgroundLight = Rect(0, 0, 400, 275, fill='white', opacity=0)

# tree and lightning
tree = Polygon(85, 275, 90, 260, 80, 250, 90, 255, 85, 235, 80, 210, 90, 190,
               85, 210, 90, 225, 100, 220, 90, 230, 100, 265, 105, 275,
               fill=rgb(180, 160, 140))

lightning = Polygon(260, 0, 210, 60, 250, 60, 160, 100, 210, 100, 120, 150, 160,
                    150, 90, 190, 220, 140, 160, 140, 270, 80, 240, 80, 310, 40,
                    270, 40, 340, 0, fill='gold', border='yellow',
                    borderWidth=1, visible=False)

# windows and control panel
Rect(0, 0, 200, 325, fill=None, border='dimGrey', borderWidth=8)
Rect(200, 0, 200, 325, fill=None, border='dimGrey', borderWidth=8)
Rect(0, 325, 400, 75, fill=gradient('silver', 'grey', start='left-top'))
Line(10, 360, 130, 360, fill='green', lineWidth=40, dashes=True)
Line(270, 360, 390, 360, fill='green', lineWidth=40, dashes=True)
Label('Do not Press!', 200, 390, fill='red', size=12, bold=True)

# button
Circle(200, 355, 29, fill=None,
       border=gradient('silver', 'grey', start='left-top'), borderWidth=5)
button = Oval(200, 355, 35, 30, fill=gradient('red', 'darkRed', start='left-top'),
              border='fireBrick')

def onMousePress(mouseX, mouseY):
    # Push the button.
    ### Place Your Code Here ###

    # Show the lightning strike and effects.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Unpress the button.
    ### (HINT: Undo all the changes made in onMousePress besides the change
    #          to the tree.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# sky and grass
Rect(0, 0, 400, 275, fill=gradient('grey', 'midnightBlue', start='top'))
Rect(0, 275, 400, 50, fill=gradient('green', 'darkGreen', start='top'))
backgroundLight = Rect(0, 0, 400, 275, fill='white', opacity=0)

# tree and lightning
tree = Polygon(85, 275, 90, 260, 80, 250, 90, 255, 85, 235, 80, 210, 90, 190,
               85, 210, 90, 225, 100, 220, 90, 230, 100, 265, 105, 275,
               fill=rgb(180, 160, 140))

lightning = Polygon(260, 0, 210, 60, 250, 60, 160, 100, 210, 100, 120, 150, 160,
                    150, 90, 190, 220, 140, 160, 140, 270, 80, 240, 80, 310, 40,
                    270, 40, 340, 0, fill='gold', border='yellow',
                    borderWidth=1, visible=False)

# windows and control panel
Rect(0, 0, 200, 325, fill=None, border='dimGrey', borderWidth=8)
Rect(200, 0, 200, 325, fill=None, border='dimGrey', borderWidth=8)
Rect(0, 325, 400, 75, fill=gradient('silver', 'grey', start='left-top'))
Line(10, 360, 130, 360, fill='green', lineWidth=40, dashes=True)
Line(270, 360, 390, 360, fill='green', lineWidth=40, dashes=True)
Label('Do not Press!', 200, 390, fill='red', size=12, bold=True)

# button
Circle(200, 355, 29, fill=None,
       border=gradient('silver', 'grey', start='left-top'), borderWidth=5)
button = Oval(200, 355, 35, 30, fill=gradient('red', 'darkRed', start='left-top'),
              border='fireBrick')

def onMousePress(mouseX, mouseY):
    # Push the button.
    button.fill = 'darkRed'

    # Show the lightning strike and effects.
    tree.fill = 'black'
    lightning.visible = True
    backgroundLight.opacity = 30

def onMouseRelease(mouseX, mouseY):
    # Unpress the button.
    button.fill = gradient('red', 'darkRed', start='left-top')

    # Remove the lighning.
    lightning.visible = False
    backgroundLight.opacity = 0
",regular,2
1999,Forest maker,2.4,"# background
Rect(0, 0, 400, 400, fill=rgb(30, 58, 19))

def onMousePress(mouseX, mouseY):
    # Draw a tree composed of two regularPolygons and a rectangle.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=rgb(30, 58, 19))

def onMousePress(mouseX, mouseY):
    Rect(mouseX, mouseY + 15, 10, 15,
         fill=gradient('sienna', rgb(120, 50, 30), start='top'), align='center')
    RegularPolygon(mouseX, mouseY, 20, 3,
                   fill=gradient('green', rgb(0, 80, 0), start='top'))
    RegularPolygon(mouseX, mouseY - 15, 15, 3,
                   fill=gradient('lightGreen', 'darkGreen', start='top'))
",regular,1
2000,Spiderman or Venom,2.4,"app.background = 'red'

# mask ridges
Line(0, 0, 400, 400)
Line(400, 0, 0, 400)
Line(200, 0, 200, 400)
Line(0, 200, 400, 200)
Star(200, 200, 150, 9, fill=None, border='black', roundness=90)
Star(200, 200, 25, 9, fill=None, border='black', roundness=90)
Star(200, 200, 250, 9, fill=None, border='black', roundness=90)

# eyes
Oval(100, 150, 100, 200, fill='white', border='black', borderWidth=6,
     rotateAngle=-20)
Oval(300, 150, 100, 200, fill='white', border='black', borderWidth=6,
     rotateAngle=20)

def onMousePress(mouseX, mouseY):
    # Change from Spiderman to Venom.
    ### (HINT: The only thing that changes is the color.)
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Change from Venom to Spiderman.
    ### (HINT: The only thing that changes is the color.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'red'

# mask ridges
Line(0, 0, 400, 400)
Line(400, 0, 0, 400)
Line(200, 0, 200, 400)
Line(0, 200, 400, 200)
Star(200, 200, 150, 9, fill=None, border='black', roundness=90)
Star(200, 200, 25, 9, fill=None, border='black', roundness=90)
Star(200, 200, 250, 9, fill=None, border='black', roundness=90)

# eyes
Oval(100, 150, 100, 200, fill='white', border='black', borderWidth=6,
     rotateAngle=-20)
Oval(300, 150, 100, 200, fill='white', border='black', borderWidth=6,
     rotateAngle=20)

def onMousePress(mouseX, mouseY):
    # Change from Spiderman to Venom.
    app.background = 'black'

def onMouseRelease(mouseX, mouseY):
    # Change from Venom to Spiderman.
    app.background = 'red'
",regular,1
1996,Alien eyes,2.4,"app.background = gradient('black', 'midnightBlue', start='top')

# Draw the alien body.
### (Hint: Use 7 shapes.)
### Place Your Code Here ###

# Write a function that draws one eye.
def drawEye(centerX, centerY, eyeSize, pupilSize):
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('black', 'midnightBlue', start='top')

# body
Circle(200, 200, 100, fill='limeGreen')

# mouth
Circle(200, 245, 25)
Rect(175, 220, 50, 25, fill='limeGreen')

# arms
Circle(100, 200, 20, fill='limeGreen')
Circle(300, 200, 20, fill='limeGreen')

# legs
Circle(150, 290, 20, fill='limeGreen')
Circle(250, 290, 20, fill='limeGreen')

def drawEye(centerX, centerY, eyeSize, pupilSize):
    Circle(centerX, centerY, eyeSize, fill='white')
    Circle(centerX, centerY, pupilSize)
",regular,1
1997,Pokey,2.4,"# Write the function drawPokeyBodyPiece(x, y), which takes an x,y point
# which is the center of the body piece, to draw the Pokey from Super Mario!

def drawBackground():
    Rect(0, 0, 400, 400, fill=gradient('skyBlue', 'orange', start='top'))
    Rect(0, 275, 400, 125, fill='gold')
    Polygon(140, 275, 240, 155, 290, 175, 330, 120, 465, 275,
            fill=rgb(235, 185, 0))
    Polygon(0, 275, 60, 185, 100, 240, 135, 220, 190, 275,
            fill=rgb(255, 235, 60))

def drawPokeyHead(x, y):
    # head spikes
    Star(x, y - 10, 32, 6, fill=rgb(255, 235, 60), border='white')

    # head and eyes
    Circle(x, y, 30, fill=gradient('gold', 'orange', start='left-top'),
           border='black')
    Oval(x - 10, y - 5, 15, 18)
    Oval(x + 10, y - 5, 15, 18)
    Circle(x - 7, y - 7, 3, fill='white')
    Circle(x + 7, y - 2, 3, fill='white')

    # mouth
    Oval(x, y + 15, 30, 15)
    Oval(x, y + 10, 30, 10, fill=gradient('gold', 'orange', start='left-top'))

def drawPokeyBodyPiece(x, y):
    # Draw the body piece, including its thorns and spikes.
    ### (HINT: The thorns are lines, and the spikes are made of regularPolygons.
    #          Also, the body gradient has a start of 'left-top'.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Write the function drawPokeyBodyPiece(x, y), which takes an x,y point
# which is the center of the body piece, to draw the Pokey from Super Mario!

def drawBackground():
    Rect(0, 0, 400, 400, fill=gradient('skyBlue', 'orange', start='top'))
    Rect(0, 275, 400, 125, fill='gold')
    Polygon(140, 275, 240, 155, 290, 175, 330, 120, 465, 275,
            fill=rgb(235, 185, 0))
    Polygon(0, 275, 60, 185, 100, 240, 135, 220, 190, 275,
            fill=rgb(255, 235, 60))

def drawPokeyHead(x, y):
    # head spikes
    Star(x, y - 10, 32, 6, fill=rgb(255, 235, 60), border='white')

    # head and eyes
    Circle(x, y, 30, fill=gradient('gold', 'orange', start='left-top'),
           border='black')
    Oval(x - 10, y - 5, 15, 18)
    Oval(x + 10, y - 5, 15, 18)
    Circle(x - 7, y - 7, 3, fill='white')
    Circle(x + 7, y - 2, 3, fill='white')

    # mouth
    Oval(x, y + 15, 30, 15)
    Oval(x, y + 10, 30, 10, fill=gradient('gold', 'orange', start='left-top'))

def drawPokeyBodyPiece(x, y):
    # Draw the thorns with 2 lines.
    Line(x - 25, y + 25, x + 25, y - 25)
    Line(x - 25, y - 25, x + 25, y + 25)

    # Draw the spikes with 2 regularPolygons.
    RegularPolygon(x - 25, y - 5, 12, 4, fill=rgb(255, 235, 60), border='white')
    RegularPolygon(x + 28, y + 5, 12, 3, fill=rgb(255, 235, 60), border='white')

    # Draw the body.
    Circle(x, y, 30, fill=gradient('gold', 'orange', start='left-top'),
           border='black')
",regular,3
2003,Bouncing ball,2.4,"app.background = gradient('midnightBlue', 'dodgerBlue', start='top')

# Define the platform and ball variables.
### (HINT: You can't see the left-top of the platform so try to position it by
#          using a different alignment!)
### Fix Your Code Here ###
# platform =
# ball =

def onMousePress(mouseX, mouseY):
    # Rotate the platform and bounce the ball.
    ### (HINT: Change the ball's bottom so that it matches the platform's top.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('midnightBlue', 'dodgerBlue', start='top')

# Define the platform and ball variables.
platform = Rect(100, 300, 300, 300, align='center',
                fill=gradient('grey', 'gainsboro', start='left-top'))
ball = Circle(100, 150, 20, fill='crimson', align='bottom')

def onMousePress(mouseX, mouseY):
    platform.rotateAngle -= 10
    ball.bottom = platform.top
",regular,3
2004,Hungry panda,2.4,"# ears
Circle(100, 100, 40)
Circle(300, 100, 40)

# body
Circle(200, 400, 175)

# face
Circle(200, 200, 125, fill='white')

# eyes
Oval(250, 170, 60, 80, rotateAngle=-30)
Oval(150, 170, 60, 80, rotateAngle=30)
Circle(160, 160, 15, fill='white')
Circle(240, 160, 15, fill='white')
Circle(160, 160, 5)
Circle(240, 160, 5)

# nose
Oval(200, 200, 50, 30)

# mouth
mouth = Circle(200, 250, 30, fill='lightCoral')
Rect(170, 215, 70, 35, fill='white')
Line(170, 250, 230, 250, fill='lightCoral', lineWidth=5)

# bamboo eaten label
Label('Amount of Bamboo Eaten:', 150, 25, size=25)

# Define the bamboo eaten counter.
### Fix Your Code Here ###
# counter =

# bamboo
bamboo = Line(190, 265, 100, 410,
              fill=gradient('oliveDrab', 'darkOliveGreen', 'darkGreen'),
              lineWidth=20)

# full cheek
fullCheek = Oval(275, 250, 60, 70, fill='white', border='black', borderWidth=3,
                 visible=False)
Rect(240, 212, 40, 70, fill='white')

def onMousePress(mouseX, mouseY):
    # Change the visibility of the mouth and fullCheek and remove a bit of bamboo.
    ### Place Your Code Here ###

    # Then, add one to the bamboo count.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Change the visibility of the mouth and fullCheek back and move the
    # bamboo to the panda's mouth.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# ears
Circle(100, 100, 40)
Circle(300, 100, 40)

# body
Circle(200, 400, 175)

# face
Circle(200, 200, 125, fill='white')

# eyes
Oval(250, 170, 60, 80, rotateAngle=-30)
Oval(150, 170, 60, 80, rotateAngle=30)
Circle(160, 160, 15, fill='white')
Circle(240, 160, 15, fill='white')
Circle(160, 160, 5)
Circle(240, 160, 5)

# nose
Oval(200, 200, 50, 30)

# mouth
mouth = Circle(200, 250, 30, fill='lightCoral')
Rect(170, 215, 70, 35, fill='white')
Line(170, 250, 230, 250, fill='lightCoral', lineWidth=5)

# bamboo eaten label
Label('Amount of Bamboo Eaten:', 150, 25, size=25)

# Define the bamboo eaten counter.
### Fix Your Code Here ###
counter = Label(0, 320, 25, size=25)

# bamboo
bamboo = Line(190, 265, 100, 410,
              fill=gradient('oliveDrab', 'darkOliveGreen', 'darkGreen'),
              lineWidth=20)

# full cheek
fullCheek = Oval(275, 250, 60, 70, fill='white', border='black', borderWidth=3,
                 visible=False)
Rect(240, 212, 40, 70, fill='white')

def onMousePress(mouseX, mouseY):
    # Change the visibility of the mouth and fullCheek and remove a bit of bamboo.
    ### Place Your Code Here ###
    mouth.visible = False
    fullCheek.visible= True
    bamboo.x1 = 170
    bamboo.y1 = 295

    # Then, add one to the bamboo count.
    ### Place Your Code Here ###
    counter.value += 1

def onMouseRelease(mouseX, mouseY):
    # Change the visibility of the mouth and fullCheek back and move the
    # bamboo to the panda's mouth.
    mouth.visible = True
    fullCheek.visible = False
    bamboo.x1 = 190
    bamboo.y1 = 265
",regular,2
2001,Drum set,2.4,"app.background = 'black'
Polygon(30, 250, 370, 250, 600, 320, -200, 320, fill='lightGrey')
Rect(0, 320, 400, 80, fill='slateGray')

# back drums
Oval(110, 230, 70, 10, border='lightGrey', borderWidth=3,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'))
Rect(110, 200, 70, 60,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'), align='center')
Oval(110, 170, 70, 10, fill='grey', border='silver', borderWidth=3)
Oval(290, 230, 70, 10, border='lightGrey', borderWidth=3,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'))
Rect(290, 200, 70, 60,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'), align='center')
Oval(290, 170, 70, 10, fill='grey', border='silver', borderWidth=3)

# bass drums
Line(200, 200, 140, 300, fill=rgb(50, 50, 50), lineWidth=5)
Line(200, 200, 260, 300, fill=rgb(50, 50, 50), lineWidth=5)
outerBass = Circle(200, 240, 60, fill='grey', border='darkRed', borderWidth=10)
innerBass = Circle(200, 240, 58, fill='grey', border='silver', borderWidth=8)

# hi-hats
Line(50, 300, 60, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(70, 300, 60, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(60, 290, 60, 150, fill=rgb(50, 50, 50), lineWidth=3)
leftHiHat = Oval(65, 150, 70, 30, fill=gradient('gold', 'goldenrod'),
                 border='darkGoldenrod', rotateAngle=45)

Line(330, 300, 340, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(350, 300, 340, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(340, 290, 340, 150, fill=rgb(50, 50, 50), lineWidth=3)
rightHiHat = Oval(340, 150, 70, 30, fill=gradient('gold', 'goldenrod'),
                  border='darkGoldenrod', rotateAngle=-45)

# light
Polygon(100, 0, 300, 0, 400, 330, 0, 330, fill='white', opacity=15)

def onMousePress(mouseX, mouseY):
    # Change the radii of the basses.
    ### Place Your Code Here ###

    # Change the angle of the hi-hats.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Change the radii of the basses.
    ### Place Your Code Here ###

    # Change the angle of the hi-hats.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
Polygon(30, 250, 370, 250, 600, 320, -200, 320, fill='lightGrey')
Rect(0, 320, 400, 80, fill='slateGray')

# back drums
Oval(110, 230, 70, 10, border='lightGrey', borderWidth=3,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'))
Rect(110, 200, 70, 60,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'), align='center')
Oval(110, 170, 70, 10, fill='grey', border='silver', borderWidth=3)
Oval(290, 230, 70, 10, border='lightGrey', borderWidth=3,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'))
Rect(290, 200, 70, 60,
     fill=gradient('darkRed', 'fireBrick', 'darkRed', start='left'), align='center')
Oval(290, 170, 70, 10, fill='grey', border='silver', borderWidth=3)

# bass drums
Line(200, 200, 140, 300, fill=rgb(50, 50, 50), lineWidth=5)
Line(200, 200, 260, 300, fill=rgb(50, 50, 50), lineWidth=5)
outerBass = Circle(200, 240, 60, fill='grey', border='darkRed', borderWidth=10)
innerBass = Circle(200, 240, 58, fill='grey', border='silver', borderWidth=8)

# hi-hats
Line(50, 300, 60, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(70, 300, 60, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(60, 290, 60, 150, fill=rgb(50, 50, 50), lineWidth=3)
leftHiHat = Oval(65, 150, 70, 30, fill=gradient('gold', 'goldenrod'),
                 border='darkGoldenrod', rotateAngle=45)

Line(330, 300, 340, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(350, 300, 340, 290, fill=rgb(50, 50, 50), lineWidth=3)
Line(340, 290, 340, 150, fill=rgb(50, 50, 50), lineWidth=3)
rightHiHat = Oval(340, 150, 70, 30, fill=gradient('gold', 'goldenrod'),
                  border='darkGoldenrod', rotateAngle=-45)

# light
Polygon(100, 0, 300, 0, 400, 330, 0, 330, fill='white', opacity=15)

def onMousePress(mouseX, mouseY):
    # Change the radii of the basses.
    innerBass.radius += 10
    outerBass.radius += 10

    # Change the angle of the hi-hats.
    leftHiHat.rotateAngle = -45
    rightHiHat.rotateAngle = 45

def onMouseRelease(mouseX, mouseY):
    # Change the radii of the basses.
    innerBass.radius -= 10
    outerBass.radius -= 10

    # Change the angle of the hi-hats.
    leftHiHat.rotateAngle = 45
    rightHiHat.rotateAngle = -45
",regular,2
2002,Honey jar,2.4,"app.background = gradient('lightSkyBlue', 'lightCyan', start='top')

# flower and tree
Rect(375, 200, 25, 200, fill=gradient('peru', 'saddleBrown', start='left'))
Circle(325, 200, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                   start='left'))
Circle(400, 200, 50, fill='green')
Circle(350, 150, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                   start='left-top'))
Circle(375, 100, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                   start='left-top'))
Circle(400, 50, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                  start='left-top'))

stickyHoney = Line(200, 275, 200, 200, lineWidth=40,
                   fill=gradient('chocolate', 'goldenrod', 'goldenrod',
                                 start='bottom'))
dipperStick = Line(200, 200, 400, 100,
                   fill=gradient('sienna', 'burlyWood', start='top'), lineWidth=20)
dipperTop = Line(200, 200, 240, 180,
                 fill=gradient('goldenrod', 'maroon', start='bottom'),
                 lineWidth=40, dashes=True)

Polygon(125, 265, 140, 275, 125, 300, 125, 375, 140, 400, 260, 400, 275, 375,
        275, 300, 260, 275, 275, 265,
        fill=gradient('chocolate', 'goldenrod', start='left'), border='goldenrod')

Rect(200, 340, 100, 50, fill='goldenrod', align='center')
Label('HONEY', 200, 340, fill='white', size=25, italic=True)

def onMousePress(mouseX, mouseY):
    # This changes the lineWidth and position of the honey.
    stickyHoney.y2 = mouseY
    stickyHoney.lineWidth = mouseY / 5 + 1

    # Change the y1 and y2 values of the dipperStick to move to the
    # location of click.
    ### Place Your Code Here ###

    # Change the y1 and y2 values of dipperTop.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightSkyBlue', 'lightCyan', start='top')

# flower and tree
Rect(375, 200, 25, 200, fill=gradient('peru', 'saddleBrown', start='left'))
Circle(325, 200, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                   start='left'))
Circle(400, 200, 50, fill='green')
Circle(350, 150, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                   start='left-top'))
Circle(375, 100, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                   start='left-top'))
Circle(400, 50, 50, fill=gradient('mediumSeaGreen', 'green', 'green',
                                  start='left-top'))

stickyHoney = Line(200, 275, 200, 200, lineWidth=40,
                   fill=gradient('chocolate', 'goldenrod', 'goldenrod',
                                 start='bottom'))
dipperStick = Line(200, 200, 400, 100,
                   fill=gradient('sienna', 'burlyWood', start='top'), lineWidth=20)
dipperTop = Line(200, 200, 240, 180,
                 fill=gradient('goldenrod', 'maroon', start='bottom'),
                 lineWidth=40, dashes=True)

Polygon(125, 265, 140, 275, 125, 300, 125, 375, 140, 400, 260, 400, 275, 375,
        275, 300, 260, 275, 275, 265,
        fill=gradient('chocolate', 'goldenrod', start='left'), border='goldenrod')

Rect(200, 340, 100, 50, fill='goldenrod', align='center')
Label('HONEY', 200, 340, fill='white', size=25, italic=True)

def onMousePress(mouseX, mouseY):
    # This changes the lineWidth and position of the honey.
    stickyHoney.y2 = mouseY
    stickyHoney.lineWidth = mouseY / 5 + 1

    # Change the y1 and y2 values of the dipperStick to move to the
    # location of click.
    dipperStick.y1 = mouseY
    dipperStick.y2 = mouseY - 100

    # Change the y1 and y2 values of dipperTop.
    dipperTop.y1 = mouseY
    dipperTop.y2 = mouseY - 20
",regular,1
1998,Rocket ship,2.4,"# The rocketShip function below has parameters which will determine what
# is drawn, but some of them have yet to be used...
def rocketShip(planetColor, isEngineOn, isOnPlanet):
    # space
    Rect(0, 0, 400, 400)
    Star(70, 100, 3, 5, fill='lightGrey')
    Star(25, 325, 3, 5, fill='lightGrey')
    Star(375, 275, 3, 5, fill='lightGrey')
    Star(325, 50, 3, 5, fill='lightGrey')
    Star(270, 185, 3, 6, fill='lightGrey')

    # rocket body
    Polygon(199, 205, 201, 205, 200, 180, fill='gold')
    Oval(200, 275, 50, 150, fill=gradient('gainsboro', 'darkGrey', start='right'))
    Rect(185, 335, 30, 20)
    Line(185, 335, 215, 335, fill='gold')

    # window
    Circle(200, 240, 15,
           fill=gradient('powderBlue', 'lightCyan', 'powderBlue',
                         start='right-top'), border='grey', borderWidth=4)

    # supports
    Polygon(185, 270, 165, 305, 160, 355, 175, 320, 185, 310, fill='maroon')
    Polygon(215, 270, 235, 305, 240, 355, 225, 320, 215, 310, fill='maroon')
    Line(200, 336, 200, 350, fill='maroon', lineWidth=3)

    # The fire should only be shown when isEngineOn is True.
    ### (HINT: Set a property using isEngineOn to hide or show the fire.)
    ### Fix Your Code Here ###
    Polygon(190, 335, 180, 360, 190, 355, 200, 370, 210, 355, 220, 360, 210,
            335, fill=gradient('yellow', 'orange', 'red', start='top'))

    # The planet should only be shown when isOnPlanet is True.
    # The planet should also be drawn using planetColor.
    ### (HINT: Set a property to isOnPlanet to hide or show the planet.)
    ### Fix Your Code Here ###
    Circle(200, 1000, 650, fill='grey')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# The rocketShip function below has parameters which will determine what
# is drawn, but some of them have yet to be used...
def rocketShip(planetColor, isEngineOn, isOnPlanet):
    # space
    Rect(0, 0, 400, 400)
    Star(70, 100, 3, 5, fill='lightGrey')
    Star(25, 325, 3, 5, fill='lightGrey')
    Star(375, 275, 3, 5, fill='lightGrey')
    Star(325, 50, 3, 5, fill='lightGrey')
    Star(270, 185, 3, 6, fill='lightGrey')

    # rocket body
    Polygon(199, 205, 201, 205, 200, 180, fill='gold')
    Oval(200, 275, 50, 150, fill=gradient('gainsboro', 'darkGrey', start='right'))
    Rect(185, 335, 30, 20)
    Line(185, 335, 215, 335, fill='gold')

    # window
    Circle(200, 240, 15,
           fill=gradient('powderBlue', 'lightCyan', 'powderBlue',
                         start='right-top'), border='grey', borderWidth=4)

    # supports
    Polygon(185, 270, 165, 305, 160, 355, 175, 320, 185, 310, fill='maroon')
    Polygon(215, 270, 235, 305, 240, 355, 225, 320, 215, 310, fill='maroon')
    Line(200, 336, 200, 350, fill='maroon', lineWidth=3)

    # The fire should only be shown when isEngineOn is True.
    ### (HINT: Set a property using isEngineOn to hide or show the fire.)
    Polygon(190, 335, 180, 360, 190, 355, 200, 370, 210, 355, 220, 360, 210,
            335, fill=gradient('yellow', 'orange', 'red', start='top'),
            visible=isEngineOn)

    # The planet should only be shown when isOnPlanet is True.
    # The planet should also be set by planetColor.
    Circle(200, 1000, 650, fill=planetColor, visible=isOnPlanet)
",regular,1
1995,Blinds,2.4,"app.background = gradient('deepSkyBlue', 'gold', start='top')

# sun
sun = Circle(200, 150, 40, fill=gradient('yellow', 'gold'))

def drawFlower(x, y):
    Line(x, y, x, y + 10, fill='springGreen')
    Star(x, y, 6, 8, fill='yellow')
    Circle(x, y, 2, fill='peru')

# hill
Oval(195, 400, 800, 300, fill=gradient('limeGreen', 'darkGreen', start='top'))
drawFlower(45, 275)
drawFlower(65, 335)
drawFlower(95, 290)
drawFlower(145, 260)
drawFlower(185, 350)
drawFlower(205, 285)
drawFlower(245, 300)
drawFlower(290, 275)
drawFlower(335, 325)
drawFlower(360, 345)

# window frame
Rect(0, 0, 400, 400, fill=None, border='saddleBrown', borderWidth=50)

# blinds and cord
cord = Line(390, 0, 390, 200, fill='white', lineWidth=3)
blinds = Line(195, 15, 195, 200, fill='beige', lineWidth=360, dashes=True)
Rect(10, 10, 370, 20, fill='wheat')

def onMousePress(mouseX, mouseY):
    # Change position of the sun and blinds.
    ### (HINT: Both the cord y2 value and sun centerX value should change
    #          according to mouseY.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'gold', start='top')

# sun
sun = Circle(200, 150, 40, fill=gradient('yellow', 'gold'))

def drawFlower(x, y):
    Line(x, y, x, y + 10, fill='springGreen')
    Star(x, y, 6, 8, fill='yellow')
    Circle(x, y, 2, fill='peru')

# hill
Oval(195, 400, 800, 300, fill=gradient('limeGreen', 'darkGreen', start='top'))
drawFlower(45, 275)
drawFlower(65, 335)
drawFlower(95, 290)
drawFlower(145, 260)
drawFlower(185, 350)
drawFlower(205, 285)
drawFlower(245, 300)
drawFlower(290, 275)
drawFlower(335, 325)
drawFlower(360, 345)

# window frame
Rect(0, 0, 400, 400, fill=None, border='saddleBrown', borderWidth=50)

# blinds and cord
cord = Line(390, 0, 390, 200, fill='white', lineWidth=3)
blinds = Line(195, 15, 195, 200, fill='beige', lineWidth=360, dashes=True)
Rect(10, 10, 370, 20, fill='wheat')

def onMousePress(mouseX, mouseY):
    # Change position of the sun and blinds.
    blinds.y2 = mouseY
    cord.y2 = 400 - mouseY

    sun.centerX = mouseY
",regular,2
2011,Creative task 5,2.5,# Fill me in!,,creative,30
2010,Creative task 4,2.5,# Fill me in!,,creative,30
2008,Creative task 2,2.5,# Fill me in!,,creative,30
2005,Rowboat,2.5,"app.background = gradient('midnightBlue', 'midnightBlue', 'orchid', start='top')

# background grass
Rect(0, 290, 400, 30, fill='darkGreen')

# trees
Polygon(0, 0, 25, 20, 35, 50, 60, 20, 90, 15, 105, 30, 100, 75, 90, 120,
        105, 135, 100, 190, 75, 210, 50, 240, 0, 250,
        fill=gradient('green', 'darkGreen', rgb(0, 40, 0)))
Polygon(340, 240, 275, 215, 255, 190, 240, 40, 305, 25, 340, 15, 400, 15,
        400, 240, fill=gradient('green', 'darkGreen', rgb(0, 40, 0)))
Polygon(0, 10, 20, 110, 50, 60, 85, 35, 60, 65, 40, 125, 65, 100, 30, 175,
        90, 150, 55, 207, 50, 250, 100, 320, 0, 320,
        fill=gradient('peru', 'sienna', 'saddleBrown', rgb(80, 40, 20)))
Polygon(150, 260, 105, 240, 75, 185, 70, 150, 80, 125, 90, 110, 70, 80, 90, 45,
        110, 15, 160, 30, 210, 10, 240, 40, 265, 100, 270, 170, 210, 235,
        fill=gradient('green', 'darkGreen', rgb(0, 40, 0)))
Polygon(110, 320, 135, 250, 90, 170, 130, 185, 120, 120, 90, 70, 125, 100,
        140, 140, 145, 85, 120, 40, 150, 70, 175, 100, 205, 40, 200, 120,
        235, 100, 200, 170, 250, 140, 200, 220, 225, 250, 275, 320,
        fill=gradient('peru', 'sienna', 'saddleBrown', rgb(80, 40, 20)))
Polygon(305, 320, 335, 220, 270, 170, 345, 195, 310, 135, 270, 120, 315, 120,
        350, 135, 310, 85, 265, 55, 325, 70, 360, 100, 375, 25, 380, 65, 400,
        140, 400, 320,
        fill=gradient('peru', 'sienna', 'saddleBrown', rgb(80, 40, 20)))
Rect(0, 320, 400, 400, fill=gradient('blue', 'darkBlue', 'black', start='top'))

# stars
Star(260, 240, 4, 20, fill='gold', opacity=50)
Star(85, 225, 3, 20, fill='gold', opacity=50)
Star(40, 15, 4, 20, fill='gold', opacity=80)
Star(320, 10, 4, 20, fill='gold', opacity=80)
Star(235, 20, 3, 20, fill='gold', opacity=80)
Star(170, 5, 3, 20, fill='gold', opacity=80)

# boat
boatBottom = Polygon(0, 300, 25, 350, 65, 360, 100, 362, 135, 360, 175, 350,
                     200, 300, fill=gradient(rgb(100, 40, 20), rgb(80, 20, 0)))
boatInside = Oval(100, 300, 200, 30, fill='saddleBrown')
boatSeats = Polygon(38, 292, 38, 313, 52, 315, 63, 315, 78, 315, 104, 315, 125,
                    315, 149, 315, 104, 288, 104, 315, 78, 315)
boatSeatCovers = Polygon(78, 315, 38, 292, 45, 285, 85, 308, 78, 315, 149, 315,
                         104, 288, 111, 281, 156, 308, 149, 315, fill='sienna')

# person
head = Circle(70, 250, 15)
forwardBody = Polygon(69, 250, 54, 301, 80, 301, 89, 315, 91, 315, 80, 299,
                      56, 299, 63, 279, 82, 291, 101, 275, 99, 275, 82, 289,
                      63, 277, 71, 250)
backwardBody = Polygon(39, 250, 64, 301, 90, 301, 99, 315, 101, 315, 90, 299,
                       66, 299, 52, 274, 85, 284, 85, 282, 52, 272, 41, 250,
                       visible=False)

# paddle
paddleStick = Line(92, 246, 130, 364, fill='saddleBrown', lineWidth=5)

# water
Rect(0, 340, 400, 60, fill='darkBlue', opacity=30)

# grass
grass = Star(50, 475, 150, 75, roundness=65,
             fill=gradient('lime', rgb(0, 50, 0), 'darkGreen', 'darkGreen',
                           start='top'))
Star(175, 455, 150, 65, fill=grass.fill, roundness=50)
Star(250, 465, 140, 90, fill=grass.fill, roundness=60)
Star(325, 480, 175, 75, fill=grass.fill, roundness=60)

def onMousePress(mouseX, mouseY):
    # Switches person to front position.
    head.centerX = boatBottom.centerX - 30
    forwardBody.visible = True
    backwardBody.visible = False
    paddleStick.x2 = boatBottom.centerX + 30

def onMouseRelease(mouseX, mouseY):
    # Switches person to back position.
    head.centerX = boatBottom.centerX - 60
    forwardBody.visible = False
    backwardBody.visible = True
    paddleStick.x2 = boatBottom.centerX - 30

    # Moves boat and person to the right.
    boatBottom.centerX += 20
    boatInside.centerX += 20
    boatSeats.centerX += 20
    boatSeatCovers.centerX += 20
    head.centerX += 20
    forwardBody.centerX += 20
    backwardBody.centerX += 20
    paddleStick.centerX += 20
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('midnightBlue', 'midnightBlue', 'orchid', start='top')

# background grass
Rect(0, 290, 400, 30, fill='darkGreen')

# trees
Polygon(0, 0, 25, 20, 35, 50, 60, 20, 90, 15, 105, 30, 100, 75, 90, 120,
        105, 135, 100, 190, 75, 210, 50, 240, 0, 250,
        fill=gradient('green', 'darkGreen', rgb(0, 40, 0)))
Polygon(340, 240, 275, 215, 255, 190, 240, 40, 305, 25, 340, 15, 400, 15,
        400, 240, fill=gradient('green', 'darkGreen', rgb(0, 40, 0)))
Polygon(0, 10, 20, 110, 50, 60, 85, 35, 60, 65, 40, 125, 65, 100, 30, 175,
        90, 150, 55, 207, 50, 250, 100, 320, 0, 320,
        fill=gradient('peru', 'sienna', 'saddleBrown', rgb(80, 40, 20)))
Polygon(150, 260, 105, 240, 75, 185, 70, 150, 80, 125, 90, 110, 70, 80, 90, 45,
        110, 15, 160, 30, 210, 10, 240, 40, 265, 100, 270, 170, 210, 235,
        fill=gradient('green', 'darkGreen', rgb(0, 40, 0)))
Polygon(110, 320, 135, 250, 90, 170, 130, 185, 120, 120, 90, 70, 125, 100,
        140, 140, 145, 85, 120, 40, 150, 70, 175, 100, 205, 40, 200, 120,
        235, 100, 200, 170, 250, 140, 200, 220, 225, 250, 275, 320,
        fill=gradient('peru', 'sienna', 'saddleBrown', rgb(80, 40, 20)))
Polygon(305, 320, 335, 220, 270, 170, 345, 195, 310, 135, 270, 120, 315, 120,
        350, 135, 310, 85, 265, 55, 325, 70, 360, 100, 375, 25, 380, 65, 400,
        140, 400, 320,
        fill=gradient('peru', 'sienna', 'saddleBrown', rgb(80, 40, 20)))
Rect(0, 320, 400, 400, fill=gradient('blue', 'darkBlue', 'black', start='top'))

# stars
Star(260, 240, 4, 20, fill='gold', opacity=50)
Star(85, 225, 3, 20, fill='gold', opacity=50)
Star(40, 15, 4, 20, fill='gold', opacity=80)
Star(320, 10, 4, 20, fill='gold', opacity=80)
Star(235, 20, 3, 20, fill='gold', opacity=80)
Star(170, 5, 3, 20, fill='gold', opacity=80)

# boat
boatBottom = Polygon(0, 300, 25, 350, 65, 360, 100, 362, 135, 360, 175, 350,
                     200, 300, fill=gradient(rgb(100, 40, 20), rgb(80, 20, 0)))
boatInside = Oval(100, 300, 200, 30, fill='saddleBrown')
boatSeats = Polygon(38, 292, 38, 313, 52, 315, 63, 315, 78, 315, 104, 315, 125,
                    315, 149, 315, 104, 288, 104, 315, 78, 315)
boatSeatCovers = Polygon(78, 315, 38, 292, 45, 285, 85, 308, 78, 315, 149, 315,
                         104, 288, 111, 281, 156, 308, 149, 315, fill='sienna')

# person
head = Circle(70, 250, 15)
forwardBody = Polygon(69, 250, 54, 301, 80, 301, 89, 315, 91, 315, 80, 299,
                      56, 299, 63, 279, 82, 291, 101, 275, 99, 275, 82, 289,
                      63, 277, 71, 250)
backwardBody = Polygon(39, 250, 64, 301, 90, 301, 99, 315, 101, 315, 90, 299,
                       66, 299, 52, 274, 85, 284, 85, 282, 52, 272, 41, 250,
                       visible=False)

# paddle
paddleStick = Line(92, 246, 130, 364, fill='saddleBrown', lineWidth=5)

# water
Rect(0, 340, 400, 60, fill='darkBlue', opacity=30)

# grass
grass = Star(50, 475, 150, 75, roundness=65,
             fill=gradient('lime', rgb(0, 50, 0), 'darkGreen', 'darkGreen',
                           start='top'))
Star(175, 455, 150, 65, fill=grass.fill, roundness=50)
Star(250, 465, 140, 90, fill=grass.fill, roundness=60)
Star(325, 480, 175, 75, fill=grass.fill, roundness=60)

def onMousePress(mouseX, mouseY):
    # Switches person to front position.
    head.centerX = boatBottom.centerX - 30
    forwardBody.visible = True
    backwardBody.visible = False
    paddleStick.x2 = boatBottom.centerX + 30

def onMouseRelease(mouseX, mouseY):
    # Switches person to back position.
    head.centerX = boatBottom.centerX - 60
    forwardBody.visible = False
    backwardBody.visible = True
    paddleStick.x2 = boatBottom.centerX - 30

    # Moves boat and person to the right.
    boatBottom.centerX += 20
    boatInside.centerX += 20
    boatSeats.centerX += 20
    boatSeatCovers.centerX += 20
    head.centerX += 20
    forwardBody.centerX += 20
    backwardBody.centerX += 20
    paddleStick.centerX += 20
",sample,1
2007,Dragon,2.5,"Rect(0, 0, 400, 400, fill='lightSkyBlue')

# back ceiling shadows
Polygon(0, 130, 25, 255, 40, 175, 55, 200, 70, 140, 95, 215, 125, 105, 145, 140,
        170, 50, 200, 155, 220, 50, 240, 55, 250, 50, 285, 180, 305, 90,
        320, 105, 350, 60, 400, 200, 400, 0, 0, 0, opacity=20)

# ceiling
Polygon(70, 0, 50, 160, 10, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(-10, 0, 25, 240, 45, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(55, 0, 90, 180, 130, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(110, 0, 145, 110, 175, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(170, 0, 200, 140, 215, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(215, 0, 235, 45, 255, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(265, 0, 320, 85, 366, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(250, 0, 285, 159, 312, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(340, 0, 399, 172, 440, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))

# ground
Rect(0, 330, 400, 70, fill=gradient('sandyBrown', 'bisque', start='top'))

# egg
Oval(170, 280, 200, 240, fill=gradient('cyan', 'deepSkyBlue', 'blue'))
Polygon(78, 235, 91, 247, 109, 229, 132, 257, 159, 230, 186, 262, 202, 241, 226,
        261, 244, 244, 270, 267, 272, 130, 69, 143, fill='lightSkyBlue')

# fire
fireYellow = Polygon(213, 150, 245, 160, 275, 170, 248, 175, 270, 192,
                     240, 195, 242, 223, 227, 203, 223, 177,
                     fill=gradient('lightYellow', 'yellow', start='left'),
                     opacity=80, visible=False)
fireOrange = Polygon(213, 150, 245, 160, 292, 158, 275, 170, 250, 167, 270, 190,
                     295, 190, 280, 200, 240, 193, 250, 215, 267, 223, 244, 220,
                     237, 205, 220, 220, 227, 180,
                     fill=gradient('white', 'orange', 'orangeRed', start='left'),
                     opacity=80, visible=False)
fireRed = Polygon(213, 150, 245, 160, 275, 150, 303, 145, 280, 155, 248, 175,
                  285, 177, 310, 190, 280, 185, 240, 182, 240, 182, 255, 200,
                  280, 200, 290, 225, 272, 210, 250, 210, 235, 195, 230, 222,
                  220, 195, 223, 177,
                  fill=gradient('darkRed', 'red', start='right'),
                  opacity=80, visible=False)

# back wing
Polygon(126, 121, 140, 111, 163, 154, 174, 154, 170, 195, 114, 178,
        fill=gradient('blue', 'midnightBlue', start='bottom'))
# stomach
Oval(185, 204, 60, 120, fill=gradient('cyan', 'violet', 'violet', start='right'),
     rotateAngle=-10)
# back body
Oval(170, 205, 50, 120, fill=gradient('darkBlue', 'blue', start='left'),
     rotateAngle=5)
# back horn
Polygon(150, 112, 140, 105, 150, 105, 168, 108, 185, 110, 185, 123,
        fill=gradient('blue', 'midnightBlue'))
# head
Circle(190, 140, 30, fill=gradient('darkBlue', 'blue', 'blue', start='left'))
mouthClosed = Oval(220, 153, 45, 35,
                   fill=gradient('blue', 'blue', 'royalBlue', start='left'),
                   rotateAngle=20)

# eye
Polygon(190, 128, 202, 128, 208, 140, 196, 138, fill='white')
Circle(199, 133, 5, fill=gradient('cyan', 'blue'))
Circle(201, 133, 2, fill='white')
# nose
Circle(230, 150, 3, fill=gradient('black', 'midnightBlue'))
# ear
Polygon(166, 130, 150, 128, 140, 130, 150, 142, 160, 145, 167, 143,
        fill=gradient('blue', 'cyan', start='left'), border='midnightBlue')
# wings
Polygon(160, 230, 163, 220, 170, 195, 145, 178, 125, 145, 125, 120,
        132, 107, 110, 115, 93, 130, 77, 160, 70, 190, 84, 247, 117, 265,
        155, 260, fill=gradient('blue', 'midnightBlue'), border='midnightBlue',
        borderWidth=5)
Polygon(95, 242, 83, 192, 90, 162, 105, 135, 98, 160, 103, 193, 125, 250, 117,
        265, fill=gradient('cyan', 'darkViolet', start='right'))
Polygon(133, 255, 115, 195, 108, 165, 110, 145, 115, 162, 123, 178, 137, 195,
        150, 203, 140, 255, fill=gradient('cyan', 'darkViolet', start='right'))
# horn
Polygon(185, 123, 163, 113, 152, 112, 142, 118, 132, 120, 120, 115, 120, 127,
        130, 133, 140, 130, 130, 128, 166, 130,
        fill=gradient('midnightBlue', 'blue', start='left'),
        border='midnightBlue')

# egg
Polygon(80, 235, 90, 250, 110, 230, 135, 250, 160, 230, 185, 265, 205, 240, 225,
        260, 245, 245, 270, 270, 165, 335,
        fill=gradient('cyan', 'deepSkyBlue', 'blue'))
Line(90, 250, 165, 335, fill='blue', lineWidth=1)
Line(135, 300, 120, 320, fill='blue', lineWidth=1)
Line(125, 315, 135, 320, fill='blue', lineWidth=1)
Line(120, 285, 155, 260, fill='blue', lineWidth=1)


# filter
Oval(200, 200, 1200, 600, fill=gradient('white', 'black', 'black', 'black'),
     opacity=30)

txt = Label('merp', 170, 50, size=50, font='monospace')

def onMousePress(mouseX, mouseY):
    # Makes fire visible.
    fireRed.visible = True
    fireOrange.visible = True
    fireYellow.visible = True
    txt.value = 'RAWR'

def onMouseRelease(mouseX, mouseY):
    # Makes fire invisible.
    fireYellow.visible = False
    fireOrange.visible = False
    fireRed.visible = False
    txt.value = 'merp'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(0, 0, 400, 400, fill='lightSkyBlue')

# back ceiling shadows
Polygon(0, 130, 25, 255, 40, 175, 55, 200, 70, 140, 95, 215, 125, 105, 145, 140,
        170, 50, 200, 155, 220, 50, 240, 55, 250, 50, 285, 180, 305, 90,
        320, 105, 350, 60, 400, 200, 400, 0, 0, 0, opacity=20)

# ceiling
Polygon(70, 0, 50, 160, 10, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(-10, 0, 25, 240, 45, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(55, 0, 90, 180, 130, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(110, 0, 145, 110, 175, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(170, 0, 200, 140, 215, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(215, 0, 235, 45, 255, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(265, 0, 320, 85, 366, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(250, 0, 285, 159, 312, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))
Polygon(340, 0, 399, 172, 440, 0,
        fill=gradient('darkGrey', 'lightBlue', 'silver', start='left'))

# ground
Rect(0, 330, 400, 70, fill=gradient('sandyBrown', 'bisque', start='top'))

# egg
Oval(170, 280, 200, 240, fill=gradient('cyan', 'deepSkyBlue', 'blue'))
Polygon(78, 235, 91, 247, 109, 229, 132, 257, 159, 230, 186, 262, 202, 241, 226,
        261, 244, 244, 270, 267, 272, 130, 69, 143, fill='lightSkyBlue')

# fire
fireYellow = Polygon(213, 150, 245, 160, 275, 170, 248, 175, 270, 192,
                     240, 195, 242, 223, 227, 203, 223, 177,
                     fill=gradient('lightYellow', 'yellow', start='left'),
                     opacity=80, visible=False)
fireOrange = Polygon(213, 150, 245, 160, 292, 158, 275, 170, 250, 167, 270, 190,
                     295, 190, 280, 200, 240, 193, 250, 215, 267, 223, 244, 220,
                     237, 205, 220, 220, 227, 180,
                     fill=gradient('white', 'orange', 'orangeRed', start='left'),
                     opacity=80, visible=False)
fireRed = Polygon(213, 150, 245, 160, 275, 150, 303, 145, 280, 155, 248, 175,
                  285, 177, 310, 190, 280, 185, 240, 182, 240, 182, 255, 200,
                  280, 200, 290, 225, 272, 210, 250, 210, 235, 195, 230, 222,
                  220, 195, 223, 177,
                  fill=gradient('darkRed', 'red', start='right'),
                  opacity=80, visible=False)

# back wing
Polygon(126, 121, 140, 111, 163, 154, 174, 154, 170, 195, 114, 178,
        fill=gradient('blue', 'midnightBlue', start='bottom'))
# stomach
Oval(185, 204, 60, 120, fill=gradient('cyan', 'violet', 'violet', start='right'),
     rotateAngle=-10)
# back body
Oval(170, 205, 50, 120, fill=gradient('darkBlue', 'blue', start='left'),
     rotateAngle=5)
# back horn
Polygon(150, 112, 140, 105, 150, 105, 168, 108, 185, 110, 185, 123,
        fill=gradient('blue', 'midnightBlue'))
# head
Circle(190, 140, 30, fill=gradient('darkBlue', 'blue', 'blue', start='left'))
mouthClosed = Oval(220, 153, 45, 35,
                   fill=gradient('blue', 'blue', 'royalBlue', start='left'),
                   rotateAngle=20)

# eye
Polygon(190, 128, 202, 128, 208, 140, 196, 138, fill='white')
Circle(199, 133, 5, fill=gradient('cyan', 'blue'))
Circle(201, 133, 2, fill='white')
# nose
Circle(230, 150, 3, fill=gradient('black', 'midnightBlue'))
# ear
Polygon(166, 130, 150, 128, 140, 130, 150, 142, 160, 145, 167, 143,
        fill=gradient('blue', 'cyan', start='left'), border='midnightBlue')
# wings
Polygon(160, 230, 163, 220, 170, 195, 145, 178, 125, 145, 125, 120,
        132, 107, 110, 115, 93, 130, 77, 160, 70, 190, 84, 247, 117, 265,
        155, 260, fill=gradient('blue', 'midnightBlue'), border='midnightBlue',
        borderWidth=5)
Polygon(95, 242, 83, 192, 90, 162, 105, 135, 98, 160, 103, 193, 125, 250, 117,
        265, fill=gradient('cyan', 'darkViolet', start='right'))
Polygon(133, 255, 115, 195, 108, 165, 110, 145, 115, 162, 123, 178, 137, 195,
        150, 203, 140, 255, fill=gradient('cyan', 'darkViolet', start='right'))
# horn
Polygon(185, 123, 163, 113, 152, 112, 142, 118, 132, 120, 120, 115, 120, 127,
        130, 133, 140, 130, 130, 128, 166, 130,
        fill=gradient('midnightBlue', 'blue', start='left'),
        border='midnightBlue')

# egg
Polygon(80, 235, 90, 250, 110, 230, 135, 250, 160, 230, 185, 265, 205, 240, 225,
        260, 245, 245, 270, 270, 165, 335,
        fill=gradient('cyan', 'deepSkyBlue', 'blue'))
Line(90, 250, 165, 335, fill='blue', lineWidth=1)
Line(135, 300, 120, 320, fill='blue', lineWidth=1)
Line(125, 315, 135, 320, fill='blue', lineWidth=1)
Line(120, 285, 155, 260, fill='blue', lineWidth=1)


# filter
Oval(200, 200, 1200, 600, fill=gradient('white', 'black', 'black', 'black'),
     opacity=30)

txt = Label('merp', 170, 50, size=50, font='monospace')

def onMousePress(mouseX, mouseY):
    # Makes fire visible.
    fireRed.visible = True
    fireOrange.visible = True
    fireYellow.visible = True
    txt.value = 'RAWR'

def onMouseRelease(mouseX, mouseY):
    # Makes fire invisible.
    fireYellow.visible = False
    fireOrange.visible = False
    fireRed.visible = False
    txt.value = 'merp'
",sample,1
2012,Collaborative task,2.5,# Fill me in!,,creative,30
2006,Creative task 1,2.5,# Fill me in!,,creative,30
2009,Creative task 3,2.5,# Fill me in!,,creative,30
2018,Cat petting,3.1.2,"app.background = 'powderBlue'

# armchair cushion and back
Oval(300, 150, 800, 250, fill=gradient('fireBrick', 'darkRed', start='top'))
Oval(300, 335, 1000, 275, fill=gradient('fireBrick', 'maroon', start='bottom'))
Line(40, 225, 30, 400, fill='darkRed', lineWidth=20, opacity=40)

# armchair arm
Rect(25, 155, 40, 245, fill='fireBrick', border='darkRed', align='right-top')
Circle(45, 155, 60, fill=gradient('fireBrick', 'maroon'), border='darkRed',
       align='right')

# body
Oval(150, 250, 500, 200,
     fill=gradient('sandyBrown', rgb(210, 135, 85), start='top'), align='left')

# legs
Circle(50, 250, 15, fill='white')
Rect(50, 225, 125, 30, rotateAngle=-10,
     fill=gradient('sandyBrown', rgb(215, 145, 85), start='left'))
Circle(155, 365, 15, fill='white')
Rect(150, 325, 120, 30, rotateAngle=-25,
     fill=gradient('sandyBrown', rgb(215, 145, 85), start='left'))

# ears
Oval(140, 130, 80, 50, fill='sandyBrown', rotateAngle=50)
Oval(135, 130, 50, 30, fill='salmon', rotateAngle=50)
Oval(255, 130, 80, 50, fill='sandyBrown', rotateAngle=130)
Oval(260, 130, 50, 30, fill='salmon', rotateAngle=130)

# face
Oval(200, 200, 200, 190, fill='sandyBrown')

# mouth
Oval(185, 235, 35, 30, fill=None, border='black')
Oval(215, 235, 35, 30, fill=None, border='black')

# eyes
Circle(165, 185, 30, fill='azure')
Circle(235, 185, 30, fill='azure', border='black')
Circle(170, 190, 20, fill='powderBlue')
Circle(230, 190, 20, fill='powderBlue')
Circle(172, 195, 10)
Circle(228, 195, 10)

leftEyelid = Circle(165, 185, 30, fill=None, border='sienna')
rightEyelid = Circle(235, 185, 30, fill=None, border='sienna')
eyelidCover = Rect(200, 240, 140, 25, fill='sandyBrown', align='bottom')

# nose
RegularPolygon(200, 225, 10, 3, fill='salmon')

# whiskers
Line(170, 220, 90, 200, lineWidth=1)
Line(175, 225, 85, 225, lineWidth=1)
Line(170, 230, 90, 250, lineWidth=1)
Line(230, 220, 310, 200, lineWidth=1)
Line(225, 225, 315, 225, lineWidth=1)
Line(230, 230, 310, 250, lineWidth=1)

def onMouseRelease(mouseX, mouseY):
    # Show the eyes by changing the height and bottom of the eyelidCover.
    # Then, change the eyelid's fills.
    ### (HINT: To do this, you will need to modify the eyelidCover, leftEyelid,
    #          and rightEyelid variables.)
    ### Place Your Code Here ###

    # Add a heart centered at mouseX, mouseY using two ovals.
    ### Place Your Code Here ###
    pass

def onMouseDrag(mouseX, mouseY):
    # Hide the eyes using the eyelids and reset the eyelidCover's height and
    # bottom.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'powderBlue'

# armchair cushion and back
Oval(300, 150, 800, 250, fill=gradient('fireBrick', 'darkRed', start='top'))
Oval(300, 335, 1000, 275, fill=gradient('fireBrick', 'maroon', start='bottom'))
Line(40, 225, 30, 400, fill='darkRed', lineWidth=20, opacity=40)

# armchair arm
Rect(25, 155, 40, 245, fill='fireBrick', border='darkRed', align='right-top')
Circle(45, 155, 60, fill=gradient('fireBrick', 'maroon'), border='darkRed',
       align='right')

# body
Oval(150, 250, 500, 200,
     fill=gradient('sandyBrown', rgb(210, 135, 85), start='top'), align='left')

# legs
Circle(50, 250, 15, fill='white')
Rect(50, 225, 125, 30, rotateAngle=-10,
     fill=gradient('sandyBrown', rgb(215, 145, 85), start='left'))
Circle(155, 365, 15, fill='white')
Rect(150, 325, 120, 30, rotateAngle=-25,
     fill=gradient('sandyBrown', rgb(215, 145, 85), start='left'))

# ears
Oval(140, 130, 80, 50, fill='sandyBrown', rotateAngle=50)
Oval(135, 130, 50, 30, fill='salmon', rotateAngle=50)
Oval(255, 130, 80, 50, fill='sandyBrown', rotateAngle=130)
Oval(260, 130, 50, 30, fill='salmon', rotateAngle=130)

# face
Oval(200, 200, 200, 190, fill='sandyBrown')

# mouth
Oval(185, 235, 35, 30, fill=None, border='black')
Oval(215, 235, 35, 30, fill=None, border='black')

# eyes
Circle(165, 185, 30, fill='azure')
Circle(235, 185, 30, fill='azure', border='black')
Circle(170, 190, 20, fill='powderBlue')
Circle(230, 190, 20, fill='powderBlue')
Circle(172, 195, 10)
Circle(228, 195, 10)

leftEyelid = Circle(165, 185, 30, fill=None, border='sienna')
rightEyelid = Circle(235, 185, 30, fill=None, border='sienna')
eyelidCover = Rect(200, 240, 140, 25, fill='sandyBrown', align='bottom')

# nose
RegularPolygon(200, 225, 10, 3, fill='salmon')

# whiskers
Line(170, 220, 90, 200, lineWidth=1)
Line(175, 225, 85, 225, lineWidth=1)
Line(170, 230, 90, 250, lineWidth=1)
Line(230, 220, 310, 200, lineWidth=1)
Line(225, 225, 315, 225, lineWidth=1)
Line(230, 230, 310, 250, lineWidth=1)

def onMouseRelease(mouseX, mouseY):
    # Show the eyes by changing the height and bottom of the eyelidCover.
    # Then, change the eyelid's fills.
    eyelidCover.height = 25
    eyelidCover.bottom = 240
    leftEyelid.fill = None
    rightEyelid.fill = None

    # Add a heart centered at mouseX, mouseY using two ovals.
    Oval(mouseX - 3, mouseY, 20, 12, fill='red', rotateAngle=35)
    Oval(mouseX + 3, mouseY, 20, 12, fill='red', rotateAngle=-35)

def onMouseDrag(mouseX, mouseY):
    # Hide the eyes using the eyelids and reset the eyelidCover's height and
    # bottom.
    eyelidCover.height = 50
    eyelidCover.bottom = 240
    leftEyelid.fill = 'sandyBrown'
    rightEyelid.fill = 'sandyBrown'
",regular,3
2019,Controlling ovals,3.1.2,"app.background = gradient('skyBlue', 'lightBlue', start='top')

o = Oval(200, 200, 200, 200, fill=gradient('lemonChiffon', 'gold'))

def onMouseMove(mouseX, mouseY):
    # Change the width and height of the oval based on mouse position.
    # Make sure there are no issues when mouseX or mouseY is 0!
    ### (HINT: Carefully use the Inspector to figure out how to update
    #          the width and height using mouseX and mouseY.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('skyBlue', 'lightBlue', start='top')

o = Oval(200, 200, 200, 200, fill=gradient('lemonChiffon', 'gold'))

def onMouseMove(mouseX, mouseY):
    # Change the width and height of the oval based on mouse position.
    # Make sure there are no issues when mouseX or mouseY is 0!
    o.width = mouseX + 1
    o.height = mouseY + 1
",regular,1
2020,File select,3.1.2,"app.background = 'black'

# header
Rect(0, 370, 400, 30, fill='white', opacity=70)
Label('File', 60, 385, size=18)
Label('Edit', 120, 385, size=18)
Label('View', 180, 385, size=18)
Label('History', 255, 385, size=18)
Label('Help', 330, 385, size=18)

# math folder
Polygon(50, 40, 85, 40, 90, 50, 50, 50,
        fill=gradient('skyBlue', 'lightBlue', start='top'))
Rect(50, 50, 100, 70, fill=gradient('skyBlue', 'lightSkyBlue', start='top'))
Label('Math', 100, 140, fill='white', size=16)

# science folder
Polygon(230, 40, 265, 40, 270, 50, 230, 50,
        fill=gradient('skyBlue', 'lightBlue', start='top'))
Rect(230, 50, 100, 70, fill=gradient('skyBlue', 'lightSkyBlue', start='top'))
Label('Science', 280, 140, fill='white', size=16)

# essay
Rect(60, 200, 80, 100, fill=gradient('gainsboro', 'white', start='top'))
Label('Essay', 100, 320, fill='white', size=16)

selected = Rect(0, 0, 200, 170, fill='white', border='white', opacity=30)

def onMouseDrag(mouseX, mouseY):
    # Drag the selected rectangle's right-bottom corner with the mouse.
    ### (HINT: Add 1 to the mouse values since the width and height of a Rect
    #          can never be 0!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# header
Rect(0, 370, 400, 30, fill='white', opacity=70)
Label('File', 60, 385, size=18)
Label('Edit', 120, 385, size=18)
Label('View', 180, 385, size=18)
Label('History', 255, 385, size=18)
Label('Help', 330, 385, size=18)

# math folder
Polygon(50, 40, 85, 40, 90, 50, 50, 50,
        fill=gradient('skyBlue', 'lightBlue', start='top'))
Rect(50, 50, 100, 70, fill=gradient('skyBlue', 'lightSkyBlue', start='top'))
Label('Math', 100, 140, fill='white', size=16)

# science folder
Polygon(230, 40, 265, 40, 270, 50, 230, 50,
        fill=gradient('skyBlue', 'lightBlue', start='top'))
Rect(230, 50, 100, 70, fill=gradient('skyBlue', 'lightSkyBlue', start='top'))
Label('Science', 280, 140, fill='white', size=16)

# essay
Rect(60, 200, 80, 100, fill=gradient('gainsboro', 'white', start='top'))
Label('Essay', 100, 320, fill='white', size=16)

selected = Rect(0, 0, 200, 170, fill='white', border='white', opacity=30)

def onMouseDrag(mouseX, mouseY):
    # Drag the selected rectangle's right-bottom corner with the mouse.
    ### (HINT: Add 1 to the mouse values since the width and height of a Rect
    #          can never be 0!)
    selected.width = mouseX + 1
    selected.height = mouseY + 1
",regular,1
2015,Mirror mouse,3.1.2,"app.background = gradient('dodgerBlue', 'navy')

dot1 = Circle(100, 100, 10, fill=gradient('lightCoral', 'crimson'))
dot2 = Circle(300, 100, 10, fill=gradient('lightCoral', 'crimson'))
dot3 = Circle(100, 300, 10, fill=gradient('lightCoral', 'crimson'))
dot4 = Circle(300, 300, 10, fill=gradient('lightCoral', 'crimson'))

Line(0, 200, 400, 200, dashes=True)
Line(200, 400, 200, 0, dashes=True)

def onMouseMove(mouseX, mouseY):
    # Dot 1 should follow the mouse exactly.
    ### Place Your Code Here ###

    # Dot 2 should follow the mouse but reflected in horizontal movement.
    ### Place Your Code Here ###

    # Dot 3 should follow the mouse but reflected in vertical movement.
    ### Place Your Code Here ###

    # Dot 4 should follow the mouse but reflected in both horizontal and
    # vertical movement.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('dodgerBlue', 'navy')

dot1 = Circle(100, 100, 10, fill=gradient('lightCoral', 'crimson'))
dot2 = Circle(300, 100, 10, fill=gradient('lightCoral', 'crimson'))
dot3 = Circle(100, 300, 10, fill=gradient('lightCoral', 'crimson'))
dot4 = Circle(300, 300, 10, fill=gradient('lightCoral', 'crimson'))

Line(0, 200, 400, 200, dashes=True)
Line(200, 400, 200, 0, dashes=True)

def onMouseMove(mouseX, mouseY):
    # Dot 1 should follow the mouse exactly.
    dot1.centerX = mouseX
    dot1.centerY = mouseY

    # Dot 2 should follow the mouse but reflected in horizontal movement.
    dot2.centerX = 400 - mouseX
    dot2.centerY = mouseY

    # Dot 3 should follow the mouse but reflected in vertical movement.
    dot3.centerX = mouseX
    dot3.centerY = 400 - mouseY

    # Dot 4 should follow the mouse but reflected in both horizontal and
    # vertical movement.
    dot4.centerX = 400 - mouseX
    dot4.centerY = 400 - mouseY
",regular,2
2016,Swing set,3.1.2,"# background
app.background = gradient('deepSkyBlue', 'white', 'forestGreen', start='top')

Oval(390, 90, 400, 150, fill=gradient('snow', 'white', start='bottom'))
Oval(205, 315, 400, 150, fill=rgb(185, 245, 150))

# swing set top bar
Line(110, 98, 330, 113, fill=gradient('saddleBrown', 'sienna', 'saddleBrown',
                                      start='left'), lineWidth=10)

# swing set left side
Line(115, 100, 140, 270, fill='saddleBrown', lineWidth=10)
Line(115, 100, 65, 320, fill=gradient('saddleBrown', 'sienna', start='bottom'),
     lineWidth=10)

# ropes and seat
leftRope = Line(175, 105, 175, 260)
seat = Line(175, 260, 225, 270, fill=gradient('red', 'fireBrick'), lineWidth=15)
rightRope = Line(225, 110, 225, 270)

# swing set right side
Line(325, 115, 355, 330, fill='saddleBrown', lineWidth=10)
Line(325, 115, 290, 365, fill=gradient('saddleBrown', 'sienna', start='bottom'),
     lineWidth=10)

def onMouseMove(mouseX, mouseY):
    # First update the seat location with mouseX and mouseY.
    ### Place Your Code Here ###

    # Then change properties of the leftRope and rightRope with respect to
    # the seat.
    ### (HINT: Set either the x1, y1 or x2, y2 properties!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
app.background = gradient('deepSkyBlue', 'white', 'forestGreen', start='top')

Oval(390, 90, 400, 150, fill=gradient('snow', 'white', start='bottom'))
Oval(205, 315, 400, 150, fill=rgb(185, 245, 150))

# swing set top bar
Line(110, 98, 330, 113, fill=gradient('saddleBrown', 'sienna', 'saddleBrown',
                                      start='left'), lineWidth=10)

# swing set left side
Line(115, 100, 140, 270, fill='saddleBrown', lineWidth=10)
Line(115, 100, 65, 320, fill=gradient('saddleBrown', 'sienna', start='bottom'),
     lineWidth=10)

# ropes and seat
leftRope = Line(175, 105, 175, 260)
seat = Line(175, 260, 225, 270, fill=gradient('red', 'fireBrick'), lineWidth=15)
rightRope = Line(225, 110, 225, 270)

# swing set right side
Line(325, 115, 355, 330, fill='saddleBrown', lineWidth=10)
Line(325, 115, 290, 365, fill=gradient('saddleBrown', 'sienna', start='bottom'),
     lineWidth=10)

def onMouseMove(mouseX, mouseY):
    # First update the seat location with mouseX and mouseY.
    seat.centerX = mouseX
    seat.centerY = mouseY

    # Then change properties of the leftRope and rightRope with respect to
    # the seat.
    leftRope.x2 = seat.x1
    leftRope.y2 = seat.y1

    rightRope.x2 = seat.x2
    rightRope.y2 = seat.y2
",regular,1
2017,Fruit ninja,3.1.2,"app.background = 'peru'

# main watermelon
Oval(200, 200, 200, 250,
     fill=gradient('darkGreen', 'lime', 'darkGreen', 'lime', 'darkGreen', 'lime',
                   start='right-top'), border='saddleBrown', rotateAngle=-40)

title = Label('Fruit', 200, 30,
              fill=gradient('purple', 'red', 'yellow', 'orange', 'green',
                            start='left'), size=45, bold=True)

# watermelon insides
Rect(188, 215, 75, 250, fill='peru', rotateAngle=40, align='center')
Oval(225, 225, 20, 190, fill='red', rotateAngle=40)

# seeds
Circle(180, 280, 2)
Circle(200, 250, 2)
Circle(210, 240, 2)
Circle(230, 215, 2)
Circle(250, 200, 2)
Circle(260, 180, 2)

blade = Polygon(110, 315, 265, 85, 305, 60, 300, 100, fill='white',
                border=gradient('white', 'peru'), borderWidth=4, visible=False)

# Covers the sliced part of the watermelon.
watermelonCover = Oval(200, 200, 200, 250, border='saddleBrown', rotateAngle=-40,
                       fill=gradient('darkGreen', 'lime', 'darkGreen', 'lime',
                                     'darkGreen', 'lime', start='right-top'))

def onMouseDrag(mouseX, mouseY):
    # Show the blade, move the blade, and hide the watermelonCover.
    ### (HINT: The centerY of the blade should be the canvas width minus
    #          the current x of the mouse.)
    ### Place Your Code Here ###

    # Change the title text.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Hides the blade and shows the whole watermelon.
    blade.visible = False
    watermelonCover.visible = True

    # Changes the title text back.
    title.value = 'Fruit'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'peru'

# main watermelon
Oval(200, 200, 200, 250,
     fill=gradient('darkGreen', 'lime', 'darkGreen', 'lime', 'darkGreen', 'lime',
                   start='right-top'), border='saddleBrown', rotateAngle=-40)

title = Label('Fruit', 200, 30,
              fill=gradient('purple', 'red', 'yellow', 'orange', 'green',
                            start='left'), size=45, bold=True)

# watermelon insides
Rect(188, 215, 75, 250, fill='peru', rotateAngle=40, align='center')
Oval(225, 225, 20, 190, fill='red', rotateAngle=40)

# seeds
Circle(180, 280, 2)
Circle(200, 250, 2)
Circle(210, 240, 2)
Circle(230, 215, 2)
Circle(250, 200, 2)
Circle(260, 180, 2)

blade = Polygon(110, 315, 265, 85, 305, 60, 300, 100, fill='white',
                border=gradient('white', 'peru'), borderWidth=4, visible=False)

# Covers the sliced part of the watermelon.
watermelonCover = Oval(200, 200, 200, 250, border='saddleBrown', rotateAngle=-40,
                       fill=gradient('darkGreen', 'lime', 'darkGreen', 'lime',
                                     'darkGreen', 'lime', start='right-top'))

def onMouseDrag(mouseX, mouseY):
    # Show the blade, move the blade, and hide the watermelonCover.
    blade.visible = True
    blade.centerX = mouseX
    blade.centerY = 400 - mouseX
    watermelonCover.visible = False

    # Change the title text.
    title.value = 'Fruit Ninja'

def onMouseRelease(mouseX, mouseY):
    # Hide the blade and show the whole watermelon.
    blade.visible = False
    watermelonCover.visible = True

    # Change the title text back.
    title.value = 'Fruit'
",regular,2
2021,if Statements Checkpoint 4,3.2.1.1,"app.background = gradient('maroon', 'black')

Label('Cookies Clicker!', 200, 20, fill='white', size=20, bold=True)

# cookie
Circle(200, 200, 105, fill=gradient('burlyWood', 'peru'))

# chocolate chips
Circle(210, 200, 10, fill='saddleBrown')
Circle(160, 130, 10, fill='saddleBrown')
Circle(280, 220, 10, fill='saddleBrown')
Circle(240, 150, 10, fill='saddleBrown')
Circle(140, 255, 10, fill='saddleBrown')
Circle(210, 245, 10, fill='saddleBrown')
Circle(130, 200, 10, fill='saddleBrown')

counter = Label(0, 200, 200, fill='white', size=64)

def onMousePress(mouseX, mouseY):
    # Increase the number of times we clicked on the cookie until it reaches 3.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('maroon', 'black')

Label('Cookies Clicker!', 200, 20, fill='white', size=20, bold=True)

# cookie
Circle(200, 200, 105, fill=gradient('burlyWood', 'peru'))

# chocolate chips
Circle(210, 200, 10, fill='saddleBrown')
Circle(160, 130, 10, fill='saddleBrown')
Circle(280, 220, 10, fill='saddleBrown')
Circle(240, 150, 10, fill='saddleBrown')
Circle(140, 255, 10, fill='saddleBrown')
Circle(210, 245, 10, fill='saddleBrown')
Circle(130, 200, 10, fill='saddleBrown')

counter = Label(0, 200, 200, fill='white', size=64)

def onMousePress(mouseX, mouseY):
    # Increase the number of times we clicked on the cookie until it reaches 3.
    if (counter.value < 3):
        counter.value += 1
",regular,1
2022,if Statements Checkpoint 5,3.2.1.1,"Label('Purple Click Counter', 200, 20, size=20, bold=True)
Label('Click in the purple part of', 200, 45)
Label('the canvas to increase the counter!', 200, 65)

Polygon(0, 0, 0, 400, 400, 400, fill='purple')
counter = Label(0, 125, 275, fill='plum', size=100, bold=True)

def onMousePress(mouseX, mouseY):
    # The counter value should increase if the click is on the purple side of
    # the canvas.
    ### (HINT: Every point in the purple area has mouseY at least as big as
    #          mouseX!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Label('Purple Click Counter', 200, 20, size=20, bold=True)
Label('Click in the purple part of', 200, 45)
Label('the canvas to increase the counter!', 200, 65)

Polygon(0, 0, 0, 400, 400, 400, fill='purple')
counter = Label(0, 125, 275, fill='plum', size=100, bold=True)

def onMousePress(mouseX, mouseY):
    # The counter value should increase if the click is on the purple side of
    # the canvas.
    if (mouseX <= mouseY):
       counter.value += 1
",regular,1
2023,Sun and Moon,3.2.2,"# skies
Rect(0, 0, 400, 200, fill='lightSkyBlue')
Rect(0, 200, 400, 200)

# Create variables for sun and moon here.
### Fix Your Code Here ###
# sun =
# moon =

# top trees
Rect(305, 190, 5, 10, fill='sienna')
Polygon(300, 190, 315, 190, 307, 160, fill='forestGreen')

Rect(335, 190, 5, 10, fill='sienna')
Polygon(330, 190, 345, 190, 337, 140, fill='forestGreen')

# bottom trees
Polygon(305, 200, 310, 200, 307, 250, fill='saddleBrown', opacity=50)
Line(305, 210, 300, 215, fill='saddleBrown', opacity=50)
Line(308, 215, 315, 220, fill='saddleBrown', opacity=50)

Polygon(335, 200, 340, 200, 337, 270, fill='saddleBrown', opacity=50)
Line(338, 215, 345, 220, fill='saddleBrown', opacity=50)
Line(335, 225, 330, 230, fill='saddleBrown', opacity=50)
Line(338, 235, 345, 240, fill='saddleBrown', opacity=50)

def onMousePress(mouseX, mouseY):
    # When the mouse press is in the sky, move the sun to the pressed location
    # and reflect the moon.
    ### (HINT: The sun's bottom should not be able to be below the bottom of
    #          the sky!)
    ### (HINT: The sun and the moon have same centerX and reflecting centerY.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# skies
Rect(0, 0, 400, 200, fill='lightSkyBlue')
Rect(0, 200, 400, 200)

# sun/moon
sun = Circle(100, 100, 20, fill='gold')
moon = Circle(100, 300, 20, fill='lightGray')

# top trees
Rect(305, 190, 5, 10, fill='sienna')
Polygon(300, 190, 315, 190, 307, 160, fill='forestGreen')

Rect(335, 190, 5, 10, fill='sienna')
Polygon(330, 190, 345, 190, 337, 140, fill='forestGreen')

# bottom trees
Polygon(305, 200, 310, 200, 307, 250, fill='saddleBrown', opacity=50)
Line(305, 210, 300, 215, fill='saddleBrown', opacity=50)
Line(308, 215, 315, 220, fill='saddleBrown', opacity=50)

Polygon(335, 200, 340, 200, 337, 270, fill='saddleBrown', opacity=50)
Line(338, 215, 345, 220, fill='saddleBrown', opacity=50)
Line(335, 225, 330, 230, fill='saddleBrown', opacity=50)
Line(338, 235, 345, 240, fill='saddleBrown', opacity=50)

def onMousePress(mouseX, mouseY):
    # When the mouse press is in the sky, move the sun to the pressed location
    # and reflect the moon.
    if (mouseY < 180):
        sun.centerX = mouseX
        sun.centerY = mouseY
        moon.centerX = mouseX
        moon.centerY = 400 - mouseY
",regular,1
2026,Feed the kitty,3.2.2,"# background
app.background = rgb(170, 185, 55)
Circle(200, 200, 150, fill='white')

# ears
Polygon(261, 158, 305, 132, 280, 195, fill=rgb(145, 170, 110),
        border=rgb(53, 31, 22), borderWidth=6)
Polygon(139, 158, 95, 132, 120, 195, fill=rgb(145, 170, 110),
        border=rgb(53, 31, 22), borderWidth=6),
Polygon(227, 129, 305, 133, 264, 160, border=rgb(55, 30, 20), borderWidth=6)
Polygon(173, 129, 95, 133, 136, 160, border=rgb(55, 30, 20), borderWidth=6)

# face and body
Oval(200, 276, 120, 130, border=rgb(55, 30, 20), borderWidth=6)
Circle(200, 200, 80, border=rgb(55, 30, 20), borderWidth=8)

# plate
Oval(200, 323, 140, 45, fill='beige', border=rgb(55, 30, 20), borderWidth=3)
Oval(200, 312, 200, 50, fill='white', border=rgb(55, 30, 20), borderWidth=4)
Oval(200, 317, 150, 30, fill=None, border=rgb(170, 185, 55), borderWidth=3)

# hands
Oval(165, 285, 30, 35, border=rgb(55, 30, 20), borderWidth=5, rotateAngle=-20)
Oval(235, 285, 30, 35, border=rgb(55, 30, 20), borderWidth=5, rotateAngle=20)

# eyes and tears
Oval(163, 193, 75, 100, fill='beige', border=rgb(55, 30, 20), borderWidth=4,
     rotateAngle=5)
Oval(237, 193, 75, 100, fill='beige', border=rgb(55, 30, 20), borderWidth=4,
     rotateAngle=-5)
leftEye = Oval(165, 185, 45, 55, border=rgb(55, 30, 20), borderWidth=4)
rightEye = Oval(235, 185, 45, 55, border=rgb(55, 30, 20), borderWidth=4)
leftTear = Oval(150, 240, 25, 15, fill='lightCyan', border=rgb(85, 130, 125))
rightTear = Oval(250, 240, 25, 15, fill='lightCyan', border=rgb(85, 130, 125))

# message
message = Label('pleeeease', 200, 90, fill=rgb(170, 185, 55), size=25, bold=True)

# food
foodPile = Oval(200, 320, 10, 5, fill='lightSalmon')
food = Circle(200, 30, 10, fill='lightSalmon', border='black', borderWidth=4)

def onMousePress(mouseX, mouseY):
    # The cat is not happy until the pile of food has a height of 30 pixels.
    # Until then, increase the width and height of the pile.
    ### (HINT: The food width should increase by 5, and height by 2.)
    ### (HINT: Make sure to set the bottom of the foodPile to 325!)
    ### Place Your Code Here ###

    # When the food has a height of at least 30 pixels, change the message
    # text and hide the tears.
    ### Place Your Code Here ###
    pass

def onMouseMove(mouseX, mouseY):
    # Moves the food as the mouse moves.
    food.centerX = mouseX
    food.centerY = mouseY

    # Makes the eyes follow the food.
    leftEye.centerX = 155 + (mouseX / 20)
    leftEye.centerY = 180 + (mouseY / 20)
    rightEye.centerX = 225 + (mouseX / 20)
    rightEye.centerY = 180 + (mouseY / 20)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
app.background = rgb(170, 185, 55)
Circle(200, 200, 150, fill='white')

# ears
Polygon(261, 158, 305, 132, 280, 195, fill=rgb(145, 170, 110),
        border=rgb(53, 31, 22), borderWidth=6)
Polygon(139, 158, 95, 132, 120, 195, fill=rgb(145, 170, 110),
        border=rgb(53, 31, 22), borderWidth=6),
Polygon(227, 129, 305, 133, 264, 160, border=rgb(55, 30, 20), borderWidth=6)
Polygon(173, 129, 95, 133, 136, 160, border=rgb(55, 30, 20), borderWidth=6)

# face and body
Oval(200, 276, 120, 130, border=rgb(55, 30, 20), borderWidth=6)
Circle(200, 200, 80, border=rgb(55, 30, 20), borderWidth=8)

# plate
Oval(200, 323, 140, 45, fill='beige', border=rgb(55, 30, 20), borderWidth=3)
Oval(200, 312, 200, 50, fill='white', border=rgb(55, 30, 20), borderWidth=4)
Oval(200, 317, 150, 30, fill=None, border=rgb(170, 185, 55), borderWidth=3)

# hands
Oval(165, 285, 30, 35, border=rgb(55, 30, 20), borderWidth=5, rotateAngle=-20)
Oval(235, 285, 30, 35, border=rgb(55, 30, 20), borderWidth=5, rotateAngle=20)

# eyes and tears
Oval(163, 193, 75, 100, fill='beige', border=rgb(55, 30, 20), borderWidth=4,
     rotateAngle=5)
Oval(237, 193, 75, 100, fill='beige', border=rgb(55, 30, 20), borderWidth=4,
     rotateAngle=-5)
leftEye = Oval(165, 185, 45, 55, border=rgb(55, 30, 20), borderWidth=4)
rightEye = Oval(235, 185, 45, 55, border=rgb(55, 30, 20), borderWidth=4)
leftTear = Oval(150, 240, 25, 15, fill='lightCyan', border=rgb(85, 130, 125))
rightTear = Oval(250, 240, 25, 15, fill='lightCyan', border=rgb(85, 130, 125))

# message
message = Label('pleeeease', 200, 90, fill=rgb(170, 185, 55), size=25, bold=True)

# food
foodPile = Oval(200, 320, 10, 5, fill='lightSalmon')
food = Circle(200, 30, 10, fill='lightSalmon', border='black', borderWidth=4)

def onMousePress(mouseX, mouseY):
    # The cat is not happy until the pile of food has a height of 30 pixels.
    # Until then, increase the width and height of the pile.
    if (foodPile.height < 30):
        foodPile.width += 5
        foodPile.height += 2
        foodPile.bottom = 325

    # When the food has a height of at least 30 pixels, change the message
    # text and hide the tears.
    if (foodPile.height >= 30):
        message.value = 'meow'
        rightTear.visible = False
        leftTear.visible = False

def onMouseMove(mouseX, mouseY):
    # Moves the food as the mouse moves.
    food.centerX = mouseX
    food.centerY = mouseY

    # Makes the eyes follow the food.
    leftEye.centerX = 155 + (mouseX / 20)
    leftEye.centerY = 180 + (mouseY / 20)
    rightEye.centerX = 225 + (mouseX / 20)
    rightEye.centerY = 180 + (mouseY / 20)
",regular,2
2429,Melting ice,3.2.2,"# background
Rect(0, 0, 400, 400, fill=gradient('turquoise', 'paleTurquoise'))

# sun
Star(0, 0, 120, 60, fill='yellow', roundness=40)
Circle(0, 0, 90, fill=gradient('yellow', 'khaki'))

# glass of cranberry juice
Rect(160, 150, 180, 250, fill='azure')
juice = Rect(170, 200, 160, 190, fill=gradient('tomato', 'coral', start='bottom'))

# ice cubes
iceCube1 = Rect(180, 220, 40, 40, fill=rgb(229, 229, 229))
iceCube2 = Rect(240, 250, 30, 30, fill=rgb(229, 229, 229))
iceCube3 = Rect(200, 300, 35, 35, fill=rgb(229, 229, 229))

# straw
Rect(290, 110, 10, 270,
     fill=gradient('tomato', 'tomato', 'tomato', 'red', start='bottom'))
Rect(290, 100, 70, 10, fill='red')


def onMousePress(mouseX, mouseY):
    # An error occurs if you click too many times. Use the error message in
    # the console to figure out what is wrong and fix it!
    ### (HINT: Use an if statement to check the opacity of one of the ice cubes.)
    ### Fix Your Code Here ###
    iceCube1.opacity -= 10
    iceCube2.opacity -= 10
    iceCube3.opacity -= 10
    juice.height += 2
    juice.top -= 2
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('turquoise', 'paleTurquoise'))

# sun
Star(0, 0, 120, 60, fill='yellow', roundness=40)
Circle(0, 0, 90, fill=gradient('yellow', 'khaki'))

# glass of cranberry juice
Rect(160, 150, 180, 250, fill='azure')
juice = Rect(170, 200, 160, 190, fill=gradient('tomato', 'coral', start='bottom'))

# ice cubes
iceCube1 = Rect(180, 220, 40, 40, fill=rgb(229, 229, 229))
iceCube2 = Rect(240, 250, 30, 30, fill=rgb(229, 229, 229))
iceCube3 = Rect(200, 300, 35, 35, fill=rgb(229, 229, 229))

# straw
Rect(290, 110, 10, 270,
     fill=gradient('tomato', 'tomato', 'tomato', 'red', start='bottom'))
Rect(290, 100, 70, 10, fill='red')


def onMousePress(mouseX, mouseY):
    # An error occurs if you click too many times. Use the error message in
    # the console to figure out what is wrong and fix it!
    if(iceCube1.opacity > 0):
        iceCube1.opacity -= 10
        iceCube2.opacity -= 10
        iceCube3.opacity -= 10
        juice.height += 2
        juice.top -= 2
",regular,1
2024,Puffy Penguin,3.2.2,"app.background = gradient('white', 'aliceBlue')

# feet
Oval(125, 305, 20, 50, fill='orange', rotateAngle=50)
Oval(135, 310, 20, 50, fill='orange', rotateAngle=20)
Oval(145, 310, 20, 50, fill='orange', rotateAngle=-10)
Oval(275, 305, 20, 50, fill='orange', rotateAngle=-50)
Oval(265, 310, 20, 50, fill='orange', rotateAngle=-20)
Oval(255, 310, 20, 50, fill='orange', rotateAngle=10)

# wings
Oval(110, 150, 65, 120, rotateAngle=-40)
Oval(110, 160, 35, 110, fill='white', rotateAngle=-40)
Oval(290, 150, 65, 120, rotateAngle=40)
Oval(290, 160, 35, 110, fill='white', rotateAngle=40)

# belly
Oval(200, 150, 150, 230)
belly = Circle(200, 230, 70, fill='white', border='black', borderWidth=15)

# body
Oval(175, 160, 65, 180, fill='white')
Oval(225, 160, 65, 180, fill='white')
Circle(175, 110, 10)
Circle(225, 110, 10)
Polygon(185, 130, 215, 130, 205, 150, fill='orange')

# words
hungryLabel = Label(""I'm full!"", 320, 50, size=35, visible=False)

def onMousePress(mouseX, mouseY):
    # Increase the size of belly to make the penguin puffy.
    ### (HINT: If the belly has a radius of over 100, show hungryLabel.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('white', 'aliceBlue')

# feet
Oval(125, 305, 20, 50, fill='orange', rotateAngle=50)
Oval(135, 310, 20, 50, fill='orange', rotateAngle=20)
Oval(145, 310, 20, 50, fill='orange', rotateAngle=-10)
Oval(275, 305, 20, 50, fill='orange', rotateAngle=-50)
Oval(265, 310, 20, 50, fill='orange', rotateAngle=-20)
Oval(255, 310, 20, 50, fill='orange', rotateAngle=10)

# body
Oval(110, 150, 65, 120, rotateAngle=-40)
Oval(110, 160, 35, 110, fill='white', rotateAngle=-40)
Oval(290, 150, 65, 120, rotateAngle=40)
Oval(290, 160, 35, 110, fill='white', rotateAngle=40)
Oval(200, 150, 150, 230)

# belly
belly = Circle(200, 230, 70, fill='white', border='black', borderWidth=15)

# wings
Oval(175, 160, 65, 180, fill='white')
Oval(225, 160, 65, 180, fill='white')
Circle(175, 110, 10)
Circle(225, 110, 10)
Polygon(185, 130, 215, 130, 205, 150, fill='orange')

# words
hungryLabel = Label(""I'm full!"", 320, 50, size=35, visible=False)

def onMousePress(mouseX, mouseY):
    # Increase the size of belly to make the penguin puffy.
    belly.radius += 3

    if (belly.radius > 100):
        hungryLabel.visible = True
",regular,1
2027,Using if-else Checkpoint 4,3.2.3.1,"app.background = 'midnightBlue'

Label('Ball wrap around', 200, 20, fill='white', size=20, bold=True)
Label('Move the mouse to move the ball right by 10', 200, 45, fill='white')
Label('When the ball gets to the edge, it wraps around!', 200, 65, fill='white')

ball = Circle(20, 200, 20, fill='yellow')

def onMouseMove(mouseX, mouseY):
    # As long as the ball's center is left of the right edge of the canvas,
    # keep moving right by 10. Otherwise restart at the left edge.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'midnightBlue'

Label('Ball wrap around', 200, 20, fill='white', size=20, bold=True)
Label('Move the mouse to move the ball right by 10', 200, 45, fill='white')
Label('When the ball gets to the edge, it wraps around!', 200, 65, fill='white')

ball = Circle(20, 200, 20, fill='yellow')

def onMouseMove(mouseX, mouseY):
    # As long as the ball's center is left of the right edge of the canvas,
    # keep moving right by 10. Otherwise restart at the left edge.
    if (ball.centerX < 400):
        ball.centerX += 10
    else:
        ball.centerX = 0
",regular,1
2028,Flashlight,3.2.4,"# background
Rect(0, 0, 400, 400)

def turnOnFlashlight(intensity):
    # Check how large intensity is.
    # Draw triangles of different colors to represent light.
    ### Place Your Code Here ###

    # flashlight
    Rect(195, 230, 10, 60, fill=rgb(68, 68, 68))
    RegularPolygon(200, 225, 15, 3, fill=rgb(68, 68, 68), rotateAngle=180)
    Oval(200, 218, 24, 5, fill='white')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400)

def turnOnFlashlight(intensity):
    # Check how large intensity is.
    # Draw triangles of different colors to represent light.
    if (intensity > 0):
        Polygon(20, 0, 380, 0, 200, 230, fill=rgb(170, 170, 170))
    if (intensity >= 30):
        Polygon(50, 0, 350, 0, 200, 230, fill=rgb(220, 220, 220))
    if (intensity >= 60):
        Polygon(80, 0, 320, 0, 200, 230, fill=rgb(240, 240, 240))
    if (intensity >= 90):
        Polygon(120, 0, 280, 0, 200, 230, fill='white')

    # flashlight
    Rect(195, 230, 10, 60, fill=rgb(68, 68, 68))
    RegularPolygon(200, 225, 15, 3, fill=rgb(68, 68, 68), rotateAngle=180)
    Oval(200, 218, 24, 5, fill='white')
",regular,3
2029,Firework,3.2.4,"# background
Rect(0, 0, 400, 400)

def onMousePress(mouseX, mouseY):
    # Check if the firework is high enough up to explode.
    ### Fix Your Code Here ###
    Star(mouseX, mouseY, 100, 12, fill=gradient('red', 'white'), roundness=10)

    Star(mouseX, mouseY, 100, 12, fill=gradient('yellow', 'white'),
         roundness=10, rotateAngle=10)

    Star(mouseX, mouseY, 100, 12, roundness=10, rotateAngle=5)

    # If the firework is not high enough, draw a rising pre-firework line.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400)

def onMousePress(mouseX, mouseY):
    # Check if the firework is high enough up to explode.
    if (mouseY < 150):
        Star(mouseX, mouseY, 100, 12, fill=gradient('red', 'white'), roundness=10)

        Star(mouseX, mouseY, 100, 12, fill=gradient('yellow', 'white'),
             roundness=10, rotateAngle=10)

        Star(mouseX, mouseY, 100, 12, roundness=10, rotateAngle=5)
    # If the firework is not high enough, draw a rising pre-firework line.
    else:
        Line(mouseX, mouseY, mouseX, 400,
             fill=gradient('black', 'red', 'yellow', 'black', start='top'))
",regular,1
2030,Scoreboard,3.2.4,"app.background = 'cornflowerBlue'

# time section
Rect(50, 0, 300, 100)
Rect(35, 0, 330, 115, fill=None, border='white', borderWidth=5)
Rect(165, 150, 70, 30, fill='cornflowerBlue')
Label('TIME', 200, 130, fill='white', size=20)
Label('00:00', 200, 50, fill='goldenrod', size=80, font='monospace', bold=True)

# home section
Label('HOME', 100, 160, fill='white', size=60, font='monospace', bold=True)
Rect(25, 190, 150, 100)
homeScoreLabel = Label(0, 100, 240, fill='red', size=100, font='monospace',
                       bold=True)

# away section
Label('AWAY', 300, 160, fill='white', size=60, font='monospace', bold=True)
Rect(225, 190, 150, 100)
awayScoreLabel = Label(0, 300, 240, fill='red', size=100, font='monospace',
                       bold=True)

# wins
Label('WINS', 100, 320, fill='white', size=40, font='monospace', bold=True)
Rect(25, 340, 150, 40)
winsLabel = Label(0, 100, 360, fill='red', size=50, font='monospace', bold=True)

# losses
Label('LOSSES', 300, 320, fill='white', size=40, font='monospace', bold=True)
Rect(225, 340, 150, 40)
lossesLabel = Label(0, 300, 360, fill='red', size=50, font='monospace', bold=True)

def finalScoreboard(homeScore, awayScore):
    # Display the final scores.
    ### (HINT: You'll need to use the homeScoreLabel, and awayScoreLabel variables
    #          defined above.)
    ### Place Your Code Here ###

    # Update the number of wins and losses (ties wont be tested by the autograder),
    # and change the color of the winning score to green.
    ### (HINT: Don't forget to change the loser's score back to red.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'cornflowerBlue'

# time section
Rect(50, 0, 300, 100)
Rect(35, 0, 330, 115, fill=None, border='white', borderWidth=5)
Rect(165, 150, 70, 30, fill='cornflowerBlue')
Label('TIME', 200, 130, fill='white', size=20)
Label('00:00', 200, 50, fill='goldenrod', size=80, font='monospace', bold=True)

# home section
Label('HOME', 100, 160, fill='white', size=60, font='monospace', bold=True)
Rect(25, 190, 150, 100)
homeScoreLabel = Label(0, 100, 240, fill='red', size=100, font='monospace',
                       bold=True)

# away section
Label('AWAY', 300, 160, fill='white', size=60, font='monospace', bold=True)
Rect(225, 190, 150, 100)
awayScoreLabel = Label(0, 300, 240, fill='red', size=100, font='monospace',
                       bold=True)

# wins
Label('WINS', 100, 320, fill='white', size=40, font='monospace', bold=True)
Rect(25, 340, 150, 40)
winsLabel = Label(0, 100, 360, fill='red', size=50, font='monospace', bold=True)

# losses
Label('LOSSES', 300, 320, fill='white', size=40, font='monospace', bold=True)
Rect(225, 340, 150, 40)
lossesLabel = Label(0, 300, 360, fill='red', size=50, font='monospace', bold=True)

def finalScoreboard(homeScore, awayScore):
    # Display the final scores.
    homeScoreLabel.value = homeScore
    awayScoreLabel.value = awayScore

    # Update the number of wins and losses (ties wont be tested by the autograder),
    # and change the color of the winning score to green.
    if (homeScore > awayScore):
        winsLabel.value += 1
        homeScoreLabel.fill = 'green'
        awayScoreLabel.fill = 'red'
    else:
        lossesLabel.value += 1
        awayScoreLabel.fill = 'green'
        homeScoreLabel.fill = 'red'
",regular,1
2031,Galaxy,3.2.4,"app.background = gradient('midnightBlue', 'navy', 'black', start='bottom')

# background stars
Star(20, 50, 5, 8, fill='gold', roundness=40)
Star(280, 30, 5, 5, fill='gold')
Star(170, 300, 5, 8, fill='white', roundness=40)
Star(340, 150, 5, 5, fill='gold')
Star(50, 350, 5, 8, fill='white', roundness=40)
Star(250, 220, 5, 5, fill='white')
Star(380, 380, 5, 5, fill='white')
Star(75, 100, 5, 8, fill='gold', roundness=40)
Star(80, 210, 5, 8, fill='white', roundness=40)
Star(175, 80, 5, 8, fill='gold', roundness=40)

star = Star(20, 20, 10, 8, fill=gradient('gold', 'navy'), roundness=40, opacity=70)

def onMousePress(mouseX, mouseY):
    # Draws a copy of the star at the mouse position.
    Star(mouseX, mouseY, 10, star.points, fill=star.fill, roundness=40)

def onMouseMove(mouseX, mouseY):
    # Moves the star according to the mouse position.
    star.centerX = mouseX
    star.centerY = mouseY

    # If the mouse is in the top half of the canvas, the fill should be a
    # gradient starting at gold. Otherwise the gradient should start at white.
    ### Place Your Code Here ###

    # If the mouse is on the left half of the canvas, the star should have
    # 8 points. Otherwise there should be 5 points.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('midnightBlue', 'navy', 'black', start='bottom')

# background stars
Star(20, 50, 5, 8, fill='gold', roundness=40)
Star(280, 30, 5, 5, fill='gold')
Star(170, 300, 5, 8, fill='white', roundness=40)
Star(340, 150, 5, 5, fill='gold')
Star(50, 350, 5, 8, fill='white', roundness=40)
Star(250, 220, 5, 5, fill='white')
Star(380, 380, 5, 5, fill='white')
Star(75, 100, 5, 8, fill='gold', roundness=40)
Star(80, 210, 5, 8, fill='white', roundness=40)
Star(175, 80, 5, 8, fill='gold', roundness=40)

star = Star(20, 20, 10, 8, fill=gradient('gold', 'navy'), roundness=40, opacity=70)

def onMousePress(mouseX, mouseY):
    # Draws a copy of the star at the mouse position.
    Star(mouseX, mouseY, 10, star.points, fill=star.fill, roundness=40)

def onMouseMove(mouseX, mouseY):
    # Moves the star according to the mouse position.
    star.centerX = mouseX
    star.centerY = mouseY

    # If the mouse is in the top half of the canvas, the fill should be a
    # gradient starting at gold. Otherwise the gradient should start at white.
    if (mouseY < 200):
        star.fill = gradient('gold', 'navy')
    else:
        star.fill = gradient('white', 'navy')

    # If the mouse is on the left half of the canvas, the star should have
    # 8 points. Otherwise there should be 5 points.
    if (mouseX < 200):
        star.points = 8
    else:
        star.points = 5
",regular,1
2032,Seesaw,3.2.4,"app.background = 'lightCyan'

# seesaw support
Oval(200, 330, 300, 50, fill='moccasin'),
RegularPolygon(200, 290, 70, 3, fill=None, border='tomato', borderWidth=7)
Circle(200, 235, 15, fill='skyBlue')

# seesaw body
seesaw = Line(50, 235, 350, 235, fill='tomato', lineWidth=12)

# message
message = Label('Balanced', 200, 100, fill='salmon', size=20)

def onMouseMove(mouseX, mouseY):
    # If the mouse is on the right side of the canvas, increase the seesaw's
    # rotateAngle by 1. Otherwise decrease it.
    ### Place Your Code Here ###

    # Change the message depending on if rotateAngle is negative, positive,
    # or zero.
    ### (HINT: A negative value is a number that is less than 0, a positive
    #          value is a number that is bigger than 0.)
    ### Place Your Code Here ###

    # If the rotateAngle is bigger than 45 or smaller than -45, reset its value
    # to 45 or -45.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightCyan'

# seesaw support
Oval(200, 330, 300, 50, fill='moccasin'),
RegularPolygon(200, 290, 70, 3, fill=None, border='tomato', borderWidth=7)
Circle(200, 235, 15, fill='skyBlue')

# seesaw body
seesaw = Line(50, 235, 350, 235, fill='tomato', lineWidth=12)

# message
message = Label('Balanced', 200, 100, fill='salmon', size=20)

def onMouseMove(mouseX, mouseY):
    # If the mouse is on the right side of the canvas, increase the seesaw's
    # rotateAngle by 1. Otherwise decrease it.
    if (mouseX > 200):
        seesaw.rotateAngle += 1
    else:
        seesaw.rotateAngle -= 1

    # Change the message depending on if rotateAngle is negative, positive,
    # or zero.
    if (seesaw.rotateAngle < 0):
        message.value = 'Leaning Left'
    if (seesaw.rotateAngle > 0):
        message.value = 'Leaning Right'
    if (seesaw.rotateAngle == 0):
        message.value = 'Balanced'

    # If the rotateAngle is bigger than 45 or smaller than -45, reset its value
    # to 45 or -45.
    if (seesaw.rotateAngle > 45):
        seesaw.rotateAngle = 45
    if (seesaw.rotateAngle < -45):
        seesaw.rotateAngle = -45
",regular,2
2033,Chick,3.3.2,"speechBubble = Polygon(280, 110, 310, 95, 390, 95, 390, 45, 290, 45, 290, 95,
                       fill=None, border='black', visible=False)
speechText = Label('...', 340, 70, size=25, visible=False)

def drawEggBottom():
    Circle(200, 260, 100, fill='lightBlue')
    Rect(200, 260, 200, 120, fill='white', align='bottom')

def drawCrack():
    Polygon(100, 260, 120, 220, 150, 255, 175, 215, 200, 260, 220, 230,
            250, 260, 275, 210, 300, 260, fill='lightBlue', border='grey',
            borderWidth=1)
    Line(100, 260, 300, 260, fill='lightBlue')

def drawEggTop():
    Oval(200, 230, 205, 260, fill='lightBlue')

def drawBabyChicken():
    # beak
    Polygon(245, 115, 250, 145, 270, 130, fill='orange')

    # body
    Oval(200, 235, 140, 150, fill=rgb(255, 205, 0))
    Oval(200, 135, 105, 100, fill=rgb(255, 205, 0))

    # cover the bottom half of the body
    Rect(135, 260, 130, 75, fill='lightBlue')

    # eye
    Oval(235, 115, 20, 20)
    Circle(240, 110, 5, fill='aliceBlue')

def onMousePress(mouseX, mouseY):
    # Show the speechBubble with appropriate text.
    speechText.visible = True
    speechBubble.visible = True

def onMouseRelease(mouseX, mouseY):
    # Hide the speechBubble.
    speechText.visible = False
    speechBubble.visible = False

def hatchedOrNot(hasHatched):
    # Draw a different image and text based on whether it has hatched or not.
    ### (HINT: Remember that hasHatched is the argument that the test case
    #          provides when it calls the hatchedOrNot function.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

speechBubble = Polygon(280, 110, 310, 95, 390, 95, 390, 45, 290, 45, 290, 95,
                       fill=None, border='black', visible=False)
speechText = Label('...', 340, 70, size=25, visible=False)

def drawEggBottom():
    Circle(200, 260, 100, fill='lightBlue')
    Rect(200, 260, 200, 120, fill='white', align='bottom')

def drawCrack():
    Polygon(100, 260, 120, 220, 150, 255, 175, 215, 200, 260, 220, 230,
            250, 260, 275, 210, 300, 260, fill='lightBlue', border='grey',
            borderWidth=1)
    Line(100, 260, 300, 260, fill='lightBlue')

def drawEggTop():
    Oval(200, 230, 205, 260, fill='lightBlue')

def drawBabyChicken():
    # beak
    Polygon(245, 115, 250, 145, 270, 130, fill='orange')

    # body
    Oval(200, 235, 140, 150, fill=rgb(255, 205, 0))
    Oval(200, 135, 105, 100, fill=rgb(255, 205, 0))

    # cover the bottom half of the body
    Rect(135, 260, 130, 75, fill='lightBlue')

    # eye
    Oval(235, 115, 20, 20)
    Circle(240, 110, 5, fill='aliceBlue')

def onMousePress(mouseX, mouseY):
    # Show the speechBubble with appropriate text.
    speechText.visible = True
    speechBubble.visible = True

def onMouseRelease(mouseX, mouseY):
    # Hide the speechBubble.
    speechText.visible = False
    speechBubble.visible = False

def hatchedOrNot(hasHatched):
    # Draw image and text based on whether it has hatched or not.
    if (hasHatched == True):
        drawEggBottom()
        drawBabyChicken()
        drawCrack()
        speechText.value = 'Peep!'
    else:
        drawEggBottom()
        drawEggTop()
        drawCrack()
        speechText.value = '...'
",regular,2
2037,Flower collection,3.3.2,"app.background = 'aliceBlue'

# vase
Oval(200, 300, 50, 10, fill='limeGreen')
Rect(175, 300, 50, 100, fill='silver')
Oval(200, 370, 100, 135,
     fill=gradient('gray', 'silver', 'silver', start='left-bottom'))

def drawLeaf(mouseX, mouseY):
    Star(mouseX, mouseY, 30, 4, fill='green', rotateAngle=45)

def drawFlower(mouseX, mouseY):
    Line(mouseX, mouseY, 200, 300, fill='limeGreen', lineWidth=4)
    Star(mouseX, mouseY, 25, 6, fill=gradient('lavender', 'plum', 'plum'))
    Circle(mouseX, mouseY, 9, fill='lemonChiffon')

def onMousePress(mouseX, mouseY):
    # Draw leaves for flowers in the bottom half of the canvas.
    ### Place Your Code Here ###

    drawFlower(mouseX, mouseY)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'aliceBlue'

# vase
Oval(200, 300, 50, 10, fill='limeGreen')
Rect(175, 300, 50, 100, fill='silver')
Oval(200, 370, 100, 135,
     fill=gradient('gray', 'silver', 'silver', start='left-bottom'))

def drawLeaf(mouseX, mouseY):
    Star(mouseX, mouseY, 30, 4, fill='green', rotateAngle=45)

def drawFlower(mouseX, mouseY):
    Line(mouseX, mouseY, 200, 300, fill='limeGreen', lineWidth=4)
    Star(mouseX, mouseY, 25, 6, fill=gradient('lavender', 'plum', 'plum'))
    Circle(mouseX, mouseY, 9, fill='lemonChiffon')

def onMousePress(mouseX, mouseY):
    if (mouseY > 200):
        drawLeaf(mouseX, mouseY)

    drawFlower(mouseX, mouseY)
",regular,1
2036,Footsteps,3.3.2,"# background
Rect(190, 0, 10, 400)
Rect(200, 0, 10, 400, fill='tan')

def drawFootstep(x, y, color):
    Oval(x, y - 5, 22, 40, fill=color)
    Circle(x, y + 20, 8, fill=color)
    Rect(x, y + 13, 16, 3, fill='white', align='center')

def onMousePress(mouseX, mouseY):
    # Draw a black footstep if the click is on left half, tan footstep otherwise.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(190, 0, 10, 400)
Rect(200, 0, 10, 400, fill='tan')

def drawFootstep(x, y, color):
    Oval(x, y - 5, 22, 40, fill=color)
    Circle(x, y + 20, 8, fill=color)
    Rect(x, y + 13, 16, 3, fill='white', align='center')

def onMousePress(mouseX, mouseY):
    # Draw a black footstep if the click is on left half, tan footstep otherwise.
    if (mouseX < 200):
        drawFootstep(mouseX, mouseY, 'black')
    else:
        drawFootstep(mouseX, mouseY, 'tan')
",regular,1
2034,Pacman ghosts,3.3.2,"# background
Rect(0, 0, 400, 400, fill='midnightBlue')

# Parameters give the center of the white part of the eye.
def drawEye(eyeCenterX, eyeCenterY):
    Circle(eyeCenterX, eyeCenterY, 20, fill='white')
    Circle(eyeCenterX, eyeCenterY, 10, fill='cornflowerBlue', align='right')

# x is the centerX of the body, y is the centerY of all feet.
def drawFeet(x, y, color):
    Circle(x - 40, y, 20, fill=color)
    Circle(x + 40, y, 20, fill=color)
    Circle(x, y, 20, fill=color)

# centerX and centerY are the center of the body of the ghost.
def drawGhost(centerX, centerY, name, color):
    # body
    Rect(centerX, centerY, 120, 80, fill=color, align='center')

    # head
    Circle(centerX, centerY - 40, 60, fill=color)

    # Draw the eyes.
    ### Place Your Code Here ###

    # Draw the feet.
    ### Place Your Code Here ###

    # Create a label with the name of the ghost.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill='midnightBlue')

# Parameters give the center of the white part of the eye.
def drawEye(eyeCenterX, eyeCenterY):
    Circle(eyeCenterX, eyeCenterY, 20, fill='white')
    Circle(eyeCenterX, eyeCenterY, 10, fill='cornflowerBlue', align='right')

# x is the centerX of the body, y is the centerY of all feet.
def drawFeet(x, y, color):
    Circle(x - 40, y, 20, fill=color)
    Circle(x + 40, y, 20, fill=color)
    Circle(x, y, 20, fill=color)

# centerX and centerY are the center of the body of the ghost.
def drawGhost(centerX, centerY, name, color):
    # body
    Rect(centerX, centerY, 120, 80, fill=color, align='center')

    # head
    Circle(centerX, centerY - 40, 60, fill=color)

    # Draw the eyes.
    drawEye(centerX - 25, centerY - 55)
    drawEye(centerX + 20, centerY - 55)

    # Draw the feet.
    drawFeet(centerX, centerY + 40, color)

    # Create a label with the name of the ghost.
    Label(name, centerX, centerY + 70, fill='white', size=25, font='monospace')
",regular,3
2035,Skyline reflection,3.3.2,"app.background = 'black'
Rect(0, 0, 400, 250, fill=gradient(rgb(15, 25, 40), rgb(20, 40, 80), start='top'))

Circle(130, 90, 60, fill=gradient('lemonChiffon', rgb(245, 240, 170)))
Circle(200, 400, 60, fill=gradient('lemonChiffon', rgb(245, 240, 170)), opacity=20)

def drawReflection(buildingTopX):
    Polygon(buildingTopX - 30, 250, buildingTopX + 30, 250,
            buildingTopX + 100, 400, buildingTopX + 40, 400, opacity=60,
            fill=gradient(rgb(115, 105, 80), rgb(50, 40, 35), 'black', start='top'))

def drawBuilding(buildingTopX, buildingTopY):
    Rect(buildingTopX, buildingTopY, 60, 250 - buildingTopY,
         fill=gradient(rgb(50, 50, 55), rgb(90, 90, 125), start='left-top'),
         align='top')

def onMousePress(mouseX, mouseY):
    # When mouse is above the skyline, draw a building and a reflection from
    # where you click.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
Rect(0, 0, 400, 250, fill=gradient(rgb(15, 25, 40), rgb(20, 40, 80), start='top'))

Circle(130, 90, 60, fill=gradient('lemonChiffon', rgb(245, 240, 170)))
Circle(200, 400, 60, fill=gradient('lemonChiffon', rgb(245, 240, 170)), opacity=20)

def drawReflection(buildingTopX):
    Polygon(buildingTopX - 30, 250, buildingTopX + 30, 250,
            buildingTopX + 100, 400, buildingTopX + 40, 400, opacity=60,
            fill=gradient(rgb(115, 105, 80), rgb(50, 40, 35), 'black', start='top'))

def drawBuilding(buildingTopX, buildingTopY):
    Rect(buildingTopX, buildingTopY, 60, 250 - buildingTopY,
         fill=gradient(rgb(50, 50, 55), rgb(90, 90, 125), start='left-top'),
         align='top')

def onMousePress(mouseX, mouseY):
    # When mouse is above the skyline, draw a building and a reflection from
    # where you click.
    if (mouseY < 250):
        drawBuilding(mouseX, mouseY)
        drawReflection(mouseX)
",regular,1
2046,Hedgehog,3.4,"app.background = 'cornflowerBlue'

spikes = Star(200, 335, 130, 30, fill='saddleBrown', roundness=80)

# body
Circle(140, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Circle(260, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Oval(200, 310, 160, 110, fill='tan', align='top')

# eyes
Circle(175, 360, 7)
Circle(225, 360, 7)

# nose
RegularPolygon(200, 390, 15, 3, rotateAngle=180)

leftEyebrow = Line(155, 345, 170, 345, rotateAngle=-15)
rightEyebrow = Line(245, 345, 230, 345, rotateAngle=15)

def drawAnimal(animal):
    # Change the number of spikes if it is a hedgehog and the fill if it is not.
    ### Place Your Code Here ###
    pass

def onMousePress(mouseX, mouseY):
    # Puff the spikes if it is a porcupine.
    # Change the eyebrows to make it disturbed.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # Change the puff and eyebrows back to the original state.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'cornflowerBlue'

spikes = Star(200, 335, 130, 30, fill='saddleBrown', roundness=80)

# body
Circle(140, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Circle(260, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Oval(200, 310, 160, 110, fill='tan', align='top')

# eyes
Circle(175, 360, 7)
Circle(225, 360, 7)

# nose
RegularPolygon(200, 390, 15, 3, rotateAngle=180)

leftEyebrow = Line(155, 345, 170, 345, rotateAngle=-15)
rightEyebrow = Line(245, 345, 230, 345, rotateAngle=15)

def drawAnimal(animal):
    # Change the number of spikes if it is a hedgehog and the fill if it is not.
    if (animal == 'hedgehog'):
        spikes.points = 60
    else:
        spikes.fill = gradient('saddleBrown', 'saddleBrown', 'saddleBrown', 'tan')

def onMousePress(mouseX, mouseY):
    # Puff the spikes if it is a porcupine.
    # Change the eyebrows to make it disturbed.
    if (spikes.points != 60):
        spikes.radius = 250
        spikes.roundness = 40

    leftEyebrow.rotateAngle = 30
    rightEyebrow.rotateAngle = -30

def onMouseRelease(mouseX, mouseY):
    # Change the puff and eyebrows back to the original state.
    if (spikes.points != 60):
        spikes.radius = 130
        spikes.roundness = 80

    leftEyebrow.rotateAngle = -15
    rightEyebrow.rotateAngle = 15
",regular,2
2044,Owl eyes,3.4,"app.background = 'slateGray'

# branch
Polygon(0, 380, 400, 360, 300, 380, 0, 400)

# body
Oval(200, 260, 280, 220, fill='tan')
Oval(200, 300, 200, 140, fill='wheat')

# wings
Oval(80, 265, 60, 130, fill='sienna', rotateAngle=10)
Oval(330, 265, 60, 130, fill='sienna', rotateAngle=-10)

# ear
Polygon(275, 60, 320, 20, 340, 110, fill='saddleBrown')
Polygon(125, 60, 80, 20, 60, 110, fill='saddleBrown')

# face
Oval(200, 150, 300, 220, fill='saddleBrown')
Circle(130, 150, 80, fill='tan')
Circle(270, 150, 80, fill='tan')
Oval(140, 140, 100, 120, fill='white')
Oval(260, 140, 100, 120, fill='white')

# feet
Polygon(135, 350, 145, 350, 155, 380, 145, 370, 140, 380, 135, 370, 125, 380,
        fill='sandyBrown')
Polygon(265, 350, 255, 350, 245, 380, 255, 370, 260, 380, 265, 370, 275, 380,
        fill='sandyBrown')

# nose
nose = Polygon(215, 170, 200, 210, 185, 170, fill='orange')

# eyes
Circle(150, 130, 35)
Circle(250, 130, 35)

leftEye = Circle(150, 130, 10, fill='white')
rightEye = Circle(250, 130, 10, fill='white')

def onMouseMove(mouseX, mouseY):
    # Move the centerX of the eyes to follow the mouse, but scale the movement
    # so that the iris stays in the eye!
    ### Fix Your Code Here ###
    ### (HINT: When mouseX is 0, the left eye's centerX should be 130.)
    ### (HINT: As mouseX increases, add mouseX / 10 to the left eye's
    #          centerX value.)
    leftEye.centerX = 150
    rightEye.centerX = 250

    # Treat mouseY and centerY in a similar way to mouseX and centerX.
    # Treat the right eye in a similar way to the left eye.
    ### Fix Your Code Here ###
    rightEye.centerY = 130
    leftEye.centerY = 130
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'slateGray'

# branch
Polygon(0, 380, 400, 360, 300, 380, 0, 400)

# body
Oval(200, 260, 280, 220, fill='tan')
Oval(200, 300, 200, 140, fill='wheat')

# wings
Oval(80, 265, 60, 130, fill='sienna', rotateAngle=10)
Oval(330, 265, 60, 130, fill='sienna', rotateAngle=-10)

# ear
Polygon(275, 60, 320, 20, 340, 110, fill='saddleBrown')
Polygon(125, 60, 80, 20, 60, 110, fill='saddleBrown')

# face
Oval(200, 150, 300, 220, fill='saddleBrown')
Circle(130, 150, 80, fill='tan')
Circle(270, 150, 80, fill='tan')
Oval(140, 140, 100, 120, fill='white')
Oval(260, 140, 100, 120, fill='white')

# feet
Polygon(135, 350, 145, 350, 155, 380, 145, 370, 140, 380, 135, 370, 125, 380,
        fill='sandyBrown')
Polygon(265, 350, 255, 350, 245, 380, 255, 370, 260, 380, 265, 370, 275, 380,
        fill='sandyBrown')

# nose
nose = Polygon(215, 170, 200, 210, 185, 170, fill='orange')

# eyes
Circle(150, 130, 35)
Circle(250, 130, 35)

leftEye = Circle(150, 130, 10, fill='white')
rightEye = Circle(250, 130, 10, fill='white')

def onMouseMove(mouseX, mouseY):
    # Move the centerX of the eyes to follow the mouse, but scale the movement
    # so that the iris stays in the eye!
    ### Fix Your Code Here ###
    leftEye.centerX = 130 + (mouseX / 10)
    leftEye.centerY = 110 + (mouseY / 10)

    rightEye.centerX = 230 + (mouseX / 10)
    rightEye.centerY = 110 + (mouseY / 10)
",regular,3
2038,Cursor duplication,3.4,"# background
Rect(100, 300, 600, 600, fill=gradient('aqua', 'royalBlue', 'midnightBlue'),
     align='center')

cursor = Polygon(200, 190, 200, 209, 204, 205, 207, 211, 211, 209, 208, 203,
                 213, 203, border='white', borderWidth=1)

def onMouseMove(mouseX, mouseY):
    # Change the location of the cursor based on your mouse location.
    ### (HINT: The mouseX and mouseY values are given by the left-top
    #          of your own mouse. The cursor should follow your mouse but
    #          be reflected vertically.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(100, 300, 600, 600, fill=gradient('aqua', 'royalBlue', 'midnightBlue'),
     align='center')

cursor = Polygon(200, 190, 200, 209, 204, 205, 207, 211, 211, 209, 208, 203,
                 213, 203, border='white', borderWidth=1)

def onMouseMove(mouseX, mouseY):
    # Change the location of the cursor based on your mouse location.
    cursor.left = mouseX
    cursor.top = 400 - mouseY
",regular,1
2039,Flowers and clouds,3.4,"app.background = gradient('deepSkyBlue', 'lightCyan', start='top')

# ground
Rect(0, 255, 400, 145, fill='oliveDrab')
Oval(200, 255, 400, 20, fill='oliveDrab')

def drawCloud(x, y, color):
    # Draws a cloud with the given color and center at (x, y).
    Oval(x, y, 100, 45, fill=color)
    Circle(x + 40, y - 10, 20, fill=color)
    Circle(x + 10, y - 20, 30, fill=color)
    Circle(x - 15, y - 20, 30, fill=color)
    Circle(x - 30, y, 20, fill=color)

def drawFlower(x, y):
    # Draws a flower centered at (x, y-10) when it is called.
    Oval(x, y - 10, 10, 20, fill='deepPink')
    Oval(x, y - 10, 10, 20, fill='hotPink', rotateAngle=60)
    Oval(x, y - 10, 10, 20, fill='deepPink', rotateAngle=120)
    Circle(x, y - 10, 2, fill='yellow')

def onMousePress(mouseX, mouseY):
    # When the mouseY is less than 255, draw a cloud with an rgb value that
    # depends on mouseY. When the mouseY is at least 255, draw a flower.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'lightCyan', start='top')

# ground
Rect(0, 255, 400, 145, fill='oliveDrab')
Oval(200, 255, 400, 20, fill='oliveDrab')

def drawCloud(x, y, color):
    # Draws a cloud with the given color and center at (x, y).
    Oval(x, y, 100, 45, fill=color)
    Circle(x + 40, y - 10, 20, fill=color)
    Circle(x + 10, y - 20, 30, fill=color)
    Circle(x - 15, y - 20, 30, fill=color)
    Circle(x - 30, y, 20, fill=color)

def drawFlower(x, y):
    # Draws a flower centered at (x, y-10) when it is called.
    Oval(x, y - 10, 10, 20, fill='deepPink')
    Oval(x, y - 10, 10, 20, fill='hotPink', rotateAngle=60)
    Oval(x, y - 10, 10, 20, fill='deepPink', rotateAngle=120)
    Circle(x, y - 10, 2, fill='yellow')

def onMousePress(mouseX, mouseY):
    # When the mouseY is less than 255, draw a cloud with an rgb value that
    # depends on mouseY. When the mouseY is at least 255, draw a flower.
    if (mouseY < 255):
        drawCloud(mouseX, mouseY, rgb(mouseY, mouseY, mouseY))

    if (mouseY >= 255):
        drawFlower(mouseX, mouseY)
",regular,1
2040,Jack-o-Lantern,3.4,"background = Rect(0, 0, 400, 400)
Oval(200, 270, 250, 80, fill='saddleBrown', opacity=30)

# pumpkin
Line(200, 120, 215, 90, fill='green', lineWidth=10)
Oval(120, 200, 100, 150, fill='orange', border='darkOrange', borderWidth=4)
Oval(280, 200, 100, 150, fill='orange', border='darkOrange', borderWidth=4)
Oval(150, 200, 120, 160, fill='orange', border='darkOrange', borderWidth=4)
Oval(250, 200, 120, 160, fill='orange', border='darkOrange', borderWidth=4)
Oval(200, 200, 130, 170, fill='orange', border='darkOrange', borderWidth=4)

leftEye = RegularPolygon(145, 170, 30, 3, fill='yellow', border='darkOrange')
rightEye = RegularPolygon(255, 170, 30, 3, fill='yellow', border='darkOrange')
mouth = Oval(200, 230, 120, 40, fill='yellow', border='darkOrange')
Oval(200, 220, 120, 30, fill='orange')

def onMouseDrag(mouseX, mouseY):
    # If the mouse is on the left side of the canvas, change the fills
    # to make a day scene. Otherwise change the fills for a night scene.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

background = Rect(0, 0, 400, 400)
Oval(200, 270, 250, 80, fill='saddleBrown', opacity=30)

# pumpkin
Line(200, 120, 215, 90, fill='green', lineWidth=10)
Oval(120, 200, 100, 150, fill='orange', border='darkOrange', borderWidth=4)
Oval(280, 200, 100, 150, fill='orange', border='darkOrange', borderWidth=4)
Oval(150, 200, 120, 160, fill='orange', border='darkOrange', borderWidth=4)
Oval(250, 200, 120, 160, fill='orange', border='darkOrange', borderWidth=4)
Oval(200, 200, 130, 170, fill='orange', border='darkOrange', borderWidth=4)

leftEye = RegularPolygon(145, 170, 30, 3, fill='yellow', border='darkOrange')
rightEye = RegularPolygon(255, 170, 30, 3, fill='yellow', border='darkOrange')
mouth = Oval(200, 230, 120, 40, fill='yellow', border='darkOrange')
Oval(200, 220, 120, 30, fill='orange')

def onMouseDrag(mouseX, mouseY):
    # If the mouse is on the left side of the canvas, change the fills
    # to make a day scene. Otherwise change the fills for a night scene.
    if (mouseX < 200):
        leftEye.fill = 'chocolate'
        rightEye.fill = 'chocolate'
        mouth.fill = 'chocolate'
        background.fill = 'lightBlue'
    else:
        leftEye.fill = 'yellow'
        rightEye.fill = 'yellow'
        mouth.fill = 'yellow'
        background.fill = 'black'
",regular,1
2042,Monument,3.4,"# These are facts about the Washington Monument that are helpful for this
# exercise:
#    The American flag was planted in 1776.
#    The bottom section of the monument was built in 1854.
#    The top section of the monument was built in 1884.
#    The reflecting pool was added in 1923.

# sky and grass
Rect(0, 0, 400, 350,
     fill=gradient('lightSkyBlue', 'lightSkyBlue', 'lightCyan', start='top'))
Rect(0, 350, 400, 150, fill='forestGreen')

def drawMonument(year):
    # Draw the flag, sections of the monument, and Reflecting Pool based
    # on the year.
    ### (HINT: Remember to use the historical information in lines 3-6.)
    # Label for the year
    Label(year, 10, 10, size=50, align='left-top')

    # American flag
    ### Fix Your Code Here ###
    Rect(270, 300, 30, 20, fill='red')
    Line(285, 302, 285, 320, fill='white', lineWidth=30, dashes=(1, 2))
    Rect(270, 300, 15, 10, fill='blue')
    Line(270, 300, 270, 350)

    # bottom section of monument
    ### Fix Your Code Here ###
    Polygon(170, 350, 175, 275, 225, 275, 230, 350, fill='cornSilk')

    # top section of monument
    ### Fix Your Code Here ###
    Polygon(175, 275, 185, 70, 200, 40, 215, 70, 225, 275,
            fill='blanchedAlmond')

    # Reflecting Pool
    ### Fix Your Code Here ###
    Polygon(150, 350, 120, 400, 280, 400, 250, 350, border='grey',
            fill=gradient('paleTurquoise', 'deepSkyBlue', start='top'))
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# These are facts about the Washington Monument that are helpful for this
# exercise:
#    The American flag was planted in 1776.
#    The bottom section of the monument was built in 1854.
#    The top section of the monument was built in 1884.
#    The reflecting pool was added in 1923.

# sky and grass
Rect(0, 0, 400, 350,
     fill=gradient('lightSkyBlue', 'lightSkyBlue', 'lightCyan', start='top'))
Rect(0, 350, 400, 150, fill='forestGreen')

def drawMonument(year):
    # Draw the flag, sections of the monument, and Reflecting Pool based
    # on the year.
    # Label for the year
    Label(year, 10, 10, size=50, align='left-top')

    # American Flag
    if (year >= 1776):
        Rect(270, 300, 30, 20, fill='red')
        Line(285, 302, 285, 320, fill='white', lineWidth=30, dashes=(1, 2))
        Rect(270, 300, 15, 10, fill='blue')
        Line(270, 300, 270, 350)

    # bottom section of monument
    if (year >= 1854):
        Polygon(170, 350, 175, 275, 225, 275, 230, 350, fill='cornSilk')

    # top section of monument
    if (year >= 1884):
        Polygon(175, 275, 185, 70, 200, 40, 215, 70, 225, 275,
                fill='blanchedAlmond')

    # Reflecting Pool
    if (year >= 1923):
        Polygon(150, 350, 120, 400, 280, 400, 250, 350, border='grey',
                fill=gradient('paleTurquoise', 'deepSkyBlue', start='top'))
",regular,2
2043,Up,3.4,"app.background = gradient('deepSkyBlue', 'lightCyan', start='top')

def drawBalloon(centerX, centerY, radius, color):
    Line(centerX, centerY, 200, 325, fill='silver', lineWidth=1)
    Circle(centerX, centerY, radius, fill=color)

def drawHouse(bottom):
    Rect(150, bottom - 50, 50, 50, fill='pink')
    Rect(200, bottom - 50, 50, 50, fill='limeGreen')
    Polygon(140, bottom - 50, 255, bottom - 50, 255, bottom - 100,
            150, bottom - 100, fill='mediumSlateBlue')
    Polygon(200, bottom - 40, 200, bottom - 60, 225, bottom - 90,
            250, bottom - 60, 250, bottom - 40, fill='lemonChiffon')
    Polygon(160, bottom - 60, 160, bottom - 70, 170, bottom - 80,
            180, bottom - 70, 180, bottom - 60, fill='lemonChiffon')
    Rect(175, bottom - 20, 10, 20, fill='maroon')
    Rect(150, bottom - 50, 50, 15, fill='cornflowerBlue')
    Rect(180, bottom - 130, 10, 40, fill='brown')
    Rect(225, bottom - 20, 12, 20, fill='lightGrey', border='tan', align='center')
    Rect(225, bottom - 60, 10, 18, fill='lightGrey', border='tan', align='center')
    Rect(170, bottom - 67, 5, 9, fill='lightGrey', border='tan', align='center')
    Rect(162, bottom - 15, 6, 12, fill='lightGrey', border='tan', align='center')

def drawHouseAndBalloons(balloons):
    # Draw the appropriate number of balloons.
    ### (HINT: There are a maximum of 5 balloons.)
    ### Place Your Code Here ###

    # Draw the house.
    ### (HINT: The house is off the ground when there are at least 5 balloons.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'lightCyan', start='top')

def drawBalloon(centerX, centerY, radius, color):
    Line(centerX, centerY, 200, 325, fill='silver', lineWidth=1)
    Circle(centerX, centerY, radius, fill=color)

def drawHouse(bottom):
    Rect(150, bottom - 50, 50, 50, fill='pink')
    Rect(200, bottom - 50, 50, 50, fill='limeGreen')
    Polygon(140, bottom - 50, 255, bottom - 50, 255, bottom - 100,
            150, bottom - 100, fill='mediumSlateBlue')
    Polygon(200, bottom - 40, 200, bottom - 60, 225, bottom - 90,
            250, bottom - 60, 250, bottom - 40, fill='lemonChiffon')
    Polygon(160, bottom - 60, 160, bottom - 70, 170, bottom - 80,
            180, bottom - 70, 180, bottom - 60, fill='lemonChiffon')
    Rect(175, bottom - 20, 10, 20, fill='maroon')
    Rect(150, bottom - 50, 50, 15, fill='cornflowerBlue')
    Rect(180, bottom - 130, 10, 40, fill='brown')
    Rect(225, bottom - 20, 12, 20, fill='lightGrey', border='tan', align='center')
    Rect(225, bottom - 60, 10, 18, fill='lightGrey', border='tan', align='center')
    Rect(170, bottom - 67, 5, 9, fill='lightGrey', border='tan', align='center')
    Rect(162, bottom - 15, 6, 12, fill='lightGrey', border='tan', align='center')

def drawHouseAndBalloons(balloons):
    # Draw the appropriate number of balloons.
    if (balloons >= 1):
        drawBalloon(160, 50, 50, 'indigo')
    if (balloons >= 2):
        drawBalloon(200, 110, 65, 'mediumPurple')
    if (balloons >= 3):
        drawBalloon(240, 50, 35, 'darkViolet')
    if (balloons >= 4):
        drawBalloon(120, 120, 40, 'mediumVioletRed')
    if (balloons >= 5):
        drawBalloon(280, 120, 35, 'purple')

    # Draw the house
    if (balloons >= 5):
        drawHouse(350)
    else:
        drawHouse(400)
",regular,2
2045,Castle,3.4,"def drawBackground(skyColor, groundColor, moatColor):
    # Draws background of the image.
    Rect(0, 325, 400, 75, fill=groundColor)
    Line(0, 375, 400, 375, fill=moatColor, lineWidth=25)
    Rect(0, 0, 400, 325, fill=skyColor)

def drawBushes(x, y, bushColor):
    Circle(x, y, 15, fill=bushColor, border='green')
    Circle(x + 15, y, 15, fill=bushColor, border='green')
    Circle(x + 20, y - 10, 15, fill=bushColor, border='green')
    Circle(x + 30, y, 15, fill=bushColor, border='green')
    Circle(x + 10, y - 10, 15, fill=bushColor)

def drawDrawbridge(drawbridgeColor, drawbridgeLineColor, windowColor):
    Rect(150, 300, 100, 50, fill=windowColor)
    Circle(200, 300, 50, fill=windowColor)
    Rect(150, 350, 100, 50, fill=drawbridgeColor)
    Line(175, 350, 175, 400, fill=drawbridgeLineColor, lineWidth=4)
    Line(200, 350, 200, 400, fill=drawbridgeLineColor, lineWidth=4)
    Line(225, 350, 225, 400, fill=drawbridgeLineColor, lineWidth=4)

def drawCone(x, y, width, coneColor):
    RegularPolygon(x, y, width, 3, fill=coneColor)

def drawCover(x, y, width, height):
    # Draws the lip at the top of every tower.
    Rect(x, y + 10, width, height, fill='dimGrey')
    Circle(x, y + height, height, fill='grey')
    Circle(x + width, y + height, height, fill='grey')
    Rect(x, y, width, 2 * height, fill='grey')

def drawWindow(x, y, windowColor):
    Oval(x, y, 30, 50, fill=windowColor)
    Rect(x - 20, y + 5, 40, 20, fill='darkGrey')

def drawTinyCastleTower(x, y, width, height, castleColor):
    # Draws the top pillar of a tower.
    Rect(x, y, width, height, fill=castleColor, border='grey')
    drawCover(x, y - 5, width, 6)

def drawCastleTower(x, y, castleColor, coneColor, windowColor):
    # Draws the small tower with body, cover, and window.
    drawCone(x + 40, y - 60, 30, coneColor)
    drawTinyCastleTower(x + 10, y - 40, 60, 100, castleColor)

    Rect(x, y, 80, 200, fill=castleColor, border='grey')
    drawCover(x, y - 5, 80, 8)
    drawWindow(x + 40, y + 60, windowColor)

def drawCastleHelper(bushColor1, bushColor2, castleColor, coneColor,
                     windowColor):
    # Draws the three towers and bushes of the castle.
    drawCastleTower(45, 150, castleColor, coneColor, windowColor)
    drawCastleTower(275, 150, castleColor, coneColor, windowColor)
    drawCastleTower(160, 100, castleColor, coneColor, windowColor)

    drawBushes(30, 335, bushColor1)
    drawBushes(340, 335, bushColor1)
    drawBushes(50, 340, bushColor2)
    drawBushes(330, 340, bushColor2)

def drawCastleScene(skyColor, groundColor, moatColor, bushColor1, bushColor2,
                    castleColor, coneColor, windowColor, drawbridgeColor,
                    drawbridgeLineColor):
    # Draw the background, the towers and bushes.
    ### (HINT: Call appropriate helper functions as needed.)
    ### Place Your Code Here ###

    # Draw the bottom of the center castle around the drawbridge
    # and the drawbridge itself.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawBackground(skyColor, groundColor, moatColor):
    # Draws background of the image.
    Rect(0, 325, 400, 75, fill=groundColor)
    Line(0, 375, 400, 375, fill=moatColor, lineWidth=25)
    Rect(0, 0, 400, 325, fill=skyColor)

def drawBushes(x, y, bushColor):
    Circle(x, y, 15, fill=bushColor, border='green')
    Circle(x + 15, y, 15, fill=bushColor, border='green')
    Circle(x + 20, y - 10, 15, fill=bushColor, border='green')
    Circle(x + 30, y, 15, fill=bushColor, border='green')
    Circle(x + 10, y - 10, 15, fill=bushColor)

def drawDrawbridge(drawbridgeColor, drawbridgeLineColor, windowColor):
    Rect(150, 300, 100, 50, fill=windowColor)
    Circle(200, 300, 50, fill=windowColor)
    Rect(150, 350, 100, 50, fill=drawbridgeColor)
    Line(175, 350, 175, 400, fill=drawbridgeLineColor, lineWidth=4)
    Line(200, 350, 200, 400, fill=drawbridgeLineColor, lineWidth=4)
    Line(225, 350, 225, 400, fill=drawbridgeLineColor, lineWidth=4)

def drawCone(x, y, width, coneColor):
    RegularPolygon(x, y, width, 3, fill=coneColor)

def drawCover(x, y, width, height):
    # Draws the lip at the top of every tower.
    Rect(x, y + 10, width, height, fill='dimGrey')
    Circle(x, y + height, height, fill='grey')
    Circle(x + width, y + height, height, fill='grey')
    Rect(x, y, width, 2 * height, fill='grey')

def drawWindow(x, y, windowColor):
    Oval(x, y, 30, 50, fill=windowColor)
    Rect(x - 20, y + 5, 40, 20, fill='darkGrey')

def drawTinyCastleTower(x, y, width, height, castleColor):
    # Draws the top pillar of a tower.
    Rect(x, y, width, height, fill=castleColor, border='grey')
    drawCover(x, y - 5, width, 6)

def drawCastleTower(x, y, castleColor, coneColor, windowColor):
    # Draws the small tower with body, cover, and window.
    drawCone(x + 40, y - 60, 30, coneColor)
    drawTinyCastleTower(x + 10, y - 40, 60, 100, castleColor)

    Rect(x, y, 80, 200, fill=castleColor, border='grey')
    drawCover(x, y - 5, 80, 8)
    drawWindow(x + 40, y + 60, windowColor)

def drawCastleHelper(bushColor1, bushColor2, castleColor, coneColor,
                     windowColor):
    # Draws the three towers and bushes of the castle.
    drawCastleTower(45, 150, castleColor, coneColor, windowColor)
    drawCastleTower(275, 150, castleColor, coneColor, windowColor)
    drawCastleTower(160, 100, castleColor, coneColor, windowColor)

    drawBushes(30, 335, bushColor1)
    drawBushes(340, 335, bushColor1)
    drawBushes(50, 340, bushColor2)
    drawBushes(330, 340, bushColor2)

def drawCastleScene(skyColor, groundColor, moatColor, bushColor1, bushColor2,
                    castleColor, coneColor, windowColor, drawbridgeColor,
                    drawbridgeLineColor):
    # Draw the background, the towers and bushes.
    drawBackground(skyColor, groundColor, moatColor)
    drawCastleHelper(bushColor1, bushColor2, castleColor, coneColor,
                     windowColor)

    # Draw the bottom of the center castle around the drawbridge
    # and the drawbridge itself.
    Rect(125, 225, 150, 125, fill=castleColor, border='grey')
    drawCover(125, 220, 150, 5)
    drawDrawbridge(drawbridgeColor, drawbridgeLineColor, windowColor)
",regular,3
2054,Collaborative task,3.5.2,# Fill me in!,,creative,30
2047,Ferris wheel,3.5.2,"# background
app.background = gradient('moccasin', 'papayaWhip', start='top')
Polygon(200, 400, 360, 340, 450, 400,
        fill=gradient('gold', 'goldenrod', start='top'))
Polygon(-100, 400, 40, 300, 300, 400,
        fill=gradient('orange', 'tomato', start='top'))

# rotating piece
rotatingSpikes = Star(200, 200, 150, 20, fill=gradient('red', 'blue'),
                      roundness=15)

# back leg
Line(175, 400, 200, 200, fill='white', lineWidth=8)

# inner rings
Circle(200, 200, 100, fill=None, border='yellow', borderWidth=10, opacity=70)
Circle(200, 200, 75, fill=None, border='blue', borderWidth=10, opacity=70)
Circle(200, 200, 50, fill=None, border='red', borderWidth=10, opacity=70)
Circle(200, 200, 25, fill=None, border='purple', borderWidth=10, opacity=70)

# outer ring
Circle(200, 200, 150, fill=None, borderWidth=10, opacity=70,
       border=gradient('blue', 'red', 'green', 'yellow', start='top'))
Circle(200, 200, 146, fill=None, border='white')
Circle(200, 200, 154, fill=None, border='white')

# front leg
Line(225, 400, 200, 200, fill='white', lineWidth=8)

def onMouseMove(mouseX, mouseY):
    rotatingSpikes.rotateAngle += 1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
app.background = gradient('moccasin', 'papayaWhip', start='top')
Polygon(200, 400, 360, 340, 450, 400,
        fill=gradient('gold', 'goldenrod', start='top'))
Polygon(-100, 400, 40, 300, 300, 400,
        fill=gradient('orange', 'tomato', start='top'))

# rotating piece
rotatingSpikes = Star(200, 200, 150, 20, fill=gradient('red', 'blue'),
                      roundness=15)

# back leg
Line(175, 400, 200, 200, fill='white', lineWidth=8)

# inner rings
Circle(200, 200, 100, fill=None, border='yellow', borderWidth=10, opacity=70)
Circle(200, 200, 75, fill=None, border='blue', borderWidth=10, opacity=70)
Circle(200, 200, 50, fill=None, border='red', borderWidth=10, opacity=70)
Circle(200, 200, 25, fill=None, border='purple', borderWidth=10, opacity=70)

# outer ring
Circle(200, 200, 150, fill=None, borderWidth=10, opacity=70,
       border=gradient('blue', 'red', 'green', 'yellow', start='top'))
Circle(200, 200, 146, fill=None, border='white')
Circle(200, 200, 154, fill=None, border='white')

# front leg
Line(225, 400, 200, 200, fill='white', lineWidth=8)

def onMouseMove(mouseX, mouseY):
    rotatingSpikes.rotateAngle += 1
",sample,1
2048,UFO chase,3.5.2,"app.background = 'black'

# background stars
Star(320, 50, 2, 5, fill='white')
Star(230, 115, 3, 5, fill='white')
Star(380, 315, 2, 5, fill='white')
Star(150, 190, 2, 5, fill='white')
Star(285, 290, 3, 5, fill='white')
Star(50, 325, 2, 5, fill='white')
Star(210, 375, 2, 5, fill='white')
Star(10, 25, 2, 5, fill='white')

# moon
Circle(50, 100, 30, fill=gradient('black', 'grey', start='left'))
Circle(40, 80, 3, fill=rgb(50, 50, 50))
Circle(65, 85, 4, fill=rgb(85, 85, 85))
Circle(70, 110, 3, fill=rgb(85, 85, 85))
Circle(40, 115, 4, fill=rgb(45, 45, 45))
Circle(45, 95, 4, fill=rgb(55, 55, 55))
Circle(60, 100, 4, fill=rgb(75, 75, 75))
Circle(30, 95, 3, fill=rgb(15, 15, 15))

# trails
trail1 = Line(0, 0, 0, 0, fill='blue', lineWidth=5)
trail2 = Line(0, 0, 0, 0, fill='lime', lineWidth=5)
trail3 = Line(0, 0, 0, 0, fill='red', lineWidth=5)

# fighters
fighter1 = Circle(-10, -10, 5, fill=gradient('lightGrey', 'grey'))
fighter2 = Circle(-10, -10, 5, fill=gradient('lightGrey', 'grey'))
fighter3 = Circle(-10, -10, 5, fill=gradient('darkGrey', 'grey'))

def moveFighter(fighter, newX, newY):
    fighter.centerX = newX
    fighter.centerY = newY

def moveTrail(fighter, trail):
    trail.x1 = trail.x2
    trail.y1 = trail.y2

    trail.x2 = fighter.centerX
    trail.y2 = fighter.centerY

def onMouseMove(mouseX, mouseY):
    # Move each fighter to the end of the previous fighter's trail.
    ### (HINT: The first fighter follows the mouse!)
    ### (HINT: Use the 1st trail's x1 and y1 to move the 2nd trail.)
    ### (HINT: Use the 2nd trail's x1 and y1 to move the 3rd trail.)
    moveFighter(fighter1, mouseX, mouseY)
    moveFighter(fighter2, trail1.x1, trail1.y1)
    moveFighter(fighter3, trail2.x1, trail2.y1)

    # Move each trail to follow the fighter.
    moveTrail(fighter1, trail1)
    moveTrail(fighter2, trail2)
    moveTrail(fighter3, trail3)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# background stars
Star(320, 50, 2, 5, fill='white')
Star(230, 115, 3, 5, fill='white')
Star(380, 315, 2, 5, fill='white')
Star(150, 190, 2, 5, fill='white')
Star(285, 290, 3, 5, fill='white')
Star(50, 325, 2, 5, fill='white')
Star(210, 375, 2, 5, fill='white')
Star(10, 25, 2, 5, fill='white')

# moon
Circle(50, 100, 30, fill=gradient('black', 'grey', start='left'))
Circle(40, 80, 3, fill=rgb(50, 50, 50))
Circle(65, 85, 4, fill=rgb(85, 85, 85))
Circle(70, 110, 3, fill=rgb(85, 85, 85))
Circle(40, 115, 4, fill=rgb(45, 45, 45))
Circle(45, 95, 4, fill=rgb(55, 55, 55))
Circle(60, 100, 4, fill=rgb(75, 75, 75))
Circle(30, 95, 3, fill=rgb(15, 15, 15))

# trails
trail1 = Line(0, 0, 0, 0, fill='blue', lineWidth=5)
trail2 = Line(0, 0, 0, 0, fill='lime', lineWidth=5)
trail3 = Line(0, 0, 0, 0, fill='red', lineWidth=5)

# fighters
fighter1 = Circle(-10, -10, 5, fill=gradient('lightGrey', 'grey'))
fighter2 = Circle(-10, -10, 5, fill=gradient('lightGrey', 'grey'))
fighter3 = Circle(-10, -10, 5, fill=gradient('darkGrey', 'grey'))

def moveFighter(fighter, newX, newY):
    fighter.centerX = newX
    fighter.centerY = newY

def moveTrail(fighter, trail):
    trail.x1 = trail.x2
    trail.y1 = trail.y2

    trail.x2 = fighter.centerX
    trail.y2 = fighter.centerY

def onMouseMove(mouseX, mouseY):
    # Move each fighter to the end of the previous fighter's trail.
    ### (HINT: The first fighter follows the mouse!)
    ### (HINT: Use the 1st trail's x1 and y1 to move the 2nd trail.)
    ### (HINT: Use the 2nd trail's x1 and y1 to move the 3rd trail.)
    moveFighter(fighter1, mouseX, mouseY)
    moveFighter(fighter2, trail1.x1, trail1.y1)
    moveFighter(fighter3, trail2.x1, trail2.y1)

    # Move each trail to follow the fighter.
    moveTrail(fighter1, trail1)
    moveTrail(fighter2, trail2)
    moveTrail(fighter3, trail3)
",sample,1
2051,Creative task 3,3.5.2,# Fill me in!,,creative,30
2049,Creative task 1,3.5.2,# Fill me in!,,creative,30
2050,Creative task 2,3.5.2,# Fill me in!,,creative,30
2052,Creative task 4,3.5.2,# Fill me in!,,creative,30
2053,Creative task 5,3.5.2,# Fill me in!,,creative,30
2058,Road trip,4.1.2,"def drawMountains():
    Polygon(0, 175, 150, 175, 50, 100, fill='steelBlue')
    Polygon(210, 175, 400, 175, 300, 100, fill='midnightBlue')
    Polygon(50, 175, 190, 175, 130, 120, fill='midnightBlue')

def drawOcean():
    Polygon(0, 285, 180, 175, 0, 175, fill='dodgerBlue')
    Polygon(0, 285, 180, 175, 190, 175, 0, 350, fill='tan')

def drawGround(groundColor):
    Rect(0, 175, 400, 225, fill=groundColor)
    Polygon(0, 350, 0, 400, 400, 400, 400, 350, 210, 175, 190, 175, fill='grey')
    Line(200, 175, 200, 400, lineWidth=10, dashes=True,
         fill=gradient('grey', 'silver', start='top'))

def drawScene(isMountainous, isDesert, isBeach, isNightTime, destination,
              milesToGo):
    # Draws the sky.
    Rect(0, 0, 400, 175, fill='lightSkyBlue')

    # Draw the ground, mountains (if needed), and ocean (if needed) based on the
    # values of the first three parameters.
    ### Place Your Code Here ###

    # Draws the sign board with destination and milesToGo.
    Line(290, 230, 290, 200)
    Line(370, 230, 370, 200)
    Rect(330, 200, 100, 60, fill='green', border='white', align='bottom')
    Label(destination, 330, 160, fill='white', size=16)
    Label(milesToGo, 330, 180, fill='white', size=18)

    # Make the scene darker if it is night-time.
    ### (HINT: Use the Inspector to see what was added to the canvas for this
    #          test case.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawMountains():
    Polygon(0, 175, 150, 175, 50, 100, fill='steelBlue')
    Polygon(210, 175, 400, 175, 300, 100, fill='midnightBlue')
    Polygon(50, 175, 190, 175, 130, 120, fill='midnightBlue')

def drawOcean():
    Polygon(0, 285, 180, 175, 0, 175, fill='dodgerBlue')
    Polygon(0, 285, 180, 175, 190, 175, 0, 350, fill='tan')

def drawGround(groundColor):
    Rect(0, 175, 400, 225, fill=groundColor)
    Polygon(0, 350, 0, 400, 400, 400, 400, 350, 210, 175, 190, 175, fill='grey')
    Line(200, 175, 200, 400, lineWidth=10, dashes=True,
         fill=gradient('grey', 'silver', start='top'))

def drawScene(isMountainous, isDesert, isBeach, isNightTime, destination,
              milesToGo):
    # Draws the sky.
    Rect(0, 0, 400, 175, fill='lightSkyBlue')

    # Draw the ground, mountains (if needed), and ocean (if needed) based on the
    # values of the first three parameters.
    if (isMountainous == True):
        drawGround('lightGreen')
        drawMountains()
    elif (isDesert == True):
        drawGround('burlyWood')
    elif (isBeach == True):
        drawGround('lightGreen')
        drawOcean()

    # Draw the sign board with destination and milesToGo.
    Line(290, 230, 290, 200)
    Line(370, 230, 370, 200)
    Rect(330, 200, 100, 60, fill='green', border='white', align='bottom')
    Label(destination, 330, 160, fill='white', size=16)
    Label(milesToGo, 330, 180, fill='white', size=18)

    # Make the scene darker if it is night-time.
    if (isNightTime == True):
        Rect(0, 0, 400, 400, opacity=50)
",regular,3
2061,Spongebob,4.1.2,"# background
Rect(0, 250, 400, 150, fill='sandyBrown')
Rect(0, 0, 400, 250, fill='skyBlue')

# Spongebob's arms
Line(90, 200, 70, 250, fill=rgb(255, 250, 95), lineWidth=10)
Line(70, 245, 100, 260, fill=rgb(255, 250, 95), lineWidth=10)
Line(310, 215, 360, 215, fill=rgb(255, 250, 95), lineWidth=10)

# sleeves
Circle(100, 210, 20, fill='white', border='black')
Circle(300, 210, 20, fill='white', border='black')

# body
Polygon(100, 250, 85, 70, 105, 45, 295, 45,
        315, 70, 300, 250, fill=rgb(255, 250, 95))
Circle(105, 65, 20, fill=rgb(255, 250, 95))
Circle(295, 65, 20, fill=rgb(255, 250, 95))

# clothes
Rect(100, 250, 200, 10, fill='white')
Rect(100, 260, 200, 40, fill=rgb(190, 125, 95))
Polygon(190, 250, 200, 260, 190, 280, 200, 290, 210,
        280, 200, 260, 210, 250, fill='red')

# eyelashes
Line(145, 105, 130, 85, lineWidth=4)
Line(155, 105, 155, 77, lineWidth=4)
Line(175, 105, 185, 85, lineWidth=4)

Line(255, 105, 270, 85, lineWidth=4)
Line(245, 105, 245, 77, lineWidth=4)
Line(225, 105, 215, 85, lineWidth=4)

# smile
Oval(205, 185, 130, 50)
Oval(205, 185, 120, 40, fill=rgb(255, 250, 95))
Rect(140, 160, 130, 25, fill=rgb(255, 250, 95))

# legs
Line(160, 300, 160, 350, fill=rgb(255, 250, 95), lineWidth=10)
Line(240, 300, 240, 350, fill=rgb(255, 250, 95), lineWidth=10)

# eyes
Circle(160, 130, 40, fill='white', border='black')
Circle(240, 130, 40, fill='white', border='black')
Circle(170, 130, 17)
Circle(230, 130, 17)
Circle(170, 130, 15, border=rgb(130, 190, 235), borderWidth=7)
Circle(230, 130, 15, border=rgb(130, 190, 235), borderWidth=7)

# nose
Oval(200, 160, 32, 40, fill=rgb(255, 250, 95), border='black')
Rect(180, 170, 30, 30, fill=rgb(255, 250, 95))

# shoes
Oval(140, 360, 35, 20)
Line(160, 350, 160, 370, lineWidth=10)

Oval(260, 360, 35, 20)
Line(240, 350, 240, 370, lineWidth=10)

# spots
Oval(105, 90, 15, 30, fill=rgb(205, 190, 115))
Oval(290, 80, 15, 20, fill=rgb(205, 190, 115))
Oval(295, 160, 15, 25, fill=rgb(205, 190, 115))
Oval(270, 230, 20, 25, fill=rgb(205, 190, 115))
Oval(120, 210, 20, 35, fill=rgb(205, 190, 115))
Oval(155, 225, 15, 20, fill=rgb(205, 190, 115))

def drawFryCooking():
    Line(360, 240, 360, 150, fill='darkSlateGrey', lineWidth=10)
    Rect(340, 100, 40, 50, fill='darkSlateGrey')
    Line(349, 125, 371, 125, fill='skyBlue', lineWidth=30, dashes=(1, 9))

def drawJellyFishing():
    Line(360, 240, 360, 150, fill='sandyBrown', lineWidth=10)
    Oval(360, 125, 40, 50, fill='grey', opacity=20)
    Oval(335, 125, 80, 50, fill='grey', opacity=20)
    Oval(360, 125, 40, 50, fill=None, border='sandyBrown', borderWidth=7)

def drawConfused():
    Oval(355, 220, 80, 100, fill='white', border='black')
    Polygon(325, 190, 280, 200, 320, 220)
    Polygon(330, 193, 285, 200, 320, 218, fill='white')
    Label('?', 355, 220, size=50)

def drawActivity(activity):
    # Draw an appropriate item using the helper functions depending on
    # the activity.
    ### (HINT: Make sure to draw the appropriate item for undefined activities.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 250, 400, 150, fill='sandyBrown')
Rect(0, 0, 400, 250, fill='skyBlue')

# Spongebob's arms
Line(90, 200, 70, 250, fill=rgb(255, 250, 95), lineWidth=10)
Line(70, 245, 100, 260, fill=rgb(255, 250, 95), lineWidth=10)
Line(310, 215, 360, 215, fill=rgb(255, 250, 95), lineWidth=10)

# sleeves
Circle(100, 210, 20, fill='white', border='black')
Circle(300, 210, 20, fill='white', border='black')

# body
Polygon(100, 250, 85, 70, 105, 45, 295, 45,
        315, 70, 300, 250, fill=rgb(255, 250, 95))
Circle(105, 65, 20, fill=rgb(255, 250, 95))
Circle(295, 65, 20, fill=rgb(255, 250, 95))

# clothes
Rect(100, 250, 200, 10, fill='white')
Rect(100, 260, 200, 40, fill=rgb(190, 125, 95))
Polygon(190, 250, 200, 260, 190, 280, 200, 290, 210,
        280, 200, 260, 210, 250, fill='red')

# eyelashes
Line(145, 105, 130, 85, lineWidth=4)
Line(155, 105, 155, 77, lineWidth=4)
Line(175, 105, 185, 85, lineWidth=4)

Line(255, 105, 270, 85, lineWidth=4)
Line(245, 105, 245, 77, lineWidth=4)
Line(225, 105, 215, 85, lineWidth=4)

# smile
Oval(205, 185, 130, 50)
Oval(205, 185, 120, 40, fill=rgb(255, 250, 95))
Rect(140, 160, 130, 25, fill=rgb(255, 250, 95))

# legs
Line(160, 300, 160, 350, fill=rgb(255, 250, 95), lineWidth=10)
Line(240, 300, 240, 350, fill=rgb(255, 250, 95), lineWidth=10)

# eyes
Circle(160, 130, 40, fill='white', border='black')
Circle(240, 130, 40, fill='white', border='black')
Circle(170, 130, 17)
Circle(230, 130, 17)
Circle(170, 130, 15, border=rgb(130, 190, 235), borderWidth=7)
Circle(230, 130, 15, border=rgb(130, 190, 235), borderWidth=7)

# nose
Oval(200, 160, 32, 40, fill=rgb(255, 250, 95), border='black')
Rect(180, 170, 30, 30, fill=rgb(255, 250, 95))

# shoes
Oval(140, 360, 35, 20)
Line(160, 350, 160, 370, lineWidth=10)

Oval(260, 360, 35, 20)
Line(240, 350, 240, 370, lineWidth=10)

# spots
Oval(105, 90, 15, 30, fill=rgb(205, 190, 115))
Oval(290, 80, 15, 20, fill=rgb(205, 190, 115))
Oval(295, 160, 15, 25, fill=rgb(205, 190, 115))
Oval(270, 230, 20, 25, fill=rgb(205, 190, 115))
Oval(120, 210, 20, 35, fill=rgb(205, 190, 115))
Oval(155, 225, 15, 20, fill=rgb(205, 190, 115))

def drawFryCooking():
    Line(360, 240, 360, 150, fill='darkSlateGrey', lineWidth=10)
    Rect(340, 100, 40, 50, fill='darkSlateGrey')
    Line(349, 125, 371, 125, fill='skyBlue', lineWidth=30, dashes=(1, 9))

def drawJellyFishing():
    Line(360, 240, 360, 150, fill='sandyBrown', lineWidth=10)
    Oval(360, 125, 40, 50, fill='grey', opacity=20)
    Oval(335, 125, 80, 50, fill='grey', opacity=20)
    Oval(360, 125, 40, 50, fill=None, border='sandyBrown', borderWidth=7)

def drawConfused():
    Oval(355, 220, 80, 100, fill='white', border='black')
    Polygon(325, 190, 280, 200, 320, 220)
    Polygon(330, 193, 285, 200, 320, 218, fill='white')
    Label('?', 355, 220, size=50)

def drawActivity(activity):
    # Draw an appropriate item using the helper functions depending on
    # the activity.
    if (activity == 'fry-cooking'):
        drawFryCooking()
    elif (activity == 'jelly-fishing'):
        drawJellyFishing()
    else:
        drawConfused()
",regular,1
2059,Volume bars,4.1.2,"app.background = 'black'

leftVolumeBar = Line(75, 300, 75, 400, lineWidth=100, dashes=True,
                     fill=gradient('black', 'red', 'orange', 'yellow',
                                   'lawnGreen', start='top'))
centerVolumeBar = Line(200, 300, 200, 400, lineWidth=100, dashes=True,
                       fill=gradient('black', 'red', 'orange', 'yellow',
                                     'lawnGreen', start='top'))
rightVolumeBar = Line(325, 300, 325, 400, lineWidth=100, dashes=True,
                      fill=gradient('black', 'red', 'orange', 'yellow',
                                    'lawnGreen', start='top'))

def setVolumeBars(newLeftBarY1, newCenterBarY1, newRightBarY1):
    # Set each volume bar to new y1 value.
    leftVolumeBar.y1 = newLeftBarY1
    centerVolumeBar.y1 = newCenterBarY1
    rightVolumeBar.y1 = newRightBarY1

def onMouseMove(mouseX, mouseY):
    # Change the height of volume bars based on which volume bar the mouse is above.
    ### (HINT: The volume bars are set at either a height of mouseY or
    #          400 - mouseY.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

leftVolumeBar = Line(75, 300, 75, 400, lineWidth=100, dashes=True,
                     fill=gradient('black', 'red', 'orange', 'yellow',
                                   'lawnGreen', start='top'))
centerVolumeBar = Line(200, 300, 200, 400, lineWidth=100, dashes=True,
                       fill=gradient('black', 'red', 'orange', 'yellow',
                                     'lawnGreen', start='top'))
rightVolumeBar = Line(325, 300, 325, 400, lineWidth=100, dashes=True,
                      fill=gradient('black', 'red', 'orange', 'yellow',
                                    'lawnGreen', start='top'))

def setVolumeBars(newLeftBarY1, newCenterBarY1, newRightBarY1):
    # Set each volume bar to new y1 value.
    leftVolumeBar.y1 = newLeftBarY1
    centerVolumeBar.y1 = newCenterBarY1
    rightVolumeBar.y1 = newRightBarY1

def onMouseMove(mouseX, mouseY):
    # Change the height of volume bars based on which volume bar the mouse is above.
    if (mouseX < 125):
        setVolumeBars(mouseY, 400 - mouseY, 400 - mouseY)
    elif (mouseX < 275):
        setVolumeBars(400 - mouseY, mouseY, 400 - mouseY)
    else:
        setVolumeBars(400 - mouseY, 400 - mouseY, mouseY)
",regular,1
2060,Apple tree,4.1.2,"app.background = rgb(205, 230, 240)

season = Label('Spring', 200, 50, size=30)

leaves1 = Circle(200, 260, 75, fill=rgb(140, 195, 30))
leaves2 = Circle(200, 210, 60, fill=rgb(140, 195, 30))
leaves3 = Circle(200, 160, 45, fill=rgb(140, 195, 30))

apple1 = Star(180, 160, 10, 8, fill=gradient('pink', 'violet'), roundness=50)
apple2 = Star(250, 230, 10, 8, fill=gradient('pink', 'violet'), roundness=50)
apple3 = Star(150, 250, 10, 8, fill=gradient('pink', 'violet'), roundness=50)
apple4 = Star(170, 290, 10, 8, fill=gradient('pink', 'violet'), roundness=50)

# trunk
Line(200, 180, 200, 400)

# branches
Line(170, 210, 200, 230)
Line(170, 260, 200, 280)
Line(230, 240, 200, 260)
Line(230, 195, 200, 215)

def colorLeaves(leafColor):
    leaves1.fill = leafColor
    leaves2.fill = leafColor
    leaves3.fill = leafColor

def showApplesOrFlowers(isVisible):
    apple1.visible = isVisible
    apple2.visible = isVisible
    apple3.visible = isVisible
    apple4.visible = isVisible

def changeApples(color, roundness):
    showApplesOrFlowers(True)
    apple1.fill = color
    apple1.roundness = roundness
    apple2.fill = color
    apple2.roundness = roundness
    apple3.fill = color
    apple3.roundness = roundness
    apple4.fill = color
    apple4.roundness = roundness

def onMousePress(mouseX, mouseY):
    # Depending on what season it is, change the leaf, change the Label,
    # and either show or hide the flowers and apples.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(205, 230, 240)

season = Label('Spring', 200, 50, size=30)

leaves1 = Circle(200, 260, 75, fill=rgb(140, 195, 30))
leaves2 = Circle(200, 210, 60, fill=rgb(140, 195, 30))
leaves3 = Circle(200, 160, 45, fill=rgb(140, 195, 30))

apple1 = Star(180, 160, 10, 8, fill=gradient('pink', 'violet'), roundness=50)
apple2 = Star(250, 230, 10, 8, fill=gradient('pink', 'violet'), roundness=50)
apple3 = Star(150, 250, 10, 8, fill=gradient('pink', 'violet'), roundness=50)
apple4 = Star(170, 290, 10, 8, fill=gradient('pink', 'violet'), roundness=50)

# trunk
Line(200, 180, 200, 400)

# branches
Line(170, 210, 200, 230)
Line(170, 260, 200, 280)
Line(230, 240, 200, 260)
Line(230, 195, 200, 215)

def colorLeaves(leafColor):
    leaves1.fill = leafColor
    leaves2.fill = leafColor
    leaves3.fill = leafColor

def showApplesOrFlowers(isVisible):
    apple1.visible = isVisible
    apple2.visible = isVisible
    apple3.visible = isVisible
    apple4.visible = isVisible

def changeApples(color, roundness):
    showApplesOrFlowers(True)
    apple1.fill = color
    apple1.roundness = roundness
    apple2.fill = color
    apple2.roundness = roundness
    apple3.fill = color
    apple3.roundness = roundness
    apple4.fill = color
    apple4.roundness = roundness

def onMousePress(mouseX, mouseY):
    # Depending on what season it is, change the leaf, change the Label,
    # and either show or hide the flowers and apples.
    if (season.value == 'Spring'):
        colorLeaves(rgb(50, 153, 50))
        changeApples('red', 100)
        season.value = 'Summer'
    elif (season.value == 'Summer'):
        colorLeaves(rgb(255, 175, 25))
        showApplesOrFlowers(False)
        season.value = 'Fall'
    elif (season.value == 'Fall'):
        colorLeaves('snow')
        showApplesOrFlowers(False)
        season.value = 'Winter'
    elif (season.value == 'Winter'):
        colorLeaves(rgb(140, 195, 30))
        changeApples(gradient('pink', 'violet'), 50)
        season.value = 'Spring'
",regular,2
2062,Cell reception,4.1.2,"Rect(0, 0, 400, 400,
     fill=gradient('limeGreen', 'yellow', 'orange', 'red', start='top'),
     opacity=20)

cellPhone = Rect(350, 320, 50, 80, border='dimGrey', borderWidth=3, align='center')
cellPhoneButton = Circle(350, 350, 5, fill='dimGrey')

barLow = Rect(180, 340, 10, 15, fill=None, border='dodgerBlue', align='bottom')
barMid = Rect(200, 340, 10, 30, fill=None, border='dodgerBlue', align='bottom')
barHigh = Rect(220, 340, 10, 45, fill=None, border='dodgerBlue', align='bottom')

def onMouseMove(mouseX, mouseY):
    # Move the cellPhone to the mouse location and cellPhoneButton accordingly.
    ### Place Your Code Here ###

    # Based on your mouseY value, fill the reception bars.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(0, 0, 400, 400,
     fill=gradient('limeGreen', 'yellow', 'orange', 'red', start='top'),
     opacity=20)

cellPhone = Rect(350, 320, 50, 80, border='dimGrey', borderWidth=3, align='center')
cellPhoneButton = Circle(350, 350, 5, fill='dimGrey')

barLow = Rect(180, 340, 10, 15, fill=None, border='dodgerBlue', align='bottom')
barMid = Rect(200, 340, 10, 30, fill=None, border='dodgerBlue', align='bottom')
barHigh = Rect(220, 340, 10, 45, fill=None, border='dodgerBlue', align='bottom')

def onMouseMove(mouseX, mouseY):
    # Move the cellPhone to the mouse location and cellPhoneButton accordingly.
    cellPhone.centerX = mouseX
    cellPhone.centerY = mouseY
    cellPhoneButton.centerX = mouseX
    cellPhoneButton.centerY = mouseY + 30

    # Based on your mouseY value, fill the reception bars.
    if (mouseY <= 100):
        barLow.fill = 'dodgerBlue'
        barMid.fill = 'dodgerBlue'
        barHigh.fill = 'dodgerBlue'
    elif (mouseY <= 200):
        barLow.fill = 'dodgerBlue'
        barMid.fill = 'dodgerBlue'
        barHigh.fill = None
    elif (mouseY <= 300):
        barLow.fill = 'dodgerBlue'
        barMid.fill = None
        barHigh.fill = None
    else:
        barLow.fill = None
        barMid.fill = None
        barHigh.fill = None
",regular,2
2057,Chameleon,4.1.2,"# background
Rect(0, 0, 200, 400, fill='blueViolet', opacity=70)
Rect(200, 0, 200, 400, fill='limeGreen', opacity=50)

chameleon = Polygon(215, 170, 235, 130, 250, 145, 280, 110, 330, 105, 360, 135,
                    370, 175, 350, 230, 330, 220, 320, 200,  345, 215, 335,
                    175, 250, 175, 240, 180, fill='limeGreen')

def onMousePress(mouseX, mouseY):
    # Move the chameleon to the location of your mouse click.
    ### Place Your Code Here ###

    # Change the fill of chameleon based on mouseX value.
    ### (HINT: Use conditionals!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 200, 400, fill='blueViolet', opacity=70)
Rect(200, 0, 200, 400, fill='limeGreen', opacity=50)

chameleon = Polygon(215, 170, 235, 130, 250, 145, 280, 110, 330, 105, 360, 135,
                    370, 175, 350, 230, 330, 220, 320, 200,  345, 215, 335,
                    175, 250, 175, 240, 180, fill='limeGreen')

def onMousePress(mouseX, mouseY):
    # Move the chameleon to the location of your mouse click.
    chameleon.centerX = mouseX
    chameleon.centerY = mouseY

    # Change the fill of chameleon based on mouseX value.
    if (mouseX < 150):
        chameleon.fill = 'blueViolet'
    elif (mouseX < 250):
        chameleon.fill = gradient('blueViolet', 'limeGreen', start='left')
    else:
        chameleon.fill = 'limeGreen'
",regular,1
2063,onKeyPress and onKeyRelease Checkpoint 4,4.2.1.1,"c = Circle(200, 200, 50, fill='plum')

def onKeyPress(key):
    if (key == 'up'):
        c.centerY -= 10
    elif (key == 'down'):
        c.centerY += 10

    # Edit onKeyPress so it works for left and right arrows as well
    # as up and down arrows.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

c = Circle(200, 200, 50, fill='plum')

def onKeyPress(key):
    # Edit onKeyPress so it works for left and right arrows as well
    # as up and down arrows.

    if (key == 'up'):
        c.centerY -= 10
    elif (key == 'down'):
        c.centerY += 10
    elif (key == 'left'):
        c.centerX -= 10
    elif (key == 'right'):
        c.centerX += 10
",regular,1
2069,Tug of war,4.2.2,"# background
Rect(0, 0, 150, 400, fill='red', opacity=10)
Rect(250, 0, 150, 400, fill='blue', opacity=10)

# left person body
Oval(65, 275, 60, 120, fill='salmon')
Circle(65, 200, 20, fill='fireBrick')

# right person body
Oval(335, 275, 55, 120, fill='dodgerBlue')
Circle(335, 200, 20, fill='blue')

# rope
rope = Line(25, 270, 375, 270)
ropeCenter = RegularPolygon(200, 275, 10, 3, fill='red', rotateAngle=180)

# arms
leftPersonArm = Line(60, 255, 100, 275, fill='fireBrick', lineWidth=8)
rightPersonArm = Line(340, 255, 300, 275, fill='blue', lineWidth=8)

# header
header = Label('Tug of War!', 200, 50, size=30)
Label('Press a to pull', 65, 110)
Label('Press l to pull', 335, 110)

def onKeyPress(key):
    # Reset the header.
    header.value = 'Tug of War!'

    # Depending on the key pressed, pull the rope and move the arm.
    # If a key other than a or l is pressed, change the header value.
    ### Place Your Code Here ###

    # Check if either side wins and change the header value accordingly.
    ### Place Your Code Here ###

def onKeyRelease(key):
    # Move the arm back to original position.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 150, 400, fill='red', opacity=10)
Rect(250, 0, 150, 400, fill='blue', opacity=10)

# left person body
Oval(65, 275, 60, 120, fill='salmon')
Circle(65, 200, 20, fill='fireBrick')

# right person body
Oval(335, 275, 55, 120, fill='dodgerBlue')
Circle(335, 200, 20, fill='blue')

# rope
rope = Line(25, 270, 375, 270)
ropeCenter = RegularPolygon(200, 275, 10, 3, fill='red', rotateAngle=180)

# arms
leftPersonArm = Line(60, 255, 100, 275, fill='fireBrick', lineWidth=8)
rightPersonArm = Line(340, 255, 300, 275, fill='blue', lineWidth=8)

# header
header = Label('Tug of War!', 200, 50, size=30)
Label('Press a to pull', 65, 110)
Label('Press l to pull', 335, 110)

def onKeyPress(key):
    # Reset the header.
    header.value = 'Tug of War!'

    # Depending on the key pressed, pull the rope and move the arm.
    # If a key other than a or l is pressed, change the header value.
    if (key == 'a'):
        ropeCenter.centerX -= 10
        rope.centerX -= 10
        leftPersonArm.centerX -= 10
    elif (key == 'l'):
        ropeCenter.centerX += 10
        rope.centerX += 10
        rightPersonArm.centerX += 10
    else:
        header.value = 'Wrong Key!'

    # Check if either side wins and change the header value accordingly.
    if (ropeCenter.centerX < 150):
        header.value = 'Red wins!'
    elif (ropeCenter.centerX > 250):
        header.value = 'Blue wins!'

def onKeyRelease(key):
    # Move the arm back to original position.
    if (key == 'a'):
        leftPersonArm.centerX += 10
    elif (key == 'l'):
        rightPersonArm.centerX -= 10
",regular,2
2068,Essay writer,4.2.2,"app.background = gradient('midnightBlue', 'royalBlue', start='top')

Rect(50, 10, 300, 380, fill=gradient('whiteSmoke', 'white', start='top'))
essay = Line(200, 20, 200, 30, lineWidth=250, dashes=True)

pageNumber = Label(1, 335, 375, size=20)

def onKeyPress(key):
    # On any key press, the essay should get longer.
    # If you reach the end of the page, go to a new page.
    ### (HINT: To go to a new page, modify essay to the shortest value
    #          and increase the pageNumber.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('midnightBlue', 'royalBlue', start='top')

Rect(50, 10, 300, 380, fill=gradient('whiteSmoke', 'white', start='top'))
essay = Line(200, 20, 200, 30, lineWidth=250, dashes=True)

pageNumber = Label(1, 335, 375, size=20)

def onKeyPress(key):
    # On any key press, the essay should get longer.
    # If you reach the end of the page, go to a new page.
    essay.y2 += 10
    if (essay.y2 > 380):
        essay.y2 = 30
        pageNumber.value += 1
",regular,1
2065,Dancing stick figure,4.2.2,"app.background = gradient('azure', 'lightBlue', 'blue')

# face and body
Circle(200, 135, 25)
Line(200, 160, 200, 240)

# upper arms
leftArm = Line(200, 185, 150, 175)
rightArm = Line(200, 185, 250, 175)

# legs
Line(200, 240, 230, 300)
Line(200, 240, 170, 300)

def toggleLeftArm():
    # Move the left arm down if it is currently up, and up if it is currently down.
    if (leftArm.y2 == 125):
        leftArm.y2 = 175
    else:
        leftArm.y2 = 125

def toggleRightArm():
    # Move the right arm down if it is currently up, and up if it is currently down.
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    # On left and right key press, call the corresponding helper function.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('azure', 'lightBlue', 'blue')

# face and body
Circle(200, 135, 25)
Line(200, 160, 200, 240)

# upper arms
leftArm = Line(200, 185, 150, 175)
rightArm = Line(200, 185, 250, 175)

# legs
Line(200, 240, 230, 300)
Line(200, 240, 170, 300)

def toggleLeftArm():
    # Move the left arm down if it is currently up, and up if it is currently down.
    if (leftArm.y2 == 125):
        leftArm.y2 = 175
    else:
        leftArm.y2 = 125

def toggleRightArm():
    # Move the right arm down if it is currently up, and up if it is currently down.
    if (rightArm.y2 == 125):
        rightArm.y2 = 175
    else:
        rightArm.y2 = 125

def onKeyPress(key):
    # On left and right key press, call the corresponding helper function.
    if (key == 'left'):
        toggleLeftArm()
    elif (key == 'right'):
        toggleRightArm()
",regular,1
2064,Flapping wings,4.2.2,"app.background = gradient('lightSkyBlue', 'deepSkyBlue', start='top')

# clouds
Circle(33, 60, 20, fill='white', border='gainsboro')
Circle(50, 40, 20, fill='white', border='gainsboro')
Circle(67, 60, 30, fill='white', border='gainsboro')
Rect(30, 45, 50, 30, fill='white')
Circle(183, 100, 30, fill='white', border='gainsboro')
Circle(200, 80, 20, fill='white', border='gainsboro')
Circle(217, 100, 30, fill='white', border='gainsboro')
Rect(180, 75, 40, 40, fill='white')
Circle(333, 300, 20, fill='white', border='gainsboro')
Circle(350, 280, 30, fill='white', border='gainsboro')
Circle(367, 300, 30, fill='white', border='gainsboro')
Rect(325, 270, 50, 40, fill='white')

# bird body
Polygon(145, 215, 110, 210, 145, 225, fill='salmon')
Polygon(145, 220, 110, 215, 145, 230, fill='salmon')
Line(170, 245, 160, 255, fill='gold', lineWidth=3)
Line(170, 245, 165, 260, fill='gold', lineWidth=3)
Oval(190, 250, 100, 65, fill='crimson', align='bottom')
Oval(190, 250, 80, 40, fill='salmon', align='bottom')
Circle(220, 200, 12, border='white', borderWidth=7)
Polygon(235, 210, 235, 215, 270, 210, fill='gold')
Polygon(235, 215, 270, 210, 235, 220, fill='goldenrod')

# bird wings
upWing = Polygon(170, 220, 185, 210, 130, 170, fill='lightSalmon')
downWing = Polygon(160, 220, 185, 210, 150, 255, fill='lightSalmon')
downWing.visible = False

def onKeyPress(key):
    # If spacebar is pressed, hide the upwards wing and show the downwards one.
    ### Place Your Code Here ###
    pass

def onKeyRelease(key):
    # If spacebar is released, do the opposite of when it is pressed.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightSkyBlue', 'deepSkyBlue', start='top')

# clouds
Circle(33, 60, 20, fill='white', border='gainsboro')
Circle(50, 40, 20, fill='white', border='gainsboro')
Circle(67, 60, 30, fill='white', border='gainsboro')
Rect(30, 45, 50, 30, fill='white')
Circle(183, 100, 30, fill='white', border='gainsboro')
Circle(200, 80, 20, fill='white', border='gainsboro')
Circle(217, 100, 30, fill='white', border='gainsboro')
Rect(180, 75, 40, 40, fill='white')
Circle(333, 300, 20, fill='white', border='gainsboro')
Circle(350, 280, 30, fill='white', border='gainsboro')
Circle(367, 300, 30, fill='white', border='gainsboro')
Rect(325, 270, 50, 40, fill='white')

# bird body
Polygon(145, 215, 110, 210, 145, 225, fill='salmon')
Polygon(145, 220, 110, 215, 145, 230, fill='salmon')
Line(170, 245, 160, 255, fill='gold', lineWidth=3)
Line(170, 245, 165, 260, fill='gold', lineWidth=3)
Oval(190, 250, 100, 65, fill='crimson', align='bottom')
Oval(190, 250, 80, 40, fill='salmon', align='bottom')
Circle(220, 200, 12, border='white', borderWidth=7)
Polygon(235, 210, 235, 215, 270, 210, fill='gold')
Polygon(235, 215, 270, 210, 235, 220, fill='goldenrod')

# bird wings
upWing = Polygon(170, 220, 185, 210, 130, 170, fill='lightSalmon')
downWing = Polygon(160, 220, 185, 210, 150, 255, fill='lightSalmon')
downWing.visible = False

def onKeyPress(key):
    # If spacebar is pressed, hide the upwards wing and show the downwards one.
    if (key == 'space'):
        upWing.visible = False
        downWing.visible = True

def onKeyRelease(key):
    # If spacebar is released, do the opposite of when it is pressed.
    if (key == 'space'):
        downWing.visible = False
        upWing.visible = True
",regular,1
2066,Caption the worm,4.2.2,"app.background = 'mediumAquamarine'

# apple
Oval(215, 70, 50, 20, fill='forestGreen', rotateAngle=-45)
Oval(175, 145, 100, 150, fill='fireBrick', rotateAngle=-15)
Oval(225, 145, 100, 150, fill='fireBrick', rotateAngle=15)
Oval(150, 140, 40, 100, fill='white', rotateAngle=-10)
Oval(155, 140, 40, 100, fill='fireBrick', rotateAngle=-10)

# worm
Circle(260, 140, 30, fill='mediumAquamarine')
Oval(235, 140, 10, 20, fill='mediumSeaGreen')
Oval(245, 145, 10, 20, fill='lightGreen', rotateAngle=-10)
Oval(255, 140, 10, 20, fill='mediumSeaGreen', rotateAngle=10)
Oval(265, 145, 10, 20, fill='lightGreen', rotateAngle=-10)
Oval(275, 140, 10, 20, fill='mediumSeaGreen', rotateAngle=-20)
Line(285, 125, 280, 115, fill='paleGoldenrod')
Line(280, 115, 275, 120, fill='paleGoldenrod')
Line(295, 125, 300, 115, fill='paleGoldenrod')
Line(300, 115, 305, 120, fill='paleGoldenrod')
Circle(290, 130, 10, fill='forestGreen')
Circle(285, 125, 2)
Circle(295, 125, 2)
Circle(290, 133, 3, fill=None, border='black')

cursor = Label('|', 20, 260, fill='white', size=40)

def onKeyPress(key):
    # When the key is not 'space', draw a new label using the key where
    # the text cursor is.
    ### Place Your Code Here ###

    # Move the cursor.
    ### (HINT: If the new centerX of cursor is greater than 380, move it to
    #          the next line and set centerX back to the beginning of the line.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'mediumAquamarine'

# apple
Oval(215, 70, 50, 20, fill='forestGreen', rotateAngle=-45)
Oval(175, 145, 100, 150, fill='fireBrick', rotateAngle=-15)
Oval(225, 145, 100, 150, fill='fireBrick', rotateAngle=15)
Oval(150, 140, 40, 100, fill='white', rotateAngle=-10)
Oval(155, 140, 40, 100, fill='fireBrick', rotateAngle=-10)

# worm
Circle(260, 140, 30, fill='mediumAquamarine')
Oval(235, 140, 10, 20, fill='mediumSeaGreen')
Oval(245, 145, 10, 20, fill='lightGreen', rotateAngle=-10)
Oval(255, 140, 10, 20, fill='mediumSeaGreen', rotateAngle=10)
Oval(265, 145, 10, 20, fill='lightGreen', rotateAngle=-10)
Oval(275, 140, 10, 20, fill='mediumSeaGreen', rotateAngle=-20)
Line(285, 125, 280, 115, fill='paleGoldenrod')
Line(280, 115, 275, 120, fill='paleGoldenrod')
Line(295, 125, 300, 115, fill='paleGoldenrod')
Line(300, 115, 305, 120, fill='paleGoldenrod')
Circle(290, 130, 10, fill='forestGreen')
Circle(285, 125, 2)
Circle(295, 125, 2)
Circle(290, 133, 3, fill=None, border='black')

cursor = Label('|', 20, 260, fill='white', size=40)

def onKeyPress(key):
    # When the key is not 'space', draw a new label using the key where
    # the text cursor is.
    if (key != 'space'):
        Label(key, cursor.centerX, cursor.centerY, fill='white', size=40)

    # Move the cursor.
    cursor.centerX += 30
    if (cursor.centerX > 380):
        cursor.centerY += 40
        cursor.centerX = 20
",regular,2
2067,Solar eclipse,4.2.2,"app.background = 'powderBlue'
skyMask = Rect(0, 0, 400, 400, opacity=0)

sun = Circle(200, 200, 80, fill=gradient('yellow', 'gold'))
sunMask = Circle(200, 200, 80, fill='orangeRed', opacity=0)

moon = Circle(0, 200, 78, fill=gradient('grey', 'powderBlue', start='left'))
moonMask = Circle(0, 200, 78, opacity=0)

ground = Oval(200, 400, 1500, 1000, fill='darkGreen', align='top')

def moveMoon():
    # Move the moon and its mask.
    ### (HINT: Check the position, press the 'space' key, and then check
    #          the position again to see how much it should change by.)
    ### Place Your Code Here ###

    # If the moon's center value is off the canvas, set the moon and moonMask
    # back to their initial x-values and set all of the masks' opacities to 0.
    ### Place Your Code Here ###
    pass

def updateMasks():
    # Decrease the opacities of the masks if the moon is to the right of the
    # sun. Otherwise, if the moon has an x-coordinate larger than 0,
    # increase the opacities. Also, rotate the moon so that the light side of
    # the gradient is always on the sun side.
    ### (HINT: Use a similar technique as with the moon position to determine
    #          how much to change the opacities!)
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    # When the space key is pressed, move the moon and update the masks. When the
    # up or down arrow keys are pressed, move the ground up or down appropriately.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'powderBlue'
skyMask = Rect(0, 0, 400, 400, opacity=0)

sun = Circle(200, 200, 80, fill=gradient('yellow', 'gold'))
sunMask = Circle(200, 200, 80, fill='orangeRed', opacity=0)

moon = Circle(0, 200, 78, fill=gradient('grey', 'powderBlue', start='left'))
moonMask = Circle(0, 200, 78, opacity=0)

ground = Oval(200, 400, 1500, 1000, fill='darkGreen', align='top')

def moveMoon():
    # Move the moon and its mask.
    moon.centerX += 20
    moonMask.centerX += 20

    # If the moon's center value is off the canvas, set the moon and moonMask
    # back to their initial x-values and set all of the masks' opacities to 0.
    if (moon.centerX > 400):
        moon.centerX = 0
        moonMask.centerX = 0
        skyMask.opacity = 0
        sunMask.opacity = 0
        moonMask.opacity = 0

def updateMasks():
    # Decrease the opacities of the masks if the moon is to the right of the
    # sun. Otherwise, if the moon has an x-coordinate larger than 0,
    # increase the opacities. Also, rotate the moon so that the light side of
    # the gradient is always on the sun side.
    if (moon.centerX > 200):
        skyMask.opacity -= 10
        sunMask.opacity -= 10
        moonMask.opacity -= 10
        moon.rotateAngle = 180
    elif (moon.centerX > 0):
        skyMask.opacity += 10
        sunMask.opacity += 10
        moonMask.opacity += 10
        moon.rotateAngle = 0
    else:
        moon.rotateAngle = 0

def onKeyPress(key):
    # When the space key is pressed, move the moon and update the masks. When the
    # up or down arrow keys are pressed, move the ground up or down appropriately.
    if (key == 'space'):
        moveMoon()
        updateMasks()
    elif (key == 'up'):
        ground.centerY -= 5
    elif (key == 'down'):
        ground.centerY += 5
",regular,3
2071,Mirrored polygons,4.3.3,"app.background = 'cornflowerBlue'

Line(200, 0, 200, 400, fill='silver', lineWidth=400, opacity=30, dashes=(1, 20))
Line(0, 200, 400, 200, fill='silver', lineWidth=400, opacity=30, dashes=(1, 20))

# divider
Line(200, 0, 200, 400, fill='white', dashes=True)

# left polygon
greenPolygon = Polygon(fill='lightGreen', border='black')

# right polygon
pinkPolygon = Polygon(fill='pink', border='black')

def onMousePress(mouseX, mouseY):
    # When the mouse is clicked on the left side, add a point to the green
    # polygon. Also, add a reflecting point to the pink polygon.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'cornflowerBlue'

Line(200, 0, 200, 400, fill='silver', lineWidth=400, opacity=30, dashes=(1, 20))
Line(0, 200, 400, 200, fill='silver', lineWidth=400, opacity=30, dashes=(1, 20))

# divider
Line(200, 0, 200, 400, fill='white', dashes=True)

# left polygon
greenPolygon = Polygon(fill='lightGreen', border='black')

# right polygon
pinkPolygon = Polygon(fill='pink', border='black')

def onMousePress(mouseX, mouseY):
    # When the mouse is clicked on the left side, add a point to the green
    # polygon. Also, add a reflecting point to the pink polygon.
    if (mouseX < 200):
        greenPolygon.addPoint(mouseX, mouseY)
        pinkPolygon.addPoint(400 - mouseX, mouseY)
",regular,1
2072,Connect the dots,4.3.3,"app.background = gradient('deepSkyBlue', 'pink', start='top')
Rect(0, 235, 400, 165,
     fill=gradient('darkGreen', 'mediumTurquoise', start='bottom'))

# legs, chest, and tail
Polygon(180, 305, 185, 320, 200, 265, 180, 250, fill='orangeRed', border='black')
Polygon(285, 305, 295, 325, 310, 245, 280, 245, fill='orangeRed', border='black')
Polygon(390, 65, 325, 95, 340, 110, 360, 105, 355, 125, 370, 130,
        fill='floralWhite', border='black')
Polygon(85, 170, 120, 160, 190, 175, 135, 260, fill='floralWhite', border='black')

# Define a polygon to add points to.
### Modify Your Code Here ###
# connect =

# dots
Circle(190, 175, 3)
Label('0, 9, 25', 195, 165, bold=True, align='left')
Circle(120, 160, 3)
Label('1', 120, 170, bold=True)
Circle(85, 170, 3)
Label('2', 75, 170, bold=True)
Circle(85, 110, 3)
Label('3', 95, 110, bold=True)
Circle(70, 40, 3)
Label('4', 80, 40, bold=True)
Circle(120, 75, 3)
Label('5', 130, 75, bold=True)
Circle(140, 80, 3)
Label('6', 150, 80, bold=True)
Circle(195, 50, 3)
Label('7', 205, 50, bold=True)
Circle(175, 105, 3)
Label('8', 185, 105, bold=True)
Circle(135, 260, 3)
Label('10', 125, 260, bold=True)
Circle(170, 340, 3)
Label('11', 180, 340, bold=True)
Circle(190, 260, 3)
Label('12', 200, 255, bold=True)
Circle(220, 270, 3)
Label('13', 220, 280, bold=True)
Circle(250, 260, 3)
Label('14', 260, 260, bold=True)
Circle(280, 340, 3)
Label('15', 290, 340, bold=True)
Circle(300, 260, 3)
Label('16', 315, 260, bold=True)
Circle(320, 225, 3)
Label('17', 330, 225, bold=True)
Circle(300, 180, 3)
Label('18, 24', 310, 180, bold=True, align='left')
Circle(325, 95, 3)
Label('19', 325, 85, bold=True)
Circle(340, 110, 3)
Label('20', 340, 120, bold=True)
Circle(360, 105, 3)
Label('21', 360, 95, bold=True)
Circle(355, 125, 3)
Label('22', 355, 135, bold=True)
Circle(370, 130, 3)
Label('23', 370, 140, bold=True)

# face
Line(110, 130, 140, 150)
Line(155, 125, 153, 150)
Oval(145, 146, 20, 12)
Circle(110, 108, 12, fill='white')
Circle(115, 108, 6)
Circle(155, 108, 12, fill='white')
Circle(160, 108, 6)

def onMousePress(mouseX, mouseY):
    # When the mouse is pressed, add a point to connect to the polygon.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'pink', start='top')
Rect(0, 235, 400, 165,
     fill=gradient('darkGreen', 'mediumTurquoise', start='bottom'))

# legs, chest, and tail
Polygon(180, 305, 185, 320, 200, 265, 180, 250, fill='orangeRed', border='black')
Polygon(285, 305, 295, 325, 310, 245, 280, 245, fill='orangeRed', border='black')
Polygon(390, 65, 325, 95, 340, 110, 360, 105, 355, 125, 370, 130,
        fill='floralWhite', border='black')
Polygon(85, 170, 120, 160, 190, 175, 135, 260, fill='floralWhite', border='black')

# Define a polygon to add points to.
connect = Polygon(fill='orangeRed', border='black')

# dots
Circle(190, 175, 3)
Label('0, 9, 25', 195, 165, bold=True, align='left')
Circle(120, 160, 3)
Label('1', 120, 170, bold=True)
Circle(85, 170, 3)
Label('2', 75, 170, bold=True)
Circle(85, 110, 3)
Label('3', 95, 110, bold=True)
Circle(70, 40, 3)
Label('4', 80, 40, bold=True)
Circle(120, 75, 3)
Label('5', 130, 75, bold=True)
Circle(140, 80, 3)
Label('6', 150, 80, bold=True)
Circle(195, 50, 3)
Label('7', 205, 50, bold=True)
Circle(175, 105, 3)
Label('8', 185, 105, bold=True)
Circle(135, 260, 3)
Label('10', 125, 260, bold=True)
Circle(170, 340, 3)
Label('11', 180, 340, bold=True)
Circle(190, 260, 3)
Label('12', 200, 255, bold=True)
Circle(220, 270, 3)
Label('13', 220, 280, bold=True)
Circle(250, 260, 3)
Label('14', 260, 260, bold=True)
Circle(280, 340, 3)
Label('15', 290, 340, bold=True)
Circle(300, 260, 3)
Label('16', 315, 260, bold=True)
Circle(320, 225, 3)
Label('17', 330, 225, bold=True)
Circle(300, 180, 3)
Label('18, 24', 310, 180, bold=True, align='left')
Circle(325, 95, 3)
Label('19', 325, 85, bold=True)
Circle(340, 110, 3)
Label('20', 340, 120, bold=True)
Circle(360, 105, 3)
Label('21', 360, 95, bold=True)
Circle(355, 125, 3)
Label('22', 355, 135, bold=True)
Circle(370, 130, 3)
Label('23', 370, 140, bold=True)

# face
Line(110, 130, 140, 150)
Line(155, 125, 153, 150)
Oval(145, 146, 20, 12)
Circle(110, 108, 12, fill='white')
Circle(115, 108, 6)
Circle(155, 108, 12, fill='white')
Circle(160, 108, 6)

def onMousePress(mouseX, mouseY):
    # When the mouse is pressed, add a point to connect to the polygon.
    connect.addPoint(mouseX, mouseY)
",regular,2
2070,City skyline,4.3.3,"app.background = gradient(rgb(210, 105, 100), rgb(240, 210, 185), start='top')

mainBuilding = Polygon(110, 400, 290, 400, 290, 340, 280, 340, 280, 300, 250, 300,
                       250, 120, 230, 120, 230, 100, 210, 100, 210, 80, 205, 80,
                       200, 5, 195, 80, 190, 80, 190, 100, 170, 100, 170, 120,
                       150, 120, 150, 300, 120, 300, 120, 340, 110, 340,
                       fill=gradient(rgb(40, 25, 40), rgb(75, 55, 75),
                                     start='left'))

Star(350, 200, 50, 500, fill=gradient('papayaWhip', 'moccasin'), roundness=80)

def drawBuilding(centerX, height):
    Rect(centerX, height + 10, 60, 400 - height, align='top',
         fill=gradient(rgb(150, 95, 90), rgb(195, 110, 115), start='left'))
    Polygon(centerX, height - 50, centerX - 30, height + 10,
            centerX + 30, height + 10,
            fill=gradient(rgb(150, 95, 90), rgb(195, 110, 115), start='left'))

def onMousePress(mouseX, mouseY):
    # Draw a building behind the main building.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(210, 105, 100), rgb(240, 210, 185), start='top')

mainBuilding = Polygon(110, 400, 290, 400, 290, 340, 280, 340, 280, 300, 250, 300,
                       250, 120, 230, 120, 230, 100, 210, 100, 210, 80, 205, 80,
                       200, 5, 195, 80, 190, 80, 190, 100, 170, 100, 170, 120,
                       150, 120, 150, 300, 120, 300, 120, 340, 110, 340,
                       fill=gradient(rgb(40, 25, 40), rgb(75, 55, 75),
                                     start='left'))

Star(350, 200, 50, 500, fill=gradient('papayaWhip', 'moccasin'), roundness=80)

def drawBuilding(centerX, height):
    Rect(centerX, height + 10, 60, 400 - height, align='top',
         fill=gradient(rgb(150, 95, 90), rgb(195, 110, 115), start='left'))
    Polygon(centerX, height - 50, centerX - 30, height + 10,
            centerX + 30, height + 10,
            fill=gradient(rgb(150, 95, 90), rgb(195, 110, 115), start='left'))

def onMousePress(mouseX, mouseY):
    # Draw a building behind the main building.
    drawBuilding(mouseX, mouseY)
    mainBuilding.toFront()
",regular,1
2074,Meteorite display,4.3.5,"app.background = rgb(220, 215, 205)

# casing
Rect(50, 300, 300, 100, fill=rgb(55, 55, 55))
Rect(80, 315, 240, 30, fill='silver')
Label('DO NOT TOUCH', 200, 330, size=25)

meteorite = Polygon(150, 300, 120, 250, 140, 220, 170, 170, 210, 150, 260, 190,
                    270, 230, 300, 260, 280, 280, 240, 300,
                    fill=gradient(rgb(110, 185, 160), rgb(10, 50, 45),
                                  start='left-top'))
cover = Rect(50, 75, 300, 225, fill=gradient('white', 'azure', start='left-top'),
             opacity=20)

Rect(50, 75, 300, 275, fill=None, border=rgb(90, 80, 80))

alarm = Polygon(150, 0, 250, 0, 230, 40, 170, 40,
                fill=gradient('lightGrey', 'darkGrey'))
light = Polygon(170, 40, 230, 40, 320, 300, 80, 300, fill='lightYellow',
                opacity=20)
alarmCover = Rect(0, 0, 400, 400, fill='red', opacity=50, visible=False)
alarmLights = Star(200, 0, 500, 10, fill='white', opacity=50, visible=False,
                   roundness=20)

hand = Oval(25, 50, 50, 50, fill='whiteSmoke')

def onMouseMove(mouseX, mouseY):
    hand.centerX = mouseX
    hand.centerY = mouseY

    # If the hand (cursor) intersects the meteorite, show the alarm and rotate
    # the alarm lights. Otherwise, restore the original background.
    ### (HINT: The alarm light rotates by a 5 degree angle.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(220, 215, 205)

# casing
Rect(50, 300, 300, 100, fill=rgb(55, 55, 55))
Rect(80, 315, 240, 30, fill='silver')
Label('DO NOT TOUCH', 200, 330, size=25)

meteorite = Polygon(150, 300, 120, 250, 140, 220, 170, 170, 210, 150, 260, 190,
                    270, 230, 300, 260, 280, 280, 240, 300,
                    fill=gradient(rgb(110, 185, 160), rgb(10, 50, 45),
                                  start='left-top'))
cover = Rect(50, 75, 300, 225, fill=gradient('white', 'azure', start='left-top'),
             opacity=20)

Rect(50, 75, 300, 275, fill=None, border=rgb(90, 80, 80))

alarm = Polygon(150, 0, 250, 0, 230, 40, 170, 40,
                fill=gradient('lightGrey', 'darkGrey'))
light = Polygon(170, 40, 230, 40, 320, 300, 80, 300, fill='lightYellow',
                opacity=20)
alarmCover = Rect(0, 0, 400, 400, fill='red', opacity=50, visible=False)
alarmLights = Star(200, 0, 500, 10, fill='white', opacity=50, visible=False,
                   roundness=20)

hand = Oval(25, 50, 50, 50, fill='whiteSmoke')

def onMouseMove(mouseX, mouseY):
    hand.centerX = mouseX
    hand.centerY = mouseY

    # If the hand (cursor) intersects the meteorite, show the alarm and rotate
    # the alarm lights. Otherwise, restore the original background.
    if (hand.hitsShape(meteorite) == True):
        app.background = 'fireBrick'
        alarmCover.visible = True
        alarmLights.visible = True
        light.visible = False
        alarmLights.rotateAngle += 5
    else:
        app.background = rgb(220, 215, 205)
        alarmCover.visible = False
        alarmLights.visible = False
        light.visible = True
",regular,1
2075,Porcupine,4.3.5,"app.background = 'cornflowerBlue'

spikes = Star(200, 335, 130, 30, fill='saddleBrown', roundness=80)

# body
Circle(140, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Circle(260, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Oval(200, 310, 160, 110, fill='tan', align='top')

# eyes
Circle(175, 360, 7)
Circle(225, 360, 7)

# nose
RegularPolygon(200, 390, 15, 3, rotateAngle=180)

leftEyebrow = Line(155, 345, 170, 345, rotateAngle=-15)
rightEyebrow = Line(245, 345, 230, 345, rotateAngle=15)

def onMouseMove(mouseX, mouseY):
    # If the mouse is on the porcupine, puff out the spikes and change the
    # eyebrows.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'cornflowerBlue'

spikes = Star(200, 335, 130, 30, fill='saddleBrown', roundness=80)

# body
Circle(140, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Circle(260, 330, 15, fill='navajoWhite', border='tan', borderWidth=5)
Oval(200, 310, 160, 110, fill='tan', align='top')

# eyes
Circle(175, 360, 7)
Circle(225, 360, 7)

# nose
RegularPolygon(200, 390, 15, 3, rotateAngle=180)

leftEyebrow = Line(155, 345, 170, 345, rotateAngle=-15)
rightEyebrow = Line(245, 345, 230, 345, rotateAngle=15)

def onMouseMove(mouseX, mouseY):
    # If the mouse is on the porcupine, puff out the spikes and change the
    # eyebrows.
    if (spikes.contains(mouseX, mouseY) == True):
        spikes.radius = 250
        spikes.roundness = 40
        leftEyebrow.rotateAngle = 30
        rightEyebrow.rotateAngle = -30
    else:
        spikes.radius = 130
        spikes.roundness = 80
        leftEyebrow.rotateAngle = -15
        rightEyebrow.rotateAngle = 15
",regular,2
2076,Maze,4.3.5,"app.background = 'darkSlateBlue'

path = Polygon(150, 230, 150, 380, 20, 380, 20, 250, 0, 250, 0, 200, 70, 200,
               70, 310, 90, 310, 90, 180, 20, 180, 20, 20, 130, 20, 130, 120,
               150, 120, 150, 20, 300, 20, 300, 220, 320, 220, 320, 20, 380, 20,
               380, 380, 170, 380, 170, 250, 220, 250, 220, 320, 330, 320,
               330, 300, 240, 300, 240, 100, 220, 100, 220, 230, fill='white')

Polygon(0, 220, 0, 230, 20, 230, 20, 240, 35, 225, 20, 210, 20, 220,
        fill='deepSkyBlue')
greenStar = Star(195, 280, 20, 5, fill='springGreen')

def drawEndScreen(boxColor, message, messageColor):
    Rect(55, 155, 290, 90, fill=boxColor, border=messageColor, borderWidth=10)
    Label(message, 200, 200, fill=messageColor, size=40)
    app.stop()

def onMouseMove(mouseX, mouseY):
    # If the mouse is not on path, you lose the game.
    # If you reach the green star, you win the game.
    ### (HINT: If you win or lose the game, the game should end!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'darkSlateBlue'

path = Polygon(150, 230, 150, 380, 20, 380, 20, 250, 0, 250, 0, 200, 70, 200,
               70, 310, 90, 310, 90, 180, 20, 180, 20, 20, 130, 20, 130, 120,
               150, 120, 150, 20, 300, 20, 300, 220, 320, 220, 320, 20, 380, 20,
               380, 380, 170, 380, 170, 250, 220, 250, 220, 320, 330, 320,
               330, 300, 240, 300, 240, 100, 220, 100, 220, 230, fill='white')

Polygon(0, 220, 0, 230, 20, 230, 20, 240, 35, 225, 20, 210, 20, 220,
        fill='deepSkyBlue')
greenStar = Star(195, 280, 20, 5, fill='springGreen')

def drawEndScreen(boxColor, message, messageColor):
    Rect(55, 155, 290, 90, fill=boxColor, border=messageColor, borderWidth=10)
    Label(message, 200, 200, fill=messageColor, size=40)
    app.stop()

def onMouseMove(mouseX, mouseY):
    # If the mouse is not on path, you lose the game.
    # If you reach the gree star, you win the game.
    if (path.contains(mouseX, mouseY) == False):
        drawEndScreen('lavender', 'GAME OVER!', 'red')
    elif (greenStar.contains(mouseX, mouseY) == True):
        drawEndScreen('honeydew', 'YOU WIN!', 'green')
",regular,3
2073,Seasonal tree,4.3.5,"app.background = gradient('deepSkyBlue', 'skyBlue', start='top')

# labels
springLabel = Label('Spring', 10, 320, fill='lightPink', size=30, align='left')
summerLabel = Label('Summer', 10, 360, fill='forestGreen', size=30, align='left')
fallLabel = Label('Fall', 390, 320, fill='darkOrange', size=30, align='right')
winterLabel = Label('Winter', 390, 360, fill='white', size=30, align='right')

leaves = Star(200, 150, 150, 16, fill='forestGreen', roundness=90)

# tree trunk and limbs
Polygon(200, 100, 150, 400, 250, 400, fill='saddleBrown')
Polygon(200, 300, 200, 250, 300, 175, fill='saddleBrown')
Polygon(200, 300, 200, 250, 100, 150, fill='saddleBrown')
Polygon(200, 200, 200, 175, 125, 100, fill='saddleBrown')
Polygon(200, 250, 200, 200, 275, 100, fill='saddleBrown')

ground = Polygon(115, 400, 140, 380, 170, 390, 210, 385, 235, 390, 275, 390,
                 295, 400, visible=False)

def onMousePress(mouseX, mouseY):
    # If a label is clicked, make the color of the leaves match the color of
    # that label. Change the leaves and ground visibility when needed.
    ### (HINT: Use contains to check what label you clicked.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'skyBlue', start='top')

# labels
springLabel = Label('Spring', 10, 320, fill='lightPink', size=30, align='left')
summerLabel = Label('Summer', 10, 360, fill='forestGreen', size=30, align='left')
fallLabel = Label('Fall', 390, 320, fill='darkOrange', size=30, align='right')
winterLabel = Label('Winter', 390, 360, fill='white', size=30, align='right')

leaves = Star(200, 150, 150, 16, fill='forestGreen', roundness=90)

# tree trunk and limbs
Polygon(200, 100, 150, 400, 250, 400, fill='saddleBrown')
Polygon(200, 300, 200, 250, 300, 175, fill='saddleBrown')
Polygon(200, 300, 200, 250, 100, 150, fill='saddleBrown')
Polygon(200, 200, 200, 175, 125, 100, fill='saddleBrown')
Polygon(200, 250, 200, 200, 275, 100, fill='saddleBrown')

ground = Polygon(115, 400, 140, 380, 170, 390, 210, 385, 235, 390, 275, 390,
                 295, 400, visible=False)

def onMousePress(mouseX, mouseY):
    # If a label is clicked, make the color of the leaves match the color of
    # that label. Change the leaves and ground visibility when needed.
    if (springLabel.contains(mouseX, mouseY) == True):
        leaves.fill = 'lightPink'
        ground.visible = False
    elif (summerLabel.contains(mouseX, mouseY) == True):
        leaves.fill = 'forestGreen'
        ground.visible = False
    elif (fallLabel.contains(mouseX, mouseY) == True):
        leaves.fill = 'darkOrange'
        ground.visible = True
        ground.fill = 'fireBrick'
    elif (winterLabel.contains(mouseX, mouseY) == True):
        leaves.fill = 'white'
        ground.visible = True
        ground.fill = 'white'
",regular,1
2083,Rotating stars,4.4,"app.background = gradient('azure', 'lavenderBlush', start='top')

s1 = Star(200, 125, 25, 5, fill=None, border='skyBlue', borderWidth=10)
s2 = Star(275, 250, 25, 5, fill=None, border='crimson', borderWidth=10)
s3 = Star(125, 250, 25, 5, fill=None, border='gold', borderWidth=10)

# Indicate size is growing.
s1.isGrowing = True
s2.isGrowing = True
s3.isGrowing = True

def rotateAndResizeStar(s):
    # When the star is growing, increase the radius and rotate it clockwise.
    # Otherwise, decrease the radius and rotate it counter-clockwise.
    ### (HINT: Look at the onMouseMove function. This helper function is called
    #          from there three times, once with each of the three stars!)
    ### Place Your Code Here ###

    # When the radius of the star is at most 5 or at least 200, change the
    # custom property appropriately.
    ### Place Your Code Here ###
    pass

def onMouseMove(mouseX, mouseY):
    rotateAndResizeStar(s1)
    rotateAndResizeStar(s2)
    rotateAndResizeStar(s3)

def onKeyPress(key):
    # This is for testing purposes - DO NOT change this function.
    if (key == 'a'):
        s1.radius = 195
        s2.radius = 195
        s3.radius = 195
    if (key == 'b'):
        s1.radius = 10
        s2.radius = 10
        s3.radius = 10
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('azure', 'lavenderBlush', start='top')

s1 = Star(200, 125, 25, 5, fill=None, border='skyBlue', borderWidth=10)
s2 = Star(275, 250, 25, 5, fill=None, border='crimson', borderWidth=10)
s3 = Star(125, 250, 25, 5, fill=None, border='gold', borderWidth=10)

# Indicate size is growing.
s1.isGrowing = True
s2.isGrowing = True
s3.isGrowing = True

def rotateAndResizeStar(s):
    # When the star is growing, increase the radius and rotate it clockwise.
    # Otherwise, decrease the radius and rotate it counter-clockwise.
    if (s.isGrowing == True):
        s.radius += 5
        s.rotateAngle += 5
    else:
        s.radius -= 5
        s.rotateAngle -= 5

    # When the radius of the star is at most 5 or at least 200, change the
    # custom property appropriately.
    if (s.radius <= 5):
        s.isGrowing = True
    elif (s.radius >= 200):
        s.isGrowing = False

def onMouseMove(mouseX, mouseY):
    rotateAndResizeStar(s1)
    rotateAndResizeStar(s2)
    rotateAndResizeStar(s3)

def onKeyPress(key):
    # This is for testing purposes - DO NOT change this function.
    if (key == 'a'):
        s1.radius = 195
        s2.radius = 195
        s3.radius = 195
    if (key == 'b'):
        s1.radius = 10
        s2.radius = 10
        s3.radius = 10
",regular,2
2084,Volcano,4.4,"app.background = gradient('skyBlue', rgb(235, 235, 235), start='top')

app.volcanoHasErupted = False

# volcano
lava = Oval(200, 120, 90, 20, fill=rgb(255, 200, 0), border='peru',
            borderWidth=4)
lava.green = 200

rock = Polygon(0, 400, 0, 380, 50, 340, 70, 300, 125, 225, 140, 180, 153, 120,
               175, 125, 200, 120, 220, 108, 235, 105, 247, 110, 255, 175, 270,
               210, 310, 250, 350, 325, 400, 375, 400, 400,
               fill=gradient('peru', 'sienna', start='top'))

# lava explosion
burst = Polygon(100, 0, 310, 0, 260, 30, 245, 60, 240, 110, 235, 105, 220,
                108, 200, 120, 175, 125, 160, 120, 150, 60, 130, 25,
                fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='bottom'),
                visible=False)

def drawSpill():
    Polygon(153, 120, 175, 125, 165, 195, 145, 260,
            80, 315, 125, 260, 150, 200, 155, 160,
            fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='top'))
    Polygon(200, 120, 220, 108, 230, 160, 230, 210,
            240, 240, 310, 345, 245, 280, 215, 225, 210, 160,
            fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='top'))
    Polygon(235, 105, 247, 110, 255, 175, 270, 210,
            310, 250, 255, 215, 240, 170, 240, 130,
            fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='top'))

def onMousePress(mouseX, mouseY):
    # Use rgb values and a provided custom property to change the fill of lava
    # at the top of the volcano so that it appears more red. Don't let any
    # value in the rgb become negative.
    ### (HINT: Decrease the value of green to make red more apparent!)
    ### (HINT: We defined a custom property that may be helpful.)
    ### Place Your Code Here ###

    # If there is no more green in the lava, the volcano should erupt if it
    # hasn't already. The volcano should only erupt once.
    ### (HINT: Use a provided app custom property to check if it has erupted.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('skyBlue', rgb(235, 235, 235), start='top')

app.volcanoHasErupted = False

# volcano
lava = Oval(200, 120, 90, 20, fill=rgb(255, 200, 0), border='peru',
            borderWidth=4)
lava.green = 200

rock = Polygon(0, 400, 0, 380, 50, 340, 70, 300, 125, 225, 140, 180, 153, 120,
               175, 125, 200, 120, 220, 108, 235, 105, 247, 110, 255, 175, 270,
               210, 310, 250, 350, 325, 400, 375, 400, 400,
               fill=gradient('peru', 'sienna', start='top'))

# lava explosion
burst = Polygon(100, 0, 310, 0, 260, 30, 245, 60, 240, 110, 235, 105, 220,
                108, 200, 120, 175, 125, 160, 120, 150, 60, 130, 25,
                fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='bottom'),
                visible=False)

def drawSpill():
    Polygon(153, 120, 175, 125, 165, 195, 145, 260,
            80, 315, 125, 260, 150, 200, 155, 160,
            fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='top'))
    Polygon(200, 120, 220, 108, 230, 160, 230, 210,
            240, 240, 310, 345, 245, 280, 215, 225, 210, 160,
            fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='top'))
    Polygon(235, 105, 247, 110, 255, 175, 270, 210,
            310, 250, 255, 215, 240, 170, 240, 130,
            fill=gradient(rgb(255, 200, 75), rgb(235, 10, 20), start='top'))

def onMousePress(mouseX, mouseY):
    # Decrease the green in the lava color until there is no green.
    if (lava.green > 0):
        lava.green -= 40
        lava.fill = rgb(255, lava.green, 0)
    # Otherwise, the volcano should erupt if it hasn't already.
    elif (app.volcanoHasErupted == False):
        burst.visible = True
        app.background = gradient('lightSlateGrey', 'lightGrey', start='top')
        drawSpill()
        app.volcanoHasErupted = True
",regular,3
2077,Cactus flowers,4.4,"app.background = gradient('dodgerBlue', 'deepSkyBlue', 'lightCyan', start='top')

cactusTop1 = Circle(200, 50, 40, fill='forestGreen', border='wheat', dashes=(5, 6))
cactusTop2 = Circle(200, 50, 25, fill='green', border='wheat', dashes=(4, 5))
cactusTop3 = Circle(200, 50, 10, fill='darkGreen', border='wheat', dashes=(3, 5))
cactus1 = Rect(160, 50, 80, 350, fill='forestGreen', border='wheat', dashes=(5, 6))
cactus2 = Rect(175, 50, 50, 350, fill='green', border='wheat', dashes=(4, 5))
cactus3 = Rect(190, 50, 20, 350, fill='darkGreen', border='wheat', dashes=(3, 5))
sand = Oval(200, 440, 500, 160, fill='darkKhaki')

def drawCactusArm(x, y):
    # Makes the top of the arm rounded.
    Circle(x, y - 40, 15, fill='green', border='wheat', dashes=(2, 5))
    Circle(x, y - 40, 8, fill='darkGreen', border='wheat', dashes=(4, 6))

    # Makes the elbow of the arm rounded.
    Circle(x, y, 15, fill='green', border='wheat', dashes=(2, 5))
    Circle(x, y, 7, fill='darkGreen', border='wheat', dashes=(4, 6))

    # Draws the horizontal part of the arm. Notice the alignment!
    if (x < 200):
        Rect(x + 5, y, 200 - x, 30, fill='green', border='wheat', dashes=(2, 5),
             align='left')
        Rect(x + 5, y, 200 - x, 14, fill='darkGreen', border='wheat',
             dashes=(4, 6), align='left')
    elif (x > 200):
        Rect(x - 5, y, x - 200, 30, fill='green', border='wheat', dashes=(2, 5),
             align='right')
        Rect(x - 5, y, x - 200, 14, fill='darkGreen', border='wheat',
             dashes=(4, 6), align='right')

    # Draws the vertical part of the arm.
    Rect(x - 15, y - 40, 30, 35, fill='green', border='wheat', dashes=(2, 5))
    Rect(x - 7, y - 40, 16, 35, fill='darkGreen', border='wheat', dashes=(4, 6))

def drawCactusFlower(x, y):
    # Here (x, y) is the center of the middle flower petal, 60 pixels above
    # the arm's elbow.
    Oval(x - 10, y, 12, 20, fill='hotPink', rotateAngle=-20)
    Oval(x + 10, y, 12, 20, fill='hotPink', rotateAngle=20)
    Oval(x, y, 15, 25, fill='purple')

def onMousePress(mouseX, mouseY):
    # Add a cactus arm and flower.
    # Make sure the cactus and sand is in front of the added arms.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('dodgerBlue', 'deepSkyBlue', 'lightCyan', start='top')

cactusTop1 = Circle(200, 50, 40, fill='forestGreen', border='wheat', dashes=(5, 6))
cactusTop2 = Circle(200, 50, 25, fill='green', border='wheat', dashes=(4, 5))
cactusTop3 = Circle(200, 50, 10, fill='darkGreen', border='wheat', dashes=(3, 5))
cactus1 = Rect(160, 50, 80, 350, fill='forestGreen', border='wheat', dashes=(5, 6))
cactus2 = Rect(175, 50, 50, 350, fill='green', border='wheat', dashes=(4, 5))
cactus3 = Rect(190, 50, 20, 350, fill='darkGreen', border='wheat', dashes=(3, 5))
sand = Oval(200, 440, 500, 160, fill='darkKhaki')

def drawCactusArm(x, y):
    # Makes the top of the arm rounded.
    Circle(x, y - 40, 15, fill='green', border='wheat', dashes=(2, 5))
    Circle(x, y - 40, 8, fill='darkGreen', border='wheat', dashes=(4, 6))

    # Makes the elbow of the arm rounded.
    Circle(x, y, 15, fill='green', border='wheat', dashes=(2, 5))
    Circle(x, y, 7, fill='darkGreen', border='wheat', dashes=(4, 6))

    # Draws the horizontal part of the arm. Notice the alignment!
    if (x < 200):
        Rect(x + 5, y, 200 - x, 30, fill='green', border='wheat', dashes=(2, 5),
             align='left')
        Rect(x + 5, y, 200 - x, 14, fill='darkGreen', border='wheat',
             dashes=(4, 6), align='left')
    elif (x > 200):
        Rect(x - 5, y, x - 200, 30, fill='green', border='wheat', dashes=(2, 5),
             align='right')
        Rect(x - 5, y, x - 200, 14, fill='darkGreen', border='wheat',
             dashes=(4, 6), align='right')

    # Draws the vertical part of the arm.
    Rect(x - 15, y - 40, 30, 35, fill='green', border='wheat', dashes=(2, 5))
    Rect(x - 7, y - 40, 16, 35, fill='darkGreen', border='wheat', dashes=(4, 6))

def drawCactusFlower(x, y):
    # Here (x, y) is the center of the middle flower petal, 60 pixels above
    # the arm's elbow.
    Oval(x - 10, y, 12, 20, fill='hotPink', rotateAngle=-20)
    Oval(x + 10, y, 12, 20, fill='hotPink', rotateAngle=20)
    Oval(x, y, 15, 25, fill='purple')

def onMousePress(mouseX, mouseY):
    # Add a cactus arm and flower.
    # Make sure the cactus and sand is in front of the added arms.
    drawCactusArm(mouseX, mouseY)
    drawCactusFlower(mouseX, mouseY - 60)

    cactusTop1.toFront()
    cactusTop2.toFront()
    cactusTop3.toFront()
    cactus1.toFront()
    cactus2.toFront()
    cactus3.toFront()
    sand.toFront()
",regular,1
2079,Day and night,4.4,"app.background = gradient('deepSkyBlue', 'lightBlue', start='top')

sun = Circle(200, 100, 50, fill='yellow')
moon = Circle(300, 100, 50, fill=gradient('gainsboro', 'white'), opacity=70,
              visible=False)
ground = Rect(0, 300, 400, 100, fill='mediumSeaGreen')

def changeFillsAndMoon(newSkyFill, newSunFill, newGroundFill, showMoon):
    app.background = newSkyFill
    sun.fill = newSunFill
    ground.fill = newGroundFill

    # Depending on the showMoon input parameter, change the visibility of the moon.
    ### Place Your Code Here ###

def onMouseMove(mouseX, mouseY):
    sun.centerX = mouseX
    sun.centerY = mouseY

    # Change the fill of the sky. Also change the moon's visibility if the
    # sun has set.
    ### (HINT: When it is night, the fill of the sun is None.)
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'lightBlue', start='top')

sun = Circle(200, 100, 50, fill='yellow')
moon = Circle(300, 100, 50, fill=gradient('gainsboro', 'white'), opacity=70,
              visible=False)
ground = Rect(0, 300, 400, 100, fill='mediumSeaGreen')

def changeFillsAndMoon(newSkyFill, newSunFill, newGroundFill, showMoon):
    app.background = newSkyFill
    sun.fill = newSunFill
    ground.fill = newGroundFill

    # Depending on the showMoon input parameter, change the visibility of the moon.
    if (showMoon == True):
        moon.visible = True
    else:
        moon.visible = False

def onMouseMove(mouseX, mouseY):
    sun.centerX = mouseX
    sun.centerY = mouseY

    # Change the fill of the sky. Also change the moon's visibility if the
    # sun has set.
    if (sun.top > ground.top):
        changeFillsAndMoon(gradient('black', 'midnightBlue', start='top'),
                           None, 'darkGreen', True)
    elif (sun.centerY > 250):
        changeFillsAndMoon(gradient('skyBlue', 'lightPink', start='top'),
                           'gold', 'seaGreen', False)
    elif (sun.centerY > 100):
        changeFillsAndMoon(gradient('deepSkyBlue', 'lightBlue', start='top'),
                           'yellow', 'mediumSeaGreen', False)
    else:
        changeFillsAndMoon('lightSkyBlue', 'yellow', 'mediumSeaGreen', False)
",regular,1
2080,Darts,4.4,"app.background = gradient('sienna', 'peru', start='top')
Line(0, 200, 400, 200, fill='saddleBrown', lineWidth=400, dashes=(3, 35))

# scoreboard
Rect(0, 365, 400, 35, fill='lightGrey', border='black')
Label('Your Score:', 220, 380, size=15, align='right')
score = Label(0, 230, 380, size=15, align='left')

# target
Line(155, 120, 200, 50, fill='white', lineWidth=5)
Line(245, 120, 200, 50, fill='white', lineWidth=5)
Circle(200, 54, 5, fill='darkSlateGray')
Circle(200, 180, 90, fill='white', border='black')
blueBoard = Circle(200, 180, 90, fill='dodgerBlue', border='black')
redBoard = Circle(200, 180, 60, fill='red', border='black')
yellowBoard = Circle(200, 180, 35, fill='yellow', border='black')
Label(30, 200, 195)
Label(20, 200, 225)
Label(10, 200, 255)

# additional targets on the side
Circle(50, 180, 90, fill='white', border='black', align='right')
Circle(45, 180, 88, fill='dodgerBlue', border='black', align='right')
Circle(350, 180, 90, fill='white', border='black', align='left')
Circle(355, 180, 88, fill='dodgerBlue', border='black', align='left')

def drawDart(x, y):
    # Here (x, y) is the center of the body of the dart. The point is 35 pixels
    # to the left of x.
    Polygon(x - 20, y - 2, x - 35, y, x - 20, y + 2)
    Oval(x, y, 50, 15, fill='mediumBlue')
    Polygon(x, y - 7, x + 5, y - 15, x + 25, y - 10, x + 24, y - 2, fill='white')
    Polygon(x, y + 7, x + 5, y + 15, x + 25, y + 10, x + 24, y + 2, fill='white')

def onMousePress(mouseX, mouseY):
    # Draw the dart so that its tip is where you clicked.
    ### Place Your Code Here ###

    # Depending on the dart location add different values to the score.
    # When the dart is thrown outside the board, subtract from the score.
    ### (HINT: The score cannot be negative.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('sienna', 'peru', start='top')
Line(0, 200, 400, 200, fill='saddleBrown', lineWidth=400, dashes=(3, 35))

# scoreboard
Rect(0, 365, 400, 35, fill='lightGrey', border='black')
Label('Your Score:', 220, 380, size=15, align='right')
score = Label(0, 230, 380, size=15, align='left')

# target
Line(155, 120, 200, 50, fill='white', lineWidth=5)
Line(245, 120, 200, 50, fill='white', lineWidth=5)
Circle(200, 54, 5, fill='darkSlateGray')
Circle(200, 180, 90, fill='white', border='black')
blueBoard = Circle(200, 180, 90, fill='dodgerBlue', border='black')
redBoard = Circle(200, 180, 60, fill='red', border='black')
yellowBoard = Circle(200, 180, 35, fill='yellow', border='black')
Label(30, 200, 195)
Label(20, 200, 225)
Label(10, 200, 255)

# additional targets on the side
Circle(50, 180, 90, fill='white', border='black', align='right')
Circle(45, 180, 88, fill='dodgerBlue', border='black', align='right')
Circle(350, 180, 90, fill='white', border='black', align='left')
Circle(355, 180, 88, fill='dodgerBlue', border='black', align='left')

def drawDart(x, y):
    # Here (x, y) is the center of the body of the dart. The point is 35 pixels
    # to the left of x.
    Polygon(x - 20, y - 2, x - 35, y, x - 20, y + 2)
    Oval(x, y, 50, 15, fill='mediumBlue')
    Polygon(x, y - 7, x + 5, y - 15, x + 25, y - 10, x + 24, y - 2, fill='white')
    Polygon(x, y + 7, x + 5, y + 15, x + 25, y + 10, x + 24, y + 2, fill='white')

def onMousePress(mouseX, mouseY):
    # Draw the dart so that its tip is where you clicked.
    drawDart(mouseX + 35, mouseY)

    # Depending on the dart location add different values to the score.
    # When the dart is thrown outside the board, subtract from the score.
    if (yellowBoard.contains(mouseX, mouseY) == True):
        score.value += 30
    elif (redBoard.contains(mouseX, mouseY) == True):
        score.value += 20
    elif (blueBoard.contains(mouseX, mouseY) == True):
        score.value += 10
    elif (score.value >= 5):
        score.value -= 5
",regular,1
2081,Pixel art,4.4,"cursor = Rect(20, 20, 20, 20, fill='red', border='black')

def moveCursor(key):
    if (key == 'up'):
        cursor.top -= 20
    elif (key == 'down'):
        cursor.top += 20
    elif (key == 'left'):
        cursor.left -= 20
    elif (key == 'right'):
        cursor.left += 20

def changeColor(key):
    # Change the cursor's fill depending on key. Use the following matches.
    # 'r' -> 'red'
    # 'g' -> 'green'
    # 'b' -> 'blue'
    # 'k' -> 'black'
    # 'w' -> 'white'
    ### Place Your Code Here ###
    pass

def placeRect(key):
    # When a space is pressed, place a rectangle at the location of the cursor
    # with the size and fill of the cursor.
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    moveCursor(key)
    changeColor(key)
    placeRect(key)
    cursor.toFront()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

cursor = Rect(20, 20, 20, 20, fill='red', border='black')

def moveCursor(key):
    if (key == 'up'):
        cursor.top -= 20
    elif (key == 'down'):
        cursor.top += 20
    elif (key == 'left'):
        cursor.left -= 20
    elif (key == 'right'):
        cursor.left += 20

def changeColor(key):
    # Change the cursor's fill depending on key. Use the following matches.
    # 'r' -> 'red'
    # 'g' -> 'green'
    # 'b' -> 'blue'
    # 'k' -> 'black'
    # 'w' -> 'white'
    if (key == 'r'):
        cursor.fill = 'red'
    elif (key == 'g'):
        cursor.fill = 'green'
    elif (key == 'b'):
        cursor.fill = 'blue'
    elif (key == 'k'):
        cursor.fill = 'black'
    elif (key == 'w'):
        cursor.fill = 'white'
def placeRect(key):
    # When a space is pressed, place a rectangle at the location of the cursor
    # with the size and fill of the cursor.
    if (key == 'space'):
        Rect(cursor.centerX, cursor.centerY, 20, 20, fill=cursor.fill,
             align='center')
def onKeyPress(key):
    moveCursor(key)
    changeColor(key)
    placeRect(key)
    cursor.toFront()
",regular,2
2078,Watering plants,4.4,"app.background = gradient('darkSlateGrey', 'deepSkyBlue', start='top')

# grass
Rect(0, 360, 400, 360, fill='darkOliveGreen')

water = Polygon(200, 35, 190, 55, 190, 60,
                200, 66, 210, 60, 210, 55, fill='lightSkyBlue')

leftStem = Line(85, 365, 85, 320, fill='lightGreen', lineWidth=5)
leftPot = Polygon(55, 345, 115, 345, 105, 400, 65, 400, fill='saddleBrown')

rightStem = Line(315, 365, 315, 320, fill='darkGreen', lineWidth=5)
rightPot = Polygon(345, 345, 285, 345, 295, 400, 335, 400, fill='saddleBrown')

def growLeftFlower():
    # Either grow some leaves on the stem or grow a flower.
    if (leftStem.y2 > 225):
        Oval(leftStem.x2, leftStem.y2, 20, 10, fill='lightGreen',
             rotateAngle=30, align='right')
        Oval(leftStem.x2, leftStem.y2, 20, 10, fill='lightGreen',
             rotateAngle=-30, align='left')
        leftStem.y2 -= 30
    else:
        Star(leftStem.x2, leftStem.y2 - 20, 35, 7, fill='pink')
        Circle(leftStem.x2, leftStem.y2 - 20, 10, fill='lemonChiffon')

def growRightFlower():
    # Either grow some leaves on the stem or grow a flower.
    if (rightStem.y2 > 175):
        Oval(rightStem.x2, rightStem.y2, 20, 10, fill='darkGreen',
             rotateAngle=30, align='right')
        Oval(rightStem.x2, rightStem.y2, 20, 10, fill='darkGreen',
             rotateAngle=-30, align='left')
        rightStem.y2 -= 30
    else:
        Star(rightStem.x2, rightStem.y2 - 20, 35, 7, fill='mediumVioletRed')
        Circle(rightStem.x2, rightStem.y2 - 20, 10, fill='gold')

def onMousePress(mouseX, mouseY):
    # Grow the plant that is watered.
    ### (HINT: A plant can be watered either on the stem or in the pot.)
    ### Place Your Code Here ###
    pass

def onMouseMove(mouseX, mouseY):
    water.centerX = mouseX
    water.centerY = mouseY
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('darkSlateGrey', 'deepSkyBlue', start='top')

# grass
Rect(0, 360, 400, 360, fill='darkOliveGreen')

water = Polygon(200, 35, 190, 55, 190, 60,
                200, 66, 210, 60, 210, 55, fill='lightSkyBlue')

leftStem = Line(85, 365, 85, 320, fill='lightGreen', lineWidth=5)
leftPot = Polygon(55, 345, 115, 345, 105, 400, 65, 400, fill='saddleBrown')

rightStem = Line(315, 365, 315, 320, fill='darkGreen', lineWidth=5)
rightPot = Polygon(345, 345, 285, 345, 295, 400, 335, 400, fill='saddleBrown')

def growLeftFlower():
    # Either grow some leaves on the stem or grow a flower.
    if (leftStem.y2 > 225):
        Oval(leftStem.x2, leftStem.y2, 20, 10, fill='lightGreen',
             rotateAngle=30, align='right')
        Oval(leftStem.x2, leftStem.y2, 20, 10, fill='lightGreen',
             rotateAngle=-30, align='left')
        leftStem.y2 -= 30
    else:
        Star(leftStem.x2, leftStem.y2 - 20, 35, 7, fill='pink')
        Circle(leftStem.x2, leftStem.y2 - 20, 10, fill='lemonChiffon')

def growRightFlower():
    # Either grow some leaves on the stem or grow a flower.
    if (rightStem.y2 > 175):
        Oval(rightStem.x2, rightStem.y2, 20, 10, fill='darkGreen',
             rotateAngle=30, align='right')
        Oval(rightStem.x2, rightStem.y2, 20, 10, fill='darkGreen',
             rotateAngle=-30, align='left')
        rightStem.y2 -= 30
    else:
        Star(rightStem.x2, rightStem.y2 - 20, 35, 7, fill='mediumVioletRed')
        Circle(rightStem.x2, rightStem.y2 - 20, 10, fill='gold')

def onMousePress(mouseX, mouseY):
    # Grow the plant that is watered.
    if (water.hitsShape(leftStem) == True):
        growLeftFlower()
    elif (water.hitsShape(leftPot) == True):
        growLeftFlower()
    elif (water.hitsShape(rightStem) == True):
        growRightFlower()
    elif (water.hitsShape(rightPot) == True):
        growRightFlower()

def onMouseMove(mouseX, mouseY):
    water.centerX = mouseX
    water.centerY = mouseY
",regular,1
2085,Fishing,4.4,"app.background = gradient('lightSkyBlue', 'orange', start='top')

# sun and lake
Circle(250, 335, 50, fill='gold')
Rect(0, 300, 400, 100, fill='dodgerBlue')

# boat and fishing rod
Polygon(0, 270, 0, 350, 50, 350, 85, 315, 100, 270, fill='sienna')
Line(0, 240, 140, 160)

# fishing line, fish body, and fish tail
fishingLine = Line(140, 160, 140, 340, lineWidth=1)
fishBody = Oval(340, 340, 50, 30, fill='salmon')
fishTail = Polygon(350, 340, 380, 350, 380, 330, fill='salmon')

def pullUpFish():
    fishingLine.x2 = 140
    fishingLine.y2 = 225

    fishBody.rotateAngle = 90
    fishBody.centerX = 140
    fishBody.centerY = 250
    fishTail.rotateAngle = 90
    fishTail.centerX = 140
    fishTail.top = 255

def onKeyPress(key):
    # Release the fish if the correct key is pressed.
    ### Place Your Code Here ###
    pass

def onMouseDrag(mouseX, mouseY):
    # If fish is very close to boat, pull it up.
    ### (HINT: Use a helper function.)
    ### Place Your Code Here ###

    # If the mouse is behind the fish, only move the line.
    ### Place Your Code Here ###

    # If the mouse is too far from the fish, only move the line.
    ### (HINT: They are too far when horizontal distance between them is more
    #          than 80.)
    ### Place Your Code Here ###

    # If the mouse is close enough to the fish and below the water, the line
    # should hook the fish.
    ### (HINT: If the line 'hooks' the fish, both the line and the fish
    #          should move.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightSkyBlue', 'orange', start='top')

# sun and lake
Circle(250, 335, 50, fill='gold')
Rect(0, 300, 400, 100, fill='dodgerBlue')

# boat and fishing rod
Polygon(0, 270, 0, 350, 50, 350, 85, 315, 100, 270, fill='sienna')
Line(0, 240, 140, 160)

# fishing line, fish body, and fish tail
fishingLine = Line(140, 160, 140, 340, lineWidth=1)
fishBody = Oval(340, 340, 50, 30, fill='salmon')
fishTail = Polygon(350, 340, 380, 350, 380, 330, fill='salmon')

def pullUpFish():
    fishingLine.x2 = 140
    fishingLine.y2 = 225

    fishBody.rotateAngle = 90
    fishBody.centerX = 140
    fishBody.centerY = 250
    fishTail.rotateAngle = 90
    fishTail.centerX = 140
    fishTail.top = 255

def onKeyPress(key):
    # Release the fish if the correct key is pressed.
    if (key == 'r'):
        fishBody.rotateAngle = 0
        fishBody.centerX = 340
        fishBody.centerY = 340

        fishTail.rotateAngle = 0
        fishTail.left = 350
        fishTail.centerY = 340

def onMouseDrag(mouseX, mouseY):
    # If fish is very close to boat, pull it up.
    if (fishBody.centerX <= 165):
        pullUpFish()

    # If the line is behind fish, only move the line.
    elif (fishBody.centerX - mouseX < 0):
        fishingLine.x2 = mouseX
        fishingLine.y2 = mouseY

    # If the line is too far from fish, only move the line.
    elif (fishBody.centerX - mouseX > 80):
        fishingLine.x2 = mouseX
        fishingLine.y2 = mouseY

    # If the line is close enough to fish, the line should hook the fish.
    elif (mouseY > 300):
        fishingLine.x2 = mouseX
        fishingLine.y2 = mouseY

        fishBody.centerX = mouseX + 25
        fishBody.centerY = mouseY
        fishTail.centerX = mouseX + 50
        fishTail.centerY = mouseY
",regular,3
2082,Trippy text,4.4,"app.background ='ivory'

cursor = Label('', 30, 30)

def drawFancyLabel(key, x, y):
    # Draws one trippy letter at position (x, y).
    Label(key, x, y, fill='cyan', size=50, opacity=80)
    Label(key, x + 5, y - 5, fill='yellow', size=50, opacity=80)
    Label(key, x - 5, y + 5, fill='magenta', size=50, opacity=80)

def moveToNextLine():
    cursor.centerY += 60
    cursor.centerX = 30

def onKeyPress(key):
    # When space is pressed, move the cursor. When enter is pressed, move
    # to the next line. When backspace is pressed, cover up the previous
    # letter on that line. If none of these keys were pressed, draw a
    # fancy label for the key pressed.
    ### (HINT: Don't worry about erasing the previous line.)
    ### Place Your Code Here ###

    # If the new centerX is greater than 370, move to next line.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background ='ivory'

cursor = Label('', 30, 30)

def drawFancyLabel(key, x, y):
    # Draws one trippy letter at position (x, y).
    Label(key, x, y, fill='cyan', size=50, opacity=80)
    Label(key, x + 5, y - 5, fill='yellow', size=50, opacity=80)
    Label(key, x - 5, y + 5, fill='magenta', size=50, opacity=80)

def moveToNextLine():
    cursor.centerY += 60
    cursor.centerX = 30

def onKeyPress(key):
    # When space is pressed, move the cursor. When enter is pressed, move
    # to the next line. When backspace is pressed, cover up the previous
    # letter on that line. If none of these keys were pressed, draw a
    # fancy label for the key pressed.
    if (key == 'space'):
        cursor.centerX += 30
    elif (key == 'enter'):
        moveToNextLine()
    elif (key == 'backspace'):
        cursor.centerX -= 30
        Rect(cursor.centerX - 20, cursor.centerY - 30, 40, 80, fill='ivory')
    else:
        drawFancyLabel(key, cursor.centerX, cursor.centerY)
        cursor.centerX += 30

    # If the new centerX is greater than 370, move to next line.
    if (cursor.centerX >= 370):
        moveToNextLine()
",regular,2
2092,Collaborative task,4.5,# Fill me in!,,creative,30
2088,Creative task 2,4.5,# Fill me in!,,creative,30
2087,Creative task 1,4.5,# Fill me in!,,creative,30
2086,Etch-A-Sketch,4.5,"# This Creative Task is inspired by the toy, Etch-A-Sketch.
# Arrow keys are used to draw the lines in the 'sand' as the Etch-A-Sketch
# knobs would.

Label('Etch-a-Sketch', 200, 30, fill='beige', size=30, bold=True)
Label('Use the arrow keys to draw!', 200, 360, fill='beige', size=15)
Label('Use the space key to clear the screen!', 200, 60, fill='beige', size=15)

app.background = 'red'

Circle(45, 360, 25, fill='white')
Circle(355, 360, 25, fill='white')

Circle(30, 85, 10, fill='darkGrey')
Circle(370, 85, 10, fill='darkGrey')
Circle(30, 305, 10, fill='darkGrey')
Circle(370, 305, 10, fill='darkGrey')
Line(30, 85, 370, 85, fill='darkGrey', lineWidth=20)
Line(30, 85, 30, 305, fill='darkGrey', lineWidth=20)
Line(370, 85, 370, 305, fill='darkGrey', lineWidth=20)
Line(30, 305, 370, 305, fill='darkGrey', lineWidth=20)

screen = Rect(30, 85, 340, 225, fill='darkGrey')
cursor = Star(200, 200, 5, 4, opacity=50)

def onKeyPress(key):
    cursor.newX = cursor.centerX
    cursor.newY = cursor.centerY

    if (key == 'up'):
        cursor.newY -= 15
    elif (key == 'down'):
        cursor.newY += 15
    elif (key == 'left'):
        cursor.newX -= 15
    elif (key == 'right'):
        cursor.newX += 15
    elif (key == 'space'):
        screen.toFront()
        cursor.toFront()

    if (screen.contains(cursor.newX, cursor.newY) == True):
        Line(cursor.centerX, cursor.centerY, cursor.newX, cursor.newY)
        cursor.centerX = cursor.newX
        cursor.centerY = cursor.newY
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# This Creative Task is inspired by the toy, Etch-A-Sketch.
# Arrow keys are used to draw the lines in the 'sand' as the Etch-A-Sketch
# knobs would.

Label('Etch-a-Sketch', 200, 30, fill='beige', size=30, bold=True)
Label('Use the arrow keys to draw!', 200, 360, fill='beige', size=15)
Label('Use the space key to clear the screen!', 200, 60, fill='beige', size=15)

app.background = 'red'

Circle(45, 360, 25, fill='white')
Circle(355, 360, 25, fill='white')

Circle(30, 85, 10, fill='darkGrey')
Circle(370, 85, 10, fill='darkGrey')
Circle(30, 305, 10, fill='darkGrey')
Circle(370, 305, 10, fill='darkGrey')
Line(30, 85, 370, 85, fill='darkGrey', lineWidth=20)
Line(30, 85, 30, 305, fill='darkGrey', lineWidth=20)
Line(370, 85, 370, 305, fill='darkGrey', lineWidth=20)
Line(30, 305, 370, 305, fill='darkGrey', lineWidth=20)

screen = Rect(30, 85, 340, 225, fill='darkGrey')
cursor = Star(200, 200, 5, 4, opacity=50)

def onKeyPress(key):
    cursor.newX = cursor.centerX
    cursor.newY = cursor.centerY

    if (key == 'up'):
        cursor.newY -= 15
    elif (key == 'down'):
        cursor.newY += 15
    elif (key == 'left'):
        cursor.newX -= 15
    elif (key == 'right'):
        cursor.newX += 15
    elif (key == 'space'):
        screen.toFront()
        cursor.toFront()

    if (screen.contains(cursor.newX, cursor.newY) == True):
        Line(cursor.centerX, cursor.centerY, cursor.newX, cursor.newY)
        cursor.centerX = cursor.newX
        cursor.centerY = cursor.newY
",sample,1
2089,Creative task 3,4.5,# Fill me in!,,creative,30
2090,Creative task 4,4.5,# Fill me in!,,creative,30
2091,Creative task 5,4.5,# Fill me in!,,creative,30
2095,Nested Conditionals Checkpoint 4,5.1.2.1,"app.background = 'black'

Line(200, 0, 200, 400, fill='lightGrey')
Line(0, 200, 400, 200, fill='lightGrey')

def onMousePress(mouseX, mouseY):
    if (mouseX < 200):
        # If the mouse is on the left side of the screen, draw a star in
        # the upper half of the canvas and a circled label on the bottom
        # half.
        ### Place Your Code Here ###
        pass

    else:
        RegularPolygon(mouseX, mouseY, 25, 6, fill='orange')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

Line(200, 0, 200, 400, fill='lightGrey')
Line(0, 200, 400, 200, fill='lightGrey')

def onMousePress(mouseX, mouseY):
    if (mouseX < 200):
        if (mouseY < 200):
            Star(mouseX, mouseY, 30, 7, fill='springGreen')
        else:
            Circle(mouseX, mouseY, 35, fill='fuchsia')
            Label('Woohoo!', mouseX, mouseY)

    else:
        RegularPolygon(mouseX, mouseY, 25, 6, fill='orange')
",regular,1
2096,Shiny lines,5.1.3,"app.background = 'black'

Line(200, 0, 200, 400, fill='white')
Line(0, 200, 400, 200, fill='white')

def onMouseMove(mouseX, mouseY):
    # Depending on the quadrant the mouse is on, draw a gradient line from
    # the closest corner.
    ### (HINT: Check x and y location separately to determine quadrant.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

Line(200, 0, 200, 400, fill='white')
Line(0, 200, 400, 200, fill='white')

def onMouseMove(mouseX, mouseY):
    # Depending on the quadrant the mouse is on, draw a gradient line from
    # the closest corner.
    if (mouseY < 200):
        if (mouseX < 200):
            Line(0, 0, mouseX, mouseY, fill=gradient('red', 'black'))
        else:
            Line(400, 0, mouseX, mouseY, fill=gradient('green', 'black'))
    else:
        if (mouseX < 200):
            Line(0, 400, mouseX, mouseY, fill=gradient('blue', 'black'))
        else:
            Line(400, 400, mouseX, mouseY, fill=gradient('yellow', 'black'))
",regular,1
2097,Faces,5.1.3,"def drawFace(x, y, backgroundColor):
    Rect(x - 100, y - 100, 200, 200, fill=backgroundColor)
    Circle(x - 25, y - 20, 20, fill='white')
    Circle(x - 25, y - 20, 7)
    Circle(x + 25, y - 20, 20, fill='white')
    Circle(x + 25, y - 20, 7)

drawFace(100, 100, 'salmon')
drawFace(300, 100, 'paleTurquoise')
drawFace(100, 300, 'paleGreen')
drawFace(300, 300, 'plum')

redMouth = Label('-', 100, 120, size=50)
blueMouth = Label('-', 300, 120, size=50)
greenMouth = Label('-', 100, 320, size=50)
purpleMouth = Label('-', 300, 320, size=50)

def onMousePress(mouseX, mouseY):
    # Based on the face you click, switch the mouth to either - or o.
    ### (HINT: First figure out which face you clicked on, then check
    #          whether that face's mouth should switch to - or to o.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawFace(x, y, backgroundColor):
    Rect(x - 100, y - 100, 200, 200, fill=backgroundColor)
    Circle(x - 25, y - 20, 20, fill='white')
    Circle(x - 25, y - 20, 7)
    Circle(x + 25, y - 20, 20, fill='white')
    Circle(x + 25, y - 20, 7)

drawFace(100, 100, 'salmon')
drawFace(300, 100, 'paleTurquoise')
drawFace(100, 300, 'paleGreen')
drawFace(300, 300, 'plum')

redMouth = Label('-', 100, 120, size=50)
blueMouth = Label('-', 300, 120, size=50)
greenMouth = Label('-', 100, 320, size=50)
purpleMouth = Label('-', 300, 320, size=50)

def onMousePress(mouseX, mouseY):
    # Based on the face you click, switch the mouth to either - or o.
    if ((mouseX < 200) and (mouseY < 200)):
        if (redMouth.value == '-'):
            redMouth.value = 'o'
        else:
            redMouth.value = '-'

    elif ((mouseX >= 200) and (mouseY < 200)):
        if (blueMouth.value == '-'):
            blueMouth.value = 'o'
        else:
            blueMouth.value = '-'

    elif ((mouseX < 200) and (mouseY >= 200)):
        if (greenMouth.value == '-'):
            greenMouth.value = 'o'
        else:
            greenMouth.value = '-'

    elif ((mouseX >= 200) and (mouseY >= 200)):
        if (purpleMouth.value == '-'):
            purpleMouth.value = 'o'
        else:
            purpleMouth.value = '-'
",regular,1
2099,Wheelbarrow,5.1.3,"# sky
Rect(0, 0, 400, 225, fill=gradient('deepSkyBlue', 'lightCyan', start='top'))

# barn
Polygon(160, 150, 190, 85, 250, 50, 310, 85, 340, 150,
        fill=gradient('darkRed', 'crimson', start='left'),
        border='white', borderWidth=3)
Rect(160, 150, 180, 80, fill=gradient('darkRed', 'crimson', start='left'),
     border='white', borderWidth=3)

# barn door
Rect(250, 200, 80, 55, fill=None, border='white', align='center')
Line(250, 175, 250, 225, fill='white')
Line(210, 175, 250, 225, fill='white')
Line(290, 175, 250, 225, fill='white')
Line(210, 225, 250, 175, fill='white')
Line(290, 225, 250, 175, fill='white')

# windows
Rect(250, 100, 30, 35, border='white', borderWidth=3, align='center')
Rect(185, 180, 25, 30, border='white', borderWidth=3, align='center')
Rect(315, 180, 25, 30, border='white', borderWidth=3, align='center')

# grass
Rect(0, 225, 400, 175, fill=gradient('forestGreen', 'mediumSeaGreen', start='top'))

# sheep
Line(105, 355, 105, 380, lineWidth=4)
Line(150, 355, 150, 380, lineWidth=4)
Circle(105, 320, 20, fill='white', border='gainsboro')
Oval(75, 340, 45, 35, rotateAngle=-30)
Circle(70, 335, 3, fill='ghostWhite')
Circle(69, 336, 1)

# grass for the sheep
Line(50, 375, 45, 360, fill='darkGreen')
Line(53, 375, 55, 363, fill='darkGreen')
Line(51, 375, 50, 360, fill='darkGreen')

# wool
Circle(100, 340, 20, fill='white', border='gainsboro')
Circle(125, 350, 20, fill='white', border='gainsboro')
Circle(160, 345, 20, fill='white', border='gainsboro')
Circle(130, 310, 20, fill='white', border='gainsboro')
Circle(155, 315, 20, fill='white', border='gainsboro')
Circle(130, 330, 30, fill='white')

# wheelbarrow
wheel = Circle(110, 215, 12, fill=gradient('white', 'black', 'black'))
barrow = Polygon(45, 195, 40, 175, 120, 175, 95, 210,
                 fill=gradient('crimson', 'maroon', start='bottom'),
                 border='brown')
stand = Polygon(45, 200, 65, 205, 55, 225, fill=None,
                border='saddleBrown', borderWidth=3)
handle = Line(20, 190, 110, 215, fill='saddleBrown', lineWidth=4)

# person
head = Circle(70, 150, 10)
body = Line(70, 150, 70, 175)
arm = Line(70, 165, 90, 185)

def moveWheelbarrow(xChange):
    head.centerX += xChange
    body.centerX += xChange
    arm.centerX += xChange

    wheel.centerX += xChange
    barrow.centerX += xChange
    handle.centerX += xChange
    stand.centerX += xChange

def liftWheelbarrow():
    handle.y1 = 170

    head.centerY -= 8
    body.centerY -= 8
    arm.centerY -= 8

    barrow.angle = 10
    barrow.centerY -= 9
    stand.angle = 12
    stand.centerY -= 12

def placeWheelbarrow():
    handle.y1 = 190

    head.centerY += 8
    body.centerY += 8
    arm.centerY += 8

    barrow.centerX = handle.x1 + 60
    barrow.angle = 0
    barrow.centerY = 192

    stand.centerX = handle.x1 + 35
    stand.angle = 0
    stand.centerY = 212

def onKeyPress(key):
    # If the wheelbarrow is set down, only the up key will lift it up.
    ### (HINT: Check the y1 value of handle to determine if handle is
    #          lifted/placed.)
    ### Place Your Code Here ###

    # Otherwise, left and right keys should move it horizontally, and the
    # down key should place it back down.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# sky
Rect(0, 0, 400, 225, fill=gradient('deepSkyBlue', 'lightCyan', start='top'))

# barn
Polygon(160, 150, 190, 85, 250, 50, 310, 85, 340, 150,
        fill=gradient('darkRed', 'crimson', start='left'),
        border='white', borderWidth=3)
Rect(160, 150, 180, 80, fill=gradient('darkRed', 'crimson', start='left'),
     border='white', borderWidth=3)

# barn door
Rect(250, 200, 80, 55, fill=None, border='white', align='center')
Line(250, 175, 250, 225, fill='white')
Line(210, 175, 250, 225, fill='white')
Line(290, 175, 250, 225, fill='white')
Line(210, 225, 250, 175, fill='white')
Line(290, 225, 250, 175, fill='white')

# windows
Rect(250, 100, 30, 35, border='white', borderWidth=3, align='center')
Rect(185, 180, 25, 30, border='white', borderWidth=3, align='center')
Rect(315, 180, 25, 30, border='white', borderWidth=3, align='center')

# grass
Rect(0, 225, 400, 175, fill=gradient('forestGreen', 'mediumSeaGreen', start='top'))

# sheep
Line(105, 355, 105, 380, lineWidth=4)
Line(150, 355, 150, 380, lineWidth=4)
Circle(105, 320, 20, fill='white', border='gainsboro')
Oval(75, 340, 45, 35, rotateAngle=-30)
Circle(70, 335, 3, fill='ghostWhite')
Circle(69, 336, 1)

# grass for the sheep
Line(50, 375, 45, 360, fill='darkGreen')
Line(53, 375, 55, 363, fill='darkGreen')
Line(51, 375, 50, 360, fill='darkGreen')

# wool
Circle(100, 340, 20, fill='white', border='gainsboro')
Circle(125, 350, 20, fill='white', border='gainsboro')
Circle(160, 345, 20, fill='white', border='gainsboro')
Circle(130, 310, 20, fill='white', border='gainsboro')
Circle(155, 315, 20, fill='white', border='gainsboro')
Circle(130, 330, 30, fill='white')

# wheelbarrow
wheel = Circle(110, 215, 12, fill=gradient('white', 'black', 'black'))
barrow = Polygon(45, 195, 40, 175, 120, 175, 95, 210,
                 fill=gradient('crimson', 'maroon', start='bottom'),
                 border='brown')
stand = Polygon(45, 200, 65, 205, 55, 225, fill=None,
                border='saddleBrown', borderWidth=3)
handle = Line(20, 190, 110, 215, fill='saddleBrown', lineWidth=4)

# person
head = Circle(70, 150, 10)
body = Line(70, 150, 70, 175)
arm = Line(70, 165, 90, 185)

def moveWheelbarrow(xChange):
    head.centerX += xChange
    body.centerX += xChange
    arm.centerX += xChange

    wheel.centerX += xChange
    barrow.centerX += xChange
    handle.centerX += xChange
    stand.centerX += xChange

def liftWheelbarrow():
    handle.y1 = 170

    head.centerY -= 8
    body.centerY -= 8
    arm.centerY -= 8

    barrow.angle = 10
    barrow.centerY -= 9
    stand.angle = 12
    stand.centerY -= 12

def placeWheelbarrow():
    handle.y1 = 190

    head.centerY += 8
    body.centerY += 8
    arm.centerY += 8

    barrow.centerX = handle.x1 + 60
    barrow.angle = 0
    barrow.centerY = 192

    stand.centerX = handle.x1 + 35
    stand.angle = 0
    stand.centerY = 212

def onKeyPress(key):
    # If the wheelbarrow is set down, only the up key will lift it up.
    if (handle.y1 == 190):
        if (key == 'up'):
            liftWheelbarrow()

    # Otherwise, left and right keys should move it horizontally, and the
    # down key should place it back down.
    else:
        if (key == 'down'):
            placeWheelbarrow()
        elif (key == 'right'):
            moveWheelbarrow(35)
        elif (key == 'left'):
            moveWheelbarrow(-35)
",regular,2
2101,Moon craters,5.1.3,"app.background = 'black'

# moon
outerMoon = Circle(200, 200, 165,
                   fill=gradient(rgb(120, 120, 120), rgb(218, 218, 218),
                                 start='left'))
innerMoon = Circle(200, 200, 135, fill=gradient('grey', 'lightGrey', start='left'))
innerMoon.nextRadius = 30

def onMousePress(mouseX, mouseY):
    # Check if the inner portion of the moon was clicked on. If it was, draw a
    # crater with radius innerMoon.nextRadius and set the nextRadius for the
    # next crater.
    ### (HINT: Use the hits method to check if the moon was clicked.)
    ### Place Your Code Here ###

    # If none of the moon was clicked on, draw a star.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# moon
outerMoon = Circle(200, 200, 165,
                   fill=gradient(rgb(120, 120, 120), rgb(218, 218, 218),
                                 start='left'))
innerMoon = Circle(200, 200, 135, fill=gradient('grey', 'lightGrey', start='left'))
innerMoon.nextRadius = 30

def onMousePress(mouseX, mouseY):
    # Check if the inner portion of the moon was clicked on. If it was, draw a
    # crater with radius innerMoon.nextRadius and set the nextRadius for the
    # next crater.
    if (innerMoon.hits(mouseX, mouseY) == True):
        Circle(mouseX, mouseY, innerMoon.nextRadius,
               fill=gradient('darkGrey', 'grey', start='left'))

        if (innerMoon.nextRadius == 20):
            innerMoon.nextRadius = 30
        else:
            innerMoon.nextRadius = 20

    # If none of the moon was clicked on, draw a star.
    elif (outerMoon.hits(mouseX, mouseY) == False):
        Star(mouseX, mouseY, 5, 4, fill='white')
",regular,1
2098,Breakfast,5.1.3,"# table
Rect(0, 0, 400, 400, fill=gradient('peru', 'sienna', start='left-top'))

def drawBasicBreakfast():
    # plate
    Circle(200, 220, 150, fill='white')

    # pancake
    Circle(170, 220, 100, fill='wheat', border='burlyWood')
    Rect(140, 210, 30, 30, fill='yellow')

    # fruit
    Circle(230, 320, 70, fill='orange')
    Circle(230, 320, 62, fill='lightCoral', border='antiqueWhite', borderWidth=5)
    Star(230, 320, 55, 12, fill='antiqueWhite', roundness=0)

def drawOrangeJuice():
    Circle(350, 70, 50, fill=gradient('gold', 'orange'), border='white',
           borderWidth=4)

def drawCoffee():
    Oval(85, 65, 50, 20, fill='white')
    Circle(20, 70, 55, fill=rgb(112, 73, 60), border='white', borderWidth=10)

def drawEggs():
    Oval(265, 160, 110, 100, fill='white', border='lightGrey', rotateAngle=20)
    Circle(250, 150, 20, fill='gold')
    Oval(285, 220, 110, 90, fill='white', border='lightGrey', rotateAngle=20)
    Circle(300, 220, 20, fill='gold')

def drawSausage():
    Oval(140, 135, 100, 40, fill='maroon', rotateAngle=350)
    Oval(190, 130, 100, 40, fill='brown', rotateAngle=320)

def drawBreakfast(isThirsty, isTired, isVegan, isVegetarian):
    drawBasicBreakfast()

    # Draw drinks depending on if you are thirsty and if you are tired or not.
    ### (HINT: The drawing code has already been written for you in helper
    #          functions!)
    ### Place Your Code Here ###

    # Draw extra food based on vegan/vegetarian preference.
    ### (HINT: This time we provided the function calls. You need to place them
    #          in conditionals appropriately.)
    ### Fix Your Code Here ###
    drawEggs()
    drawSausage()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# table
Rect(0, 0, 400, 400, fill=gradient('peru', 'sienna', start='left-top'))

def drawBasicBreakfast():
    # plate
    Circle(200, 220, 150, fill='white')

    # pancake
    Circle(170, 220, 100, fill='wheat', border='burlyWood')
    Rect(140, 210, 30, 30, fill='yellow')

    # fruit
    Circle(230, 320, 70, fill='orange')
    Circle(230, 320, 62, fill='lightCoral', border='antiqueWhite', borderWidth=5)
    Star(230, 320, 55, 12, fill='antiqueWhite', roundness=0)

def drawOrangeJuice():
    Circle(350, 70, 50, fill=gradient('gold', 'orange'), border='white',
           borderWidth=4)

def drawCoffee():
    Oval(85, 65, 50, 20, fill='white')
    Circle(20, 70, 55, fill=rgb(112, 73, 60), border='white', borderWidth=10)

def drawEggs():
    Oval(265, 160, 110, 100, fill='white', border='lightGrey', rotateAngle=20)
    Circle(250, 150, 20, fill='gold')
    Oval(285, 220, 110, 90, fill='white', border='lightGrey', rotateAngle=20)
    Circle(300, 220, 20, fill='gold')

def drawSausage():
    Oval(140, 135, 100, 40, fill='maroon', rotateAngle=350)
    Oval(190, 130, 100, 40, fill='brown', rotateAngle=320)

def drawBreakfast(isThirsty, isTired, isVegan, isVegetarian):
    drawBasicBreakfast()

    # Draw drinks depending on if you are thirsty and if you are tired or not.
    if (isThirsty == True):
        drawOrangeJuice()
    if (isTired == True):
        drawCoffee()

    # Draw extra food based on vegan/vegetarian preference.
    if (isVegan == False):
        drawEggs()
        if (isVegetarian == False):
            drawSausage()
",regular,2
2100,Rock paper scissors,5.1.3,"Rect(0, 0, 400, 400, fill=gradient('steelBlue', 'lightSteelBlue', start='top'))

leftThrow = Label('Rock', 100, 275, size=25)
rightThrow = Label('Rock', 300, 275, size=25)
leftInstructions = Label('Use s, d, f key to control left', 200, 375, size=14)
rightInstructions = Label('Use j, k, l key to control right', 200, 390, size=14)

def drawFinger(x1, y1, x2, y2):
    Line(x1, y1, x2, y2, fill='gold', lineWidth=20)
    Circle(x1, y1, 10, fill='gold')

def drawLeftHand():
    Circle(100, 200, 50, fill='gold')
    if (leftThrow.value != 'Rock'):
        drawFinger(85, 90, 85, 200)
        drawFinger(60, 100, 60, 200)
    if (leftThrow.value == 'Paper'):
        drawFinger(110, 90, 110, 200)
        drawFinger(135, 100, 135, 200)
        drawFinger(160, 170, 125, 230)
    leftThrow.toFront()

def drawRightHand():
    Circle(300, 200, 50, fill='gold')
    if (rightThrow.value != 'Rock'):
        drawFinger(285, 90, 285, 200)
        drawFinger(260, 100, 260, 200)
    if (rightThrow.value == 'Paper'):
        drawFinger(310, 90, 310, 200)
        drawFinger(335, 100, 335, 200)
        drawFinger(360, 170, 325, 230)
    rightThrow.toFront()

def drawWinner(leftMove, rightMove):
    # Check leftMove and rightMove and draw == , > , < accordingly.
    ### (HINT: It matters if we use uppercase or lowercase here!)
    ### Place Your Code Here ###
    pass

def throwdown():
    # Draw over the old hand and redraw the hands.
    Rect(0, 0, 400, 400, fill=gradient('steelBlue', 'lightSteelBlue', start='top'))
    drawLeftHand()
    drawRightHand()
    drawWinner(leftThrow.value, rightThrow.value)

    leftInstructions.toFront()
    rightInstructions.toFront()

def onKeyPress(key):
    if (key == 's'):
        leftThrow.value = 'Rock'
    elif (key == 'd'):
        leftThrow.value = 'Paper'
    elif (key == 'f'):
        leftThrow.value = 'Scissors'
    elif (key == 'l'):
        rightThrow.value = 'Rock'
    elif (key == 'k'):
        rightThrow.value = 'Paper'
    elif (key == 'j'):
        rightThrow.value = 'Scissors'
    throwdown()

drawLeftHand()
drawRightHand()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(0, 0, 400, 400, fill=gradient('steelBlue', 'lightSteelBlue', start='top'))

leftThrow = Label('Rock', 100, 275, size=25)
rightThrow = Label('Rock', 300, 275, size=25)
leftInstructions = Label('Use s, d, f key to control left', 200, 375, size=14)
rightInstructions = Label('Use j, k, l key to control right', 200, 390, size=14)

def drawFinger(x1, y1, x2, y2):
    Line(x1, y1, x2, y2, fill='gold', lineWidth=20)
    Circle(x1, y1, 10, fill='gold')

def drawLeftHand():
    Circle(100, 200, 50, fill='gold')
    if (leftThrow.value != 'Rock'):
        drawFinger(85, 90, 85, 200)
        drawFinger(60, 100, 60, 200)
    if (leftThrow.value == 'Paper'):
        drawFinger(110, 90, 110, 200)
        drawFinger(135, 100, 135, 200)
        drawFinger(160, 170, 125, 230)
    leftThrow.toFront()

def drawRightHand():
    Circle(300, 200, 50, fill='gold')
    if (rightThrow.value != 'Rock'):
        drawFinger(285, 90, 285, 200)
        drawFinger(260, 100, 260, 200)
    if (rightThrow.value == 'Paper'):
        drawFinger(310, 90, 310, 200)
        drawFinger(335, 100, 335, 200)
        drawFinger(360, 170, 325, 230)
    rightThrow.toFront()

def drawWinner(leftMove, rightMove):
    # Check leftMove and rightMove and draw == , > , < accordingly.
    if (leftMove == rightMove):
        Label('==', 200, 200, size=60)
    elif (((leftMove == 'Rock') and (rightMove == 'Scissors')) or
          ((leftMove == 'Paper') and (rightMove == 'Rock')) or
          ((leftMove == 'Scissors') and (rightMove == 'Paper'))):
        Label('>', 200, 200, size=60)
    else:
        Label('<', 200, 200, size=60)

def throwdown():
    # Draw over the old hand and redraw the hands.
    Rect(0, 0, 400, 400, fill=gradient('steelBlue', 'lightSteelBlue', start='top'))
    drawLeftHand()
    drawRightHand()
    drawWinner(leftThrow.value, rightThrow.value)

    leftInstructions.toFront()
    rightInstructions.toFront()

def onKeyPress(key):
    if (key == 's'):
        leftThrow.value = 'Rock'
    elif (key == 'd'):
        leftThrow.value = 'Paper'
    elif (key == 'f'):
        leftThrow.value = 'Scissors'
    elif (key == 'l'):
        rightThrow.value = 'Rock'
    elif (key == 'k'):
        rightThrow.value = 'Paper'
    elif (key == 'j'):
        rightThrow.value = 'Scissors'
    throwdown()

drawLeftHand()
drawRightHand()
",regular,3
2104,Star expansion,5.2.2,"app.background = gradient('skyBlue', 'paleTurquoise', start='top')

star1 = Star(200, 200, 175, 8, fill=gradient('darkViolet', 'mediumOrchid'),
             roundness=50, opacity=40)
star2 = Star(200, 200, 175, 8, fill=gradient('mediumBlue', 'midnightBlue'),
             roundness=50, opacity=40)

def onKeyHold(keys):
    # When holding the up key, increase the roundness of star1 and
    # decrease that of star2.
    # When holding the down key, change the roundness in the opposite directions
    ### (HINT: Roundness cannot be greater than 100 or less than 0,
    #          so wrap around.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('skyBlue', 'paleTurquoise', start='top')

star1 = Star(200, 200, 175, 8, fill=gradient('darkViolet', 'mediumOrchid'),
             roundness=50, opacity=40)
star2 = Star(200, 200, 175, 8, fill=gradient('mediumBlue', 'midnightBlue'),
             roundness=50, opacity=40)

def onKeyHold(keys):
    # When holding the up key, increase the roundness of star1 and
    # decrease that of star2.
    # When holding the down key, change the roundness in the opposite directions
    if ('up' in keys):
        if (star2.roundness == 0):
            star1.roundness = 0
            star2.roundness = 100
        else:
            star1.roundness += 2
            star2.roundness -= 2
    elif ('down' in keys):
        if (star1.roundness == 0):
            star1.roundness = 100
            star2.roundness = 0
        else:
            star1.roundness -= 2
            star2.roundness += 2
",regular,2
2103,Anthill,5.2.2,"app.background = gradient('mediumSeaGreen', 'darkGreen')

# anthill
Circle(200, 200, 175, fill=gradient('peru', rgb(60, 30, 20)))
Star(200, 200, 175, 23, fill=gradient('peru', rgb(60, 30, 20)), opacity=70,
     roundness=5)
Circle(200, 200, 30, border=rgb(60, 30, 20), borderWidth=4)

ants = Star(200, 200, 25, 9, fill=None, border='black', dashes=True,
            roundness=1)

def onKeyHold(keys):
    # When the spacebar is held, change the size of the dashed shape
    # by 3 to make the ants look like they are moving.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('mediumSeaGreen', 'darkGreen')

# anthill
Circle(200, 200, 175, fill=gradient('peru', rgb(60, 30, 20)))
Star(200, 200, 175, 23, fill=gradient('peru', rgb(60, 30, 20)), opacity=70,
     roundness=5)
Circle(200, 200, 30, border=rgb(60, 30, 20), borderWidth=4)

ants = Star(200, 200, 25, 9, fill=None, border='black', dashes=True,
            roundness=1)

def onKeyHold(keys):
    # When the spacebar is held, change the size of the dashed shape
    # by 3 to make the ants look like they are moving.
    if ('space' in keys):
        ants.radius += 3
",regular,1
2102,Dot race,5.2.2,"app.background = 'paleGreen'

track = Rect(200, 200, 360, 360, align='center')
innerGrass = Rect(200, 200, 260, 260, fill='paleGreen', align='center')
Rect(200, 200, 310, 310, fill=None, border='white', dashes=True, align='center')

message = Label('Dot Race!', 200, 200, size=25)

finishLine = Line(320, 200, 390, 200, fill='white', lineWidth=30)
Line(315, 200, 390, 200, fill='red', lineWidth=30, dashes=True)

purpleDot = Circle(45, 175, 15, fill='darkOrchid')
blueDot = Circle(45, 225, 15, fill='dodgerBlue')

def onKeyHold(keys):
    # While the race is still going, move the dots and check if the race ends.
    if (message.value == 'Dot Race!'):
        if ('up' in keys):
            purpleDot.centerY -= 10
        if ('down' in keys):
            purpleDot.centerY += 10
        if ('left' in keys):
            purpleDot.centerX -= 10
        if ('right' in keys):
            purpleDot.centerX += 10
        if ('w' in keys):
            blueDot.centerY -= 10
        if ('s' in keys):
            blueDot.centerY += 10
        if ('a' in keys):
            blueDot.centerX -= 10
        if ('d' in keys):
            blueDot.centerX += 10

        # Check if one of the dots wins and if so change the value of the message.
        # A dot wins if either it touches the finish line or the center of the
        # other dot is not on the track.
        ### (HINT: The innerGrass is not a part of the track so you also need to
        #          check if the dots are touching the innerGrass.)
        ### Place Your Code Here ###

def onKeyPress(key):
    # Do not change this function! It is for testing purposes only!
    if (key == 'q'):
        message.value = 'Dot Race!'
        purpleDot.centerX = 350
        purpleDot.centerY = 165
        blueDot.centerX = 350
        blueDot.centerY = 240
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'paleGreen'

track = Rect(200, 200, 360, 360, align='center')
innerGrass = Rect(200, 200, 260, 260, fill='paleGreen', align='center')
Rect(200, 200, 310, 310, fill=None, border='white', dashes=True, align='center')

message = Label('Dot Race!', 200, 200, size=25)

finishLine = Line(320, 200, 390, 200, fill='white', lineWidth=30)
Line(315, 200, 390, 200, fill='red', lineWidth=30, dashes=True)

purpleDot = Circle(45, 175, 15, fill='darkOrchid')
blueDot = Circle(45, 225, 15, fill='dodgerBlue')

def onKeyHold(keys):
    # While the race is still going, move the dots and check if the race ends.
    if (message.value == 'Dot Race!'):
        if ('up' in keys):
            purpleDot.centerY -= 10
        if ('down' in keys):
            purpleDot.centerY += 10
        if ('left' in keys):
            purpleDot.centerX -= 10
        if ('right' in keys):
            purpleDot.centerX += 10
        if ('w' in keys):
            blueDot.centerY -= 10
        if ('s' in keys):
            blueDot.centerY += 10
        if ('a' in keys):
            blueDot.centerX -= 10
        if ('d' in keys):
            blueDot.centerX += 10

        # Check if one of the dots wins and if so change the value of the message.
        # A dot wins if either it touches the finish line or the center of the
        # other dot is not on the track.
        if ((track.contains(purpleDot.centerX, purpleDot.centerY) == False) or
            (innerGrass.contains(purpleDot.centerX, purpleDot.centerY) == True)):
            message.value = 'Blue dot won!'
        elif ((track.contains(blueDot.centerX, blueDot.centerY) == False) or
              (innerGrass.contains(blueDot.centerX, blueDot.centerY) == True)):
            message.value = 'Purple dot won!'
        elif (purpleDot.hitsShape(finishLine) == True):
            message.value = 'Purple dot won!'
        elif (blueDot.hitsShape(finishLine) == True):
            message.value = 'Blue dot won!'

def onKeyPress(key):
    # Do not change this function! It is for testing purposes only!
    if (key == 'q'):
        message.value = 'Dot Race!'
        purpleDot.centerX = 350
        purpleDot.centerY = 165
        blueDot.centerX = 350
        blueDot.centerY = 240
",regular,3
2105,Strobing circles,5.2.2,"app.background = 'azure'

head = Circle(200, 200, 30, fill='mediumOrchid')

def getNewHeadColor():
    # Cycle through the three colors.
    if (head.fill == 'mediumOrchid'):
        head.fill = 'mediumSpringGreen'
    elif (head.fill == 'mediumSpringGreen'):
        head.fill = 'blue'
    else:
        head.fill = 'mediumOrchid'

def onKeyHold(keys):
    # Depending on the keys held down, move the head in an appropriate direction.
    ### Place Your Code Here ###

    # Draw a new circle where the head is with the same fill.
    ### Place Your Code Here ###

    # Change the color of the head.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'azure'

head = Circle(200, 200, 30, fill='mediumOrchid')

def getNewHeadColor():
    # Cycle through the three colors.
    if (head.fill == 'mediumOrchid'):
        head.fill = 'mediumSpringGreen'
    elif (head.fill == 'mediumSpringGreen'):
        head.fill = 'blue'
    else:
        head.fill = 'mediumOrchid'

def onKeyHold(keys):
    # Depending on the keys held down, move the head in an appropriate direction.
    if ('up' in keys):
        head.centerY -= 10
    if ('down' in keys):
        head.centerY += 10
    if ('left' in keys):
        head.centerX -= 10
    if ('right' in keys):
        head.centerX += 10

    # Draw a new circle where the head is with the same fill.
    Circle(head.centerX, head.centerY, 30, fill=head.fill)

    # Change the color of the head.
    getNewHeadColor()
",regular,1
2106,Cocoa,5.2.2,"app.background = 'lightCyan'

# table
Polygon(0, 325, 100, 200, 400, 200, 400, 400, 0, 400, fill='tan')

# clock
Circle(60, 75, 50, fill='white', border='black')
Circle(60, 75, 45, fill='white', border='black', dashes=True)

# hand draws a line centered at the center of the clock. handCover covers half
# of the hand so that the hand only points in one direction.
hand = Line(60, 40, 60, 110)
handCover = Line(60, 75, 60, 110, fill='white', lineWidth=5)

# mug handle
Circle(330, 260, 40, fill=None, border='brown', borderWidth=12)

# mug
Rect(170, 180, 160, 150, fill='brown')
Oval(250, 330, 160, 60, fill='brown')
Oval(250, 180, 160, 80, fill='maroon')
Oval(250, 185, 140, 50, fill='saddleBrown')

def drawMarshmallow(x, y):
    Rect(x, y, 20, 10, fill='white')
    Oval(x, y - 5, 20, 10, fill='white', border='brown', borderWidth=1,
         align='left-top')
    Oval(x, y + 5, 20, 10, fill='white', align='left-top')

def drawMarshmallows():
    drawMarshmallow(200, 170)
    drawMarshmallow(275, 175)
    drawMarshmallow(240, 190)

def drawSteamPart(x):
    Circle(x, 60, 20, fill='grey', opacity=20)
    Circle(x - 10, 60, 20, fill='lightCyan')
    Circle(x, 100, 20, fill='grey', opacity=20)
    Circle(x + 10, 100, 20, fill='lightCyan')

def drawSteam():
    drawSteamPart(190)
    drawSteamPart(250)
    drawSteamPart(310)

drawSteam()
drawMarshmallows()

marshmallowCover = Oval(250, 185, 140, 50, fill='saddleBrown', opacity=0)
steamCover = Rect(160, 30, 170, 100, fill='lightCyan', opacity=0)

def onKeyHold(keys):
    # Rotate the clock hand, and make sure to move the handCover as well.
    # Cover up the marshmallows and steam gradually so it looks like they
    # are disappearing.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightCyan'

# table
Polygon(0, 325, 100, 200, 400, 200, 400, 400, 0, 400, fill='tan')

# clock
Circle(60, 75, 50, fill='white', border='black')
Circle(60, 75, 45, fill='white', border='black', dashes=True)

# hand draws a line centered at the center of the clock. handCover covers half
# of the hand so that the hand only points in one direction.
hand = Line(60, 40, 60, 110)
handCover = Line(60, 75, 60, 110, fill='white', lineWidth=5)

# mug handle
Circle(330, 260, 40, fill=None, border='brown', borderWidth=12)

# mug
Rect(170, 180, 160, 150, fill='brown')
Oval(250, 330, 160, 60, fill='brown')
Oval(250, 180, 160, 80, fill='maroon')
Oval(250, 185, 140, 50, fill='saddleBrown')

def drawMarshmallow(x, y):
    Rect(x, y, 20, 10, fill='white')
    Oval(x, y - 5, 20, 10, fill='white', border='brown', borderWidth=1,
         align='left-top')
    Oval(x, y + 5, 20, 10, fill='white', align='left-top')

def drawMarshmallows():
    drawMarshmallow(200, 170)
    drawMarshmallow(275, 175)
    drawMarshmallow(240, 190)

def drawSteamPart(x):
    Circle(x, 60, 20, fill='grey', opacity=20)
    Circle(x - 10, 60, 20, fill='lightCyan')
    Circle(x, 100, 20, fill='grey', opacity=20)
    Circle(x + 10, 100, 20, fill='lightCyan')

def drawSteam():
    drawSteamPart(190)
    drawSteamPart(250)
    drawSteamPart(310)

drawSteam()
drawMarshmallows()

marshmallowCover = Oval(250, 185, 140, 50, fill='saddleBrown', opacity=0)
steamCover = Rect(160, 30, 170, 100, fill='lightCyan', opacity=0)

def onKeyHold(keys):
    # Rotate the clock hand, and make sure to move the handCover as well.
    # Cover up the marshmallows and steam gradually so it looks like they
    # are disappearing.
    hand.rotateAngle += 5
    handCover.x2 = hand.x2
    handCover.y2 = hand.y2
    if (marshmallowCover.opacity < 99):
        marshmallowCover.opacity += 2
    if (steamCover.opacity < 100):
        steamCover.opacity += 1
",regular,3
2107,Empire state building,5.2.2,"app.background = gradient(rgb(165, 115, 180), rgb(235, 160, 130),
                          rgb(225, 190, 165), start='top')

# background buildings
Rect(30, 200, 70, 200, fill=rgb(98, 86, 110))
Rect(0, 240, 50, 202, fill=rgb(60, 46, 75))
Rect(80, 230, 60, 172, fill=rgb(60, 46, 75))

Rect(320, 190, 50, 212, fill=rgb(98, 86, 110))
Rect(360, 220, 40, 182, fill=rgb(60, 46, 75))
Rect(290, 260, 60, 142, fill=rgb(60, 46, 75))

# building
Polygon(110, 400, 290, 400, 290, 340, 280, 340, 280, 300, 250, 300, 250, 85,
        230, 85, 230, 65, 170, 65, 170, 85, 150, 85, 150, 300, 120, 300, 120,
        340, 110, 340, fill=rgb(16, 5, 16))
Polygon(195, 65, 200, 0, 205, 65, fill=rgb(15, 5, 15))

Line(170, 85, 170, 400, fill=rgb(80, 70, 85))
Line(230, 85, 230, 400, fill=rgb(80, 70, 85))
Line(200, 80, 200, 400, fill=rgb(225, 225, 190), lineWidth=10, dashes=True)

# elevator
elevator = Rect(190, 378, 20, 22, fill=rgb(70, 65, 85))

# display the floor we are on
Label('Floor', 320, 60, fill='snow', size=26)
floor = Label(0, 320, 100, fill='snow', size=38)

def onKeyHold(keys):
    # Move the elevator up and down the floor when those arrow keys are
    # pressed. There are 102 floors in the Empire State Building, the elevator
    # cannot go higher than that. You also cannot go below floor 0.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(165, 115, 180), rgb(235, 160, 130),
                          rgb(225, 190, 165), start='top')

# background buildings
Rect(30, 200, 70, 200, fill=rgb(98, 86, 110))
Rect(0, 240, 50, 202, fill=rgb(60, 46, 75))
Rect(80, 230, 60, 172, fill=rgb(60, 46, 75))

Rect(320, 190, 50, 212, fill=rgb(98, 86, 110))
Rect(360, 220, 40, 182, fill=rgb(60, 46, 75))
Rect(290, 260, 60, 142, fill=rgb(60, 46, 75))

# building
Polygon(110, 400, 290, 400, 290, 340, 280, 340, 280, 300, 250, 300, 250, 85,
        230, 85, 230, 65, 170, 65, 170, 85, 150, 85, 150, 300, 120, 300, 120,
        340, 110, 340, fill=rgb(16, 5, 16))
Polygon(195, 65, 200, 0, 205, 65, fill=rgb(15, 5, 15))

Line(170, 85, 170, 400, fill=rgb(80, 70, 85))
Line(230, 85, 230, 400, fill=rgb(80, 70, 85))
Line(200, 80, 200, 400, fill=rgb(225, 225, 190), lineWidth=10, dashes=True)

# elevator
elevator = Rect(190, 378, 20, 22, fill=rgb(70, 65, 85))

# display the floor we are on
Label('Floor', 320, 60, fill='snow', size=26)
floor = Label(0, 320, 100, fill='snow', size=38)

def onKeyHold(keys):
    # Move the elevator up and down the floor when those arrow keys are
    # pressed. There are 102 floors in the Empire State Building, the elevator
    # cannot go higher than that. You also cannot go below floor 0.
    if ('up' in keys):
        if (floor.value < 102):
            elevator.centerY -= 3
            floor.value += 1
    if ('down' in keys):
        if (floor.value > 0):
            elevator.centerY += 3
            floor.value -= 1
",regular,2
2108,Bubble pop,5.2.2,"app.background = gradient('dodgerBlue', 'dodgerBlue', 'lightCyan', start='bottom')

# ocean stars
Star(65, 65, 10, 6, fill='paleGreen')
Star(345, 300, 10, 7, fill='paleGreen', opacity=70)
Star(315, 125, 10, 4, fill='aliceBlue', roundness=20, rotateAngle=45)
Star(75, 300, 10, 8, fill='hotPink', rotateAngle=20, roundness=30, opacity=80)

# jellyfish body
Circle(240, 350, 50, fill=rgb(250, 200, 230))
Circle(240, 350, 45, fill=rgb(250, 220, 240))
Rect(185, 350, 110, 150, fill='dodgerBlue')
Line(205, 370, 275, 370, fill=rgb(250, 220, 240), lineWidth=40, dashes=(10, 5))

# jellyfish eyes and mouth
Circle(218, 332, 5)
Circle(263, 332, 5)
Circle(218, 330, 2, fill='grey')
Circle(263, 330, 2, fill='grey')
Circle(240, 332, 7, fill=rgb(250, 120, 180))
Rect(230, 325, 20, 7, fill=rgb(250, 220, 240))

# bubble
bubble = Circle(200, 330, 10, fill=gradient('lightCyan', 'lavender'), opacity=30,
                border=gradient('plum', 'darkTurquoise', 'hotPink',
                                'gold', start='top'))

def onKeyHold(keys):
    # When the up key is held, move the bubble up by 5 pixels.
    ### Place Your Code Here ###

    # Increase the radius by 1, and reset if the radius gets bigger than 80.
    ### (HINT: Do this even when the bubble doesn't move up.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('dodgerBlue', 'dodgerBlue', 'lightCyan', start='bottom')

# ocean stars
Star(65, 65, 10, 6, fill='paleGreen')
Star(345, 300, 10, 7, fill='paleGreen', opacity=70)
Star(315, 125, 10, 4, fill='aliceBlue', roundness=20, rotateAngle=45)
Star(75, 300, 10, 8, fill='hotPink', rotateAngle=20, roundness=30, opacity=80)

# jellyfish body
Circle(240, 350, 50, fill=rgb(250, 200, 230))
Circle(240, 350, 45, fill=rgb(250, 220, 240))
Rect(185, 350, 110, 150, fill='dodgerBlue')
Line(205, 370, 275, 370, fill=rgb(250, 220, 240), lineWidth=40, dashes=(10, 5))

# jellyfish eyes and mouth
Circle(218, 332, 5)
Circle(263, 332, 5)
Circle(218, 330, 2, fill='grey')
Circle(263, 330, 2, fill='grey')
Circle(240, 332, 7, fill=rgb(250, 120, 180))
Rect(230, 325, 20, 7, fill=rgb(250, 220, 240))

# bubble
bubble = Circle(200, 330, 10, fill=gradient('lightCyan', 'lavender'), opacity=30,
                border=gradient('plum', 'darkTurquoise', 'hotPink',
                                'gold', start='top'))

def onKeyHold(keys):
    # When the up key is held, move the bubble up by 5 pixels.
    if ('up' in keys):
        bubble.centerY -= 5

    # Increase the radius by 1, and reset if the radius gets bigger than 80.
    bubble.radius += 1
    if (bubble.radius > 80):
        bubble.radius = 10
        bubble.centerY = 330
",regular,1
2116,Underwater Tag,5.3,"app.background = gradient(rgb(135, 250, 250), rgb(15, 125, 195), start='top')

# fish
yellowFish = Polygon(140, 100, 100, 60, 110, 95, 90, 85, 100, 100, 90, 120,
                     110, 105, 100, 140,
                     fill=gradient('white', 'lemonChiffon', 'gold', 'darkOrange',
                                   start='right'))
yellowFishEye = Circle(130, 95, 3)
yellowFishScore = Label(0, 50, 100, fill='yellow', size=50)

purpleFish = Polygon(140, 300, 100, 260, 110, 295, 90, 285, 100, 300, 90, 320,
                     110, 305, 100, 340,
                     fill=gradient('white', 'lavender', 'orchid', 'darkOrchid',
                                   start='right'))
purpleFishEye = Circle(130, 295, 3)
purpleFishScore = Label(0, 50, 300, fill=rgb(210, 190, 255), size=50)

Label('Underwater Tag', 200, 20, size=22)
Label('When two fish collide, the fish on the left scores that point.', 200, 40)
Label('One fish moves faster up/down, the other moves faster left/right!', 200, 55)

def checkFishIntersection():
    # Check if the fish intersect and add a point for the fish that is further left.
    ### (HINT: What happens when the fish have the same x-coordinate?
    #          Play with the canvas or test cases to figure it out!)
    ### Place Your Code Here ###


    # This code resets the fish to their original locations. This should happen
    # only if the fish intersect.
    ### Fix Your Code Here ###
    yellowFish.centerX = 115
    yellowFish.centerY = 100
    yellowFishEye.centerX = 130
    yellowFishEye.centerY = 95

    purpleFish.centerX = 115
    purpleFish.centerY = 300
    purpleFishEye.centerX = 130
    purpleFishEye.centerY = 295


def checkFishWraparound(fish):
    # Check if a fish is outside the canvas bounds and wraparound. Use the
    # left, right, top, and bottom for wrapping, not centerX and centerY.
    ### Place Your Code Here ###
    pass

def moveEyes():
    # Moves the eyes of both fish relative to its body.
    yellowFishEye.centerX = yellowFish.centerX + 15
    yellowFishEye.centerY = yellowFish.centerY - 5
    purpleFishEye.centerX = purpleFish.centerX + 15
    purpleFishEye.centerY = purpleFish.centerY - 5

def onKeyHold(keys):
    # Move the fish in their respective directions.
    if ('w' in keys):
        yellowFish.centerY -= 10
    elif ('s' in keys):
        yellowFish.centerY += 10
    elif ('a' in keys):
        yellowFish.centerX -= 5
    elif ('d' in keys):
        yellowFish.centerX += 5

    if ('up' in keys):
        purpleFish.centerY -= 5
    elif ('down' in keys):
        purpleFish.centerY += 5
    elif ('left' in keys):
        purpleFish.centerX -= 10
    elif ('right' in keys):
        purpleFish.centerX += 10

    checkFishWraparound(yellowFish)
    checkFishWraparound(purpleFish)

    # Move the eyes.
    moveEyes()

    # Update score appropriately, if fish intersect each other.
    checkFishIntersection()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(135, 250, 250), rgb(15, 125, 195), start='top')

# fish
yellowFish = Polygon(140, 100, 100, 60, 110, 95, 90, 85, 100, 100, 90, 120,
                     110, 105, 100, 140,
                     fill=gradient('white', 'lemonChiffon', 'gold', 'darkOrange',
                                   start='right'))
yellowFishEye = Circle(130, 95, 3)
yellowFishScore = Label(0, 50, 100, fill='yellow', size=50)

purpleFish = Polygon(140, 300, 100, 260, 110, 295, 90, 285, 100, 300, 90, 320,
                     110, 305, 100, 340,
                     fill=gradient('white', 'lavender', 'orchid', 'darkOrchid',
                                   start='right'))
purpleFishEye = Circle(130, 295, 3)
purpleFishScore = Label(0, 50, 300, fill=rgb(210, 190, 255), size=50)

Label('Underwater Tag', 200, 20, size=22)
Label('When two fish collide, the fish on the left scores that point.', 200, 40)
Label('One fish moves faster up/down, the other moves faster left/right!', 200, 55)

def checkFishIntersection():
    # Check if the fish intersect and add a point for the fish that is further left.
    if (yellowFish.hitsShape(purpleFish) == True):
        if (yellowFish.centerX < purpleFish.centerX):
            yellowFishScore.value += 1
        else:
            purpleFishScore.value += 1

        # This code resets the fish to their original locations. This should happen
        # only if the fish intersect.
        yellowFish.centerX = 115
        yellowFish.centerY = 100
        yellowFishEye.centerX = 130
        yellowFishEye.centerY = 95

        purpleFish.centerX = 115
        purpleFish.centerY = 300
        purpleFishEye.centerX = 130
        purpleFishEye.centerY = 295

def checkFishWraparound(fish):
    # Check if a fish is outside the canvas bounds and wraparound. Use the
    # left, right, top, and bottom for wrapping, not centerX and centerY.
    if (fish.right < 0):
        fish.left = 400
    elif (fish.left > 400):
        fish.right = 0
    if (fish.bottom < 0):
        fish.top = 400
    elif (fish.top > 400):
        fish.bottom = 0

def moveEyes():
    # Moves the eyes of both fish relative to its body.
    yellowFishEye.centerX = yellowFish.centerX + 15
    yellowFishEye.centerY = yellowFish.centerY - 5
    purpleFishEye.centerX = purpleFish.centerX + 15
    purpleFishEye.centerY = purpleFish.centerY - 5

def onKeyHold(keys):
    # Move the fish in their respective directions.
    if ('w' in keys):
        yellowFish.centerY -= 10
    elif ('s' in keys):
        yellowFish.centerY += 10
    elif ('a' in keys):
        yellowFish.centerX -= 5
    elif ('d' in keys):
        yellowFish.centerX += 5

    if ('up' in keys):
        purpleFish.centerY -= 5
    elif ('down' in keys):
        purpleFish.centerY += 5
    elif ('left' in keys):
        purpleFish.centerX -= 10
    elif ('right' in keys):
        purpleFish.centerX += 10

    checkFishWraparound(yellowFish)
    checkFishWraparound(purpleFish)

    # Move the eyes.
    moveEyes()

    # Update score appropriately, if fish intersect each other.
    checkFishIntersection()
",regular,2
2113,Fireworks!,5.3,"app.background = 'black'

# background hills
Polygon(140, 400, 220, 310, 245, 330, 270, 290, 290, 300, 330, 245, 465, 400,
        fill=rgb(13, 34, 39))
Polygon(0, 400, 60, 310, 100, 365, 135, 345, 190, 400, fill=rgb(15, 24, 35))

fireworkTrail = Line(200, 380, 200, 580,
                     fill=gradient('red', 'yellow', 'black', start='top'))
firework = Star(200, 150, 150, 12, fill=None,
                border=gradient('red', 'yellow', 'black'), roundness=10,
                dashes=True, visible=False)

def explodeFirework():
    firework.centerY = fireworkTrail.top
    fireworkTrail.visible = False
    firework.visible = True

def onKeyPress(key):
    # Resets the firework on 'enter'.
    if (key == 'enter'):
        fireworkTrail.visible = True
        fireworkTrail.top = 380
        firework.visible = False

    # If space is pressed, explode the firework.
    ### Place Your Code Here ###

def onKeyHold(keys):
    if (firework.visible == False):
        # If left or right are held and the firework is not too close to the
        # edge of the canvas, move it in the corresponding direction by 5 pixels.
        ### Place Your Code Here ###

        # If 'up' is held, keep moving the firework up.
        ### Place Your Code Here ###
        pass

    # Once at a height of 150, explode the firework.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# background hills
Polygon(140, 400, 220, 310, 245, 330, 270, 290, 290, 300, 330, 245, 465, 400,
        fill=rgb(13, 34, 39))
Polygon(0, 400, 60, 310, 100, 365, 135, 345, 190, 400, fill=rgb(15, 24, 35))

fireworkTrail = Line(200, 380, 200, 580,
                     fill=gradient('red', 'yellow', 'black', start='top'))
firework = Star(200, 150, 150, 12, fill=None,
                border=gradient('red', 'yellow', 'black'), roundness=10,
                dashes=True, visible=False)

def explodeFirework():
    firework.centerY = fireworkTrail.top
    fireworkTrail.visible = False
    firework.visible = True

def onKeyPress(key):
    # Resets the firework on 'enter'.
    if (key == 'enter'):
        fireworkTrail.visible = True
        fireworkTrail.top = 380
        firework.visible = False

    # If space is pressed, explode the firework.
    if (key == 'space'):
        explodeFirework()

def onKeyHold(keys):
    if (firework.visible == False):
        # If left or right are held and the firework is not too close to the
        # edge of the canvas, move it in the corresponding direction by 5 pixels.
        if (('left' in keys) and (fireworkTrail.centerX > 15)):
            fireworkTrail.centerX -= 5
            firework.centerX -= 5
        elif (('right' in keys) and (fireworkTrail.centerX < 385)):
            fireworkTrail.centerX += 5
            firework.centerX += 5

        # If 'up' is held, keep moving the firework up.
        if ('up' in keys):
            fireworkTrail.top -= 5

    # Once at a height of 150, explode the firework.
    if (fireworkTrail.y1 <= 150):
        explodeFirework()
",regular,1
2112,"Red light, green light",5.3,"app.background = gradient('deepSkyBlue', 'lightSkyBlue', start='top')

Rect(0, 150, 400, 250, fill=gradient('forestGreen', 'limeGreen', start='bottom'))

# traffic light
Line(200, 75, 200, 65)
Line(0, 50, 200, 65)
Line(400, 50, 200, 65)
Rect(175, 75, 50, 100, fill='orange')
redLight = Circle(200, 100, 20, fill='red')
greenLight = Circle(200, 150, 20, fill='gray')
msg = Label('Stop!', 200, 350, size=20, bold=True)

# road
Rect(0, 200, 400, 100)
Line(0, 250, 400, 250, fill='yellow', lineWidth=3, dashes=True)

# car
car = Polygon(0, 211, 3, 210, 12, 210, 15, 211, 30, 211, 33, 210, 45, 210, 48, 220,
              48, 230, 45, 240, 33, 240, 30, 239, 15, 239, 12, 240, 3, 240, 0, 239,
              fill=gradient('royalBlue', 'mediumBlue'))
frontWindow = Polygon(40, 215, 42, 225, 40, 235, 30, 234, 30, 216)
backWindow = Rect(5, 215, 5, 20)
top = Polygon(10, 215, 30, 216, 30, 234, 10, 235, fill=None, border='black',
              borderWidth=1)

def moveCar(leftPosition):
    car.left = leftPosition
    frontWindow.left = leftPosition + 30
    backWindow.left = leftPosition + 5
    top.left = backWindow.right

def changeLight(redFill, greenFill, msgValue):
    redLight.fill = redFill
    greenLight.fill = greenFill
    msg.value = msgValue

def onKeyPress(key):
    # Changes the color of the light.
    if (key == 'enter'):
        if (msg.value == 'Go!'):
            changeLight('red', 'gray', 'Stop!')
        else:
            changeLight('gray', 'green', 'Go!')

def onKeyHold(keys):
    # Move the car forward or back to the starting point according to the
    # light color while the game is playing.
    ### (HINT: Make sure to update the message if needed!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'lightSkyBlue', start='top')

Rect(0, 150, 400, 250, fill=gradient('forestGreen', 'limeGreen', start='bottom'))

# traffic light
Line(200, 75, 200, 65)
Line(0, 50, 200, 65)
Line(400, 50, 200, 65)
Rect(175, 75, 50, 100, fill='orange')
redLight = Circle(200, 100, 20, fill='red')
greenLight = Circle(200, 150, 20, fill='gray')
msg = Label('Stop!', 200, 350, size=20, bold=True)

# road
Rect(0, 200, 400, 100)
Line(0, 250, 400, 250, fill='yellow', lineWidth=3, dashes=True)

# car
car = Polygon(0, 211, 3, 210, 12, 210, 15, 211, 30, 211, 33, 210, 45, 210, 48, 220,
              48, 230, 45, 240, 33, 240, 30, 239, 15, 239, 12, 240, 3, 240, 0, 239,
              fill=gradient('royalBlue', 'mediumBlue'))
frontWindow = Polygon(40, 215, 42, 225, 40, 235, 30, 234, 30, 216)
backWindow = Rect(5, 215, 5, 20)
top = Polygon(10, 215, 30, 216, 30, 234, 10, 235, fill=None, border='black',
              borderWidth=1)

def moveCar(leftPosition):
    car.left = leftPosition
    frontWindow.left = leftPosition + 30
    backWindow.left = leftPosition + 5
    top.left = backWindow.right

def changeLight(redFill, greenFill, msgValue):
    redLight.fill = redFill
    greenLight.fill = greenFill
    msg.value = msgValue

def onKeyPress(key):
    # Changes the color of the light.
    if (key == 'enter'):
        if (msg.value == 'Go!'):
            changeLight('red', 'gray', 'Stop!')
        else:
            changeLight('gray', 'green', 'Go!')

def onKeyHold(keys):
    # Move the car forward or back to the starting point according to the
    # light color while the game is playing.
    if (msg.value != 'Car wins!'):
        if ('space' in keys):
            if (redLight.fill == 'red'):
                moveCar(0)
            else:
                moveCar(car.left + 3)
                if (car.right > 400):
                    msg.value = 'Car wins!'
                    msg.fill = car.fill
",regular,3
2114,Biking,5.3,"# background
Rect(0, 0, 400, 275, fill='lightSkyBlue')
Rect(0, 275, 400, 125, fill='lightGreen')

# mountains
mountain1 = Polygon(140, 275, 240, 155, 290, 175, 330, 120, 465, 275,
                    fill=rgb(95, 155, 200))
mountain2 = Polygon(0, 275, 60, 185, 100, 240, 135, 220, 190, 275,
                    fill=rgb(95, 110, 175))

# left wheel of the bike
leftWheel = Star(100, 250, 55, 17, fill=None, border='black', roundness=0)
Circle(100, 250, 60, fill=None, border='black', borderWidth=5)
Circle(100, 250, 55, fill=None, border='grey', borderWidth=5)

# right wheel of the bike
rightWheel = Star(300, 250, 55, 17, fill=None, border='black', roundness=0)
Circle(300, 250, 60, fill=None, border='black', borderWidth=5)
Circle(300, 250, 55, fill=None, border='grey', borderWidth=5)

# bike frame
Polygon(100, 250, 180, 250, 275, 155, 150, 175, fill=None, border='red',
        borderWidth=5)
Line(300, 250, 265, 115, fill='red', lineWidth=5)
Line(180, 250, 140, 150, fill='red', lineWidth=5)
Oval(145, 155, 50, 10, rotateAngle=5, align='bottom')
Line(270, 115, 235, 110, lineWidth=5)

def moveMountainsLeft():
    # Moves the mountains left in relation to the bike.
    mountain1.centerX -= 10
    mountain2.centerX -= 15

    if (mountain1.right < 0):
        mountain1.left = 400
    if (mountain2.right < 0):
        mountain2.left = 400

def moveMountainsRight():
    # Move the mountains right in relation to the bike.
    ### Place Your Code Here ###
    pass

def onKeyHold(keys):
    # When the right key is held, rotate the wheels and move the mountains
    # appropriately so that it looks like the bike is moving forward.
    ### (HINT: Moving the mountains left will make your bike appear to move right.)
    if ('right' in keys):
        ### Fix Your Code Here ###
        moveMountainsRight()

    # When the left key is held, rotate the wheels and move the mountains
    # appropriately so that it looks like the bike is moving backward.
    ### Place Your Code Here
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 275, fill='lightSkyBlue')
Rect(0, 275, 400, 125, fill='lightGreen')

# mountains
mountain1 = Polygon(140, 275, 240, 155, 290, 175, 330, 120, 465, 275,
                    fill=rgb(95, 155, 200))
mountain2 = Polygon(0, 275, 60, 185, 100, 240, 135, 220, 190, 275,
                    fill=rgb(95, 110, 175))

# left wheel of the bike
leftWheel = Star(100, 250, 55, 17, fill=None, border='black', roundness=0)
Circle(100, 250, 60, fill=None, border='black', borderWidth=5)
Circle(100, 250, 55, fill=None, border='grey', borderWidth=5)

# right wheel of the bike
rightWheel = Star(300, 250, 55, 17, fill=None, border='black', roundness=0)
Circle(300, 250, 60, fill=None, border='black', borderWidth=5)
Circle(300, 250, 55, fill=None, border='grey', borderWidth=5)

# bike frame
Polygon(100, 250, 180, 250, 275, 155, 150, 175, fill=None, border='red',
        borderWidth=5)
Line(300, 250, 265, 115, fill='red', lineWidth=5)
Line(180, 250, 140, 150, fill='red', lineWidth=5)
Oval(145, 155, 50, 10, rotateAngle=5, align='bottom')
Line(270, 115, 235, 110, lineWidth=5)

def moveMountainsLeft():
    # Moves the mountains left in relation to the bike.
    mountain1.centerX -= 10
    mountain2.centerX -= 15

    if (mountain1.right < 0):
        mountain1.left = 400
    if (mountain2.right < 0):
        mountain2.left = 400

def moveMountainsRight():
    # Move the mountains right in relation to the bike.
    mountain1.centerX += 10
    mountain2.centerX += 15

    if (mountain1.left > 400):
        mountain1.right = 0
    if (mountain2.left > 400):
        mountain2.right = 0

def onKeyHold(keys):
    # Rotate the wheels of the bike and move the mountains appropriately.
    if ('right' in keys):
        leftWheel.rotateAngle += 5
        rightWheel.rotateAngle += 5
        moveMountainsLeft()
    elif ('left' in keys):
        leftWheel.rotateAngle -= 5
        rightWheel.rotateAngle -= 5
        moveMountainsRight()
",regular,2
2109,Jabber jaws,5.3,"app.background = 'lavenderBlush'
app.isMouthGrowing = False

noiseLines = Star(160, 220, 60, 8, roundness=10)
Rect(100, 140, 75, 160, fill='lavenderBlush')

# face
Oval(30, 140, 230, 350, fill='lightSkyBlue')
Polygon(0, 0, 130, 0, 145, 60, 180, 130, 145, 155, 0, 210, fill='lightSkyBlue')
Circle(80, 50, 15)

mouth = Polygon(145, 185, 80, 185, 95, 225, 140, 250, fill='lavenderBlush')

def onKeyHold(keys):
    # Depending on the variable app.isMouthGrowing, change the mouth's size,
    # reposition it on the boundary of the face, and change noiseLines.
    ### Place Your Code Here ###

    # Switch app.isMouthGrowing when the size of the mouth is too big or small.
    ### (HINT: Use the test cases to help figure out when too big and too
    #          small are!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lavenderBlush'
app.isMouthGrowing = False

noiseLines = Star(160, 220, 60, 8, roundness=10)
Rect(100, 140, 75, 160, fill='lavenderBlush')

# face
Oval(30, 140, 230, 350, fill='lightSkyBlue')
Polygon(0, 0, 130, 0, 145, 60, 180, 130, 145, 155, 0, 210, fill='lightSkyBlue')
Circle(80, 50, 15)

mouth = Polygon(145, 185, 80, 185, 95, 225, 140, 250, fill='lavenderBlush')

def onKeyHold(keys):
    # Depending on the variable app.isMouthGrowing, change the mouth's size,
    # reposition it on the boundary of the face, and change noiseLines.
    if (app.isMouthGrowing == True):
        mouth.width += 5
        mouth.height += 5
        mouth.right = 145
        noiseLines.radius += 5
    else:
        mouth.width -= 5
        mouth.height -= 5
        mouth.right = 145
        noiseLines.radius -= 5

    # Switch app.isMouthGrowing when the size of the mouth is too big or small.
    if ((mouth.width >= 70) or (mouth.height <= 10)):
        if (app.isMouthGrowing == True):
            app.isMouthGrowing = False
        else:
            app.isMouthGrowing = True
",regular,2
2110,Rotating Star,5.3,"app.background = gradient('black', 'midnightBlue', 'blue', start='left-top')

# background
Polygon(0, 0, 400, 220, 400, 400, 220, 400, fill='white', opacity=30)

# halo and the star
halo = Circle(0, 0, 30, fill=gradient('white', 'gold'), opacity=50)
halo.isGrowing = True

star = Star(0, 0, 1, 5, fill=gradient('lightYellow', 'gold'))

def onKeyHold(keys):
    # Check if the halo is growing and add or subtract accordingly from its size.
    ### Place Your Code Here ###

    # If the radius is bigger than 50 or smaller than 20, change halo.isGrowing.
    ### Place Your Code Here ###

    # If right is held, increase the centerX, centerY, and rotateAngle by 5
    # and the radius by 1. Also, wrap around from right-bottom corner to left-top
    # corner and reset the radius of the star to 1.
    ### Place Your Code Here ###

    halo.centerX = star.centerX
    halo.centerY = star.centerY
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('black', 'midnightBlue', 'blue', start='left-top')

# background
Polygon(0, 0, 400, 220, 400, 400, 220, 400, fill='white', opacity=30)

# halo and the star
halo = Circle(0, 0, 30, fill=gradient('white', 'gold'), opacity=50)
halo.isGrowing = True

star = Star(0, 0, 1, 5, fill=gradient('lightYellow', 'gold'))

def onKeyHold(keys):
    # Check if the halo is growing and add or subtract accordingly from its size.
    if (halo.isGrowing == True):
        halo.radius += 1
    else:
        halo.radius -= 1

    # If the radius is bigger than 50 or smaller than 20, change halo.isGrowing.
    if (halo.radius > 50):
        halo.isGrowing = False
    if (halo.radius < 20):
        halo.isGrowing = True

    # If right is held, increase the centerX, centerY, and rotateAngle by 5
    # and the radius by 1. Also, wrap around from right-bottom corner to left-top
    # corner and reset the radius of the star to 1.
    if ('right' in keys):
        star.centerX += 5
        star.centerY += 5
        star.rotateAngle += 5
        star.radius += 1

        if (star.centerX >= 400):
            star.centerX = 0
            star.centerY = 0
            star.radius = 1

    halo.centerX = star.centerX
    halo.centerY = star.centerY
",regular,1
2111,Surprised Face,5.3,"app.background = 'seaGreen'

# eyes
Oval(110, 120, 70, 120, fill='white')
Oval(290, 120, 70, 120, fill='white')
Oval(110, 120, 50, 80, fill=gradient('skyBlue', 'skyBlue', 'blue'))
Oval(290, 120, 50, 80, fill=gradient('skyBlue', 'skyBlue', 'blue'))
Oval(110, 120, 30, 50)
Oval(290, 120, 30, 50)

mouth = Oval(200, 320, 40, 5, fill='pink', border='black', borderWidth=4)

def expandHorizontal():
    mouth.width += 2

def expandVertical():
    mouth.height += 2

def onKeyHold(keys):
    # Expand based on the keys held.
    ### (HINT: Use compound conditionals to check that both arrow keys
    #          are being pressed and use the helper functions.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'seaGreen'

# eyes
Oval(110, 120, 70, 120, fill='white')
Oval(290, 120, 70, 120, fill='white')
Oval(110, 120, 50, 80, fill=gradient('skyBlue', 'skyBlue', 'blue'))
Oval(290, 120, 50, 80, fill=gradient('skyBlue', 'skyBlue', 'blue'))
Oval(110, 120, 30, 50)
Oval(290, 120, 30, 50)

mouth = Oval(200, 320, 40, 5, fill='pink', border='black', borderWidth=4)

def expandHorizontal():
    mouth.width += 2

def expandVertical():
    mouth.height += 2

def onKeyHold(keys):
    # Expand based on the keys held.
    if (('left' in keys) and ('right' in keys)):
        expandHorizontal()
    if (('up' in keys) and ('down' in keys)):
        expandVertical()
",regular,1
2115,Flapping bird,5.3,"app.background = gradient('deepSkyBlue', 'skyBlue', start='top')

# clouds
Circle(-10, 350, 60, fill='white', border='gainsboro', borderWidth=3)
Circle(55, 380, 50, fill='white', border='gainsboro', borderWidth=3)
Rect(0, 340, 30, 60, fill='white')
Circle(340, 75, 50, fill='white', border='gainsboro', borderWidth=3)
Circle(260, 120, 70, fill='white', border='gainsboro', borderWidth=3)
Circle(410, 120, 60, fill='white', border='gainsboro', borderWidth=3)
Circle(330, 150, 80, fill='white', border='gainsboro')
Rect(295, 60, 20, 11, fill='white')
Rect(365, 65, 20, 13, fill='white')
Rect(245, 90, 155, 95, fill='white')

# bird wings
leftWing = Polygon(175, 230, 185, 205, 145, 195, 130, 195, 155, 210,
                   fill='violet')
rightWing = Polygon(225, 230, 215, 205, 255, 195, 270, 195, 245, 210,
                    fill='violet')
app.wingsMovingUp = True

# bird body
body = Oval(200, 250, 80, 65, fill='violet', align='bottom')
belly = Oval(200, 250, 65, 40, fill='pink', align='bottom')

# bird eyes
leftEye = Circle(190, 190, 12, border='white', borderWidth=7)
rightEye = Circle(210, 190, 12, border='white', borderWidth=7)

# bird beak
beak = Polygon(200, 195, 210, 200, 200, 215, 190, 200, fill='gold')

def moveBird(bodyX, bodyY):
    # Moves all the individual pieces of the bird (besides the body).
    belly.centerX = bodyX
    belly.bottom = body.bottom

    leftEye.centerX = bodyX - 10
    rightEye.centerX = bodyX + 10
    leftEye.centerY = body.top + 5
    rightEye.centerY = body.top + 5

    beak.centerX = bodyX
    beak.bottom = belly.top + 5

    leftWing.centerX = body.left - 8
    rightWing.centerX = body.right + 8
    leftWing.centerY = bodyY - 5
    rightWing.centerY = bodyY - 5

def onKeyHold(keys):
    # Change the center of the body based on the 'w','a','s','d' keys.
    ### Place Your Code Here ###

    # When moving up or down, flap the wings 5 degrees in the direction that
    # app.wingsMovingUp indicates. If the angle is less than -40 or larger
    # than 0, app.wingsMovingUp should change.
    ### Place Your Code Here ###

    # Move the bird based on the new center of the body.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'skyBlue', start='top')

# clouds
Circle(-10, 350, 60, fill='white', border='gainsboro', borderWidth=3)
Circle(55, 380, 50, fill='white', border='gainsboro', borderWidth=3)
Rect(0, 340, 30, 60, fill='white')
Circle(340, 75, 50, fill='white', border='gainsboro', borderWidth=3)
Circle(260, 120, 70, fill='white', border='gainsboro', borderWidth=3)
Circle(410, 120, 60, fill='white', border='gainsboro', borderWidth=3)
Circle(330, 150, 80, fill='white', border='gainsboro')
Rect(295, 60, 20, 11, fill='white')
Rect(365, 65, 20, 13, fill='white')
Rect(245, 90, 155, 95, fill='white')

# bird wings
leftWing = Polygon(175, 230, 185, 205, 145, 195, 130, 195, 155, 210,
                   fill='violet')
rightWing = Polygon(225, 230, 215, 205, 255, 195, 270, 195, 245, 210,
                    fill='violet')
app.wingsMovingUp = True

# bird body
body = Oval(200, 250, 80, 65, fill='violet', align='bottom')
belly = Oval(200, 250, 65, 40, fill='pink', align='bottom')

# bird eyes
leftEye = Circle(190, 190, 12, border='white', borderWidth=7)
rightEye = Circle(210, 190, 12, border='white', borderWidth=7)

# bird beak
beak = Polygon(200, 195, 210, 200, 200, 215, 190, 200, fill='gold')

def moveBird(bodyX, bodyY):
    # Moves all the individual pieces of the bird (besides the body).
    belly.centerX = bodyX
    belly.bottom = body.bottom

    leftEye.centerX = bodyX - 10
    rightEye.centerX = bodyX + 10
    leftEye.centerY = body.top + 5
    rightEye.centerY = body.top + 5

    beak.centerX = bodyX
    beak.bottom = belly.top + 5

    leftWing.centerX = body.left - 8
    rightWing.centerX = body.right + 8
    leftWing.centerY = bodyY - 5
    rightWing.centerY = bodyY - 5

def onKeyHold(keys):
    # Change the center of the body based on the 'w','a','s','d' keys.
    if ('a' in keys):
        body.centerX -= 2
    if ('d' in keys):
        body.centerX += 2
    if ('s' in keys):
        body.centerY += 2
    if ('w' in keys):
        body.centerY -= 2

    # When moving up or down, flap the wings 5 degrees in the direction that
    # app.wingsMovingUp indicates. If the angle is less than -40 or larger
    # than 0, app.wingsMovingUp should change.
    if (('s' in keys) or ('w' in keys)):
        if (app.wingsMovingUp == True):
            leftWing.rotateAngle += 5
            rightWing.rotateAngle -= 5
        else:
            leftWing.rotateAngle -= 5
            rightWing.rotateAngle += 5

        if ((leftWing.rotateAngle < -40) or (leftWing.rotateAngle > 0)):
            if (app.wingsMovingUp == False):
                app.wingsMovingUp = True
            else:
                app.wingsMovingUp = False

    # Move the bird based on the new center of the body.
    moveBird(body.centerX, body.centerY)
",regular,3
2121,Creative task 4,5.4,# Fill me in!,,creative,30
2122,Creative task 5,5.4,# Fill me in!,,creative,30
2118,Creative task 1,5.4,# Fill me in!,,creative,30
2123,Collaborative task,5.4,# Fill me in!,,creative,30
2117,Takeoff,5.4,"app.background = gradient('deepSkyBlue', 'lightBlue', start='top')

# ground
grass = Rect(200, 270, 800, 260, fill=gradient('mediumSeaGreen', 'darkGreen'),
             align='center')
runway = Rect(200, 280, 800, 160, fill='grey', align='center')
centerLines = Line(0, 280, 400, 280, fill='yellow', lineWidth=5, dashes=(20, 15))

# airplane landing gear
frontWheel = Circle(295, 280, 3)
frontSupport = Line(295, 270, 295, 280)
backWheel1 = Circle(140, 280, 3)
backSupport1 = Line(140, 270, 140, 280)

# airplane body and tail
Polygon(80, 235, 40, 235, 30, 175, fill='gainsboro')
Rect(190, 250, 180, 40, fill=gradient('whiteSmoke', 'darkGrey', start='top'),
     align='center')
Polygon(280, 230, 300, 233, 312, 238, 322, 245, 328, 255, 320, 265, 310, 270,
        280, 270, fill=gradient('whiteSmoke', 'darkGrey', start='top'))
Polygon(100, 230, 35, 235, 35, 240, 100, 270,
        fill=gradient('whiteSmoke', 'darkGrey', start='top'))

# airplane wings
Polygon(185, 270, 175, 270, 170, 280, fill='darkGrey')
Polygon(165, 255, 200, 255, 145, 285, fill='gainsboro')

# airplane windows
Line(100, 245, 295, 245, dashes=True)
Polygon(300, 238, 300, 245, 320, 245, 310, 238)

# sun
sun = Circle(375, 30, 50, fill=gradient('yellow', 'beige'), border='gold')

# clouds (cloud1 farthest left, cloud2 middle, cloud3 farthest right)
cloud1 = Oval(650, -225, 750, 450, fill='white')
cloud2 = Oval(800, -350, 500, 350, fill='white')
cloud3 = Oval(1000, -200, 600, 400, fill='white')

def moveSun(dy):
    sun.centerY += dy

def moveClouds(dx, dy):
    # dx is the amount the clouds move left, dy the amount they move down.
    cloud1.centerX -= dx
    cloud2.centerX -= dx
    cloud3.centerX -= dx
    cloud1.centerY += dy
    cloud2.centerY += dy
    cloud3.centerY += dy

    # Wrap the clouds around.
    if (cloud3.right < 0):
        cloud1.centerX = 800
        cloud2.centerX = 950
        cloud3.centerX = 1150

def liftLandingGear():
    # Hide all of the wheels.
    frontWheel.visible = False
    frontSupport.visible = False
    backWheel1.visible = False
    backSupport1.visible = False

def takeOff():
    # Rotate the ground as if the plane tilted up.
    grass.rotateAngle += 0.25
    runway.rotateAngle += 0.25
    centerLines.rotateAngle += 0.25

    # Move the ground down as if the plane is lifting off.
    grass.centerY += 5
    runway.centerY += 5
    centerLines.centerY += 5

def onKeyPress(key):
    if (key == 'space'):
        liftLandingGear()

def onKeyHold(keys):
    # Move the runway lines to make it seem like the runway is moving.
    if ('right' in keys):
        centerLines.centerX -= 10
        centerLines.x2 = 400

    # If both right and up keys are held down, the plane should be flying.
    # Until the grass has dropped below the canvas, the plane should in takeoff
    # mode and the sun should move down by 2 pixels at a time.
    if (('right' in keys) and ('up' in keys)):
        if (grass.top < 400):
            takeOff()
            moveSun(2)

        # Once the ground is gone, check if the 3rd cloud's top value is
        # less than 350. If it is, move the cloud down and to the left by 5.
        elif (cloud3.top < 350):
            moveClouds(5, 5)

        # If the first two statements are false, then check if the
        # sun's centerY value is greater than 30. If it is, then move the
        # clouds left by 5 and the sun up by 2.
        elif (sun.centerY > 30):
            moveClouds(5, 0)
            moveSun(-2)

        # If nothing above was true, you should just move the clouds left by 5.
        else:
            moveClouds(5, 0)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'lightBlue', start='top')

# ground
grass = Rect(200, 270, 800, 260, fill=gradient('mediumSeaGreen', 'darkGreen'),
             align='center')
runway = Rect(200, 280, 800, 160, fill='grey', align='center')
centerLines = Line(0, 280, 400, 280, fill='yellow', lineWidth=5, dashes=(20, 15))

# airplane landing gear
frontWheel = Circle(295, 280, 3)
frontSupport = Line(295, 270, 295, 280)
backWheel1 = Circle(140, 280, 3)
backSupport1 = Line(140, 270, 140, 280)

# airplane body and tail
Polygon(80, 235, 40, 235, 30, 175, fill='gainsboro')
Rect(190, 250, 180, 40, fill=gradient('whiteSmoke', 'darkGrey', start='top'),
     align='center')
Polygon(280, 230, 300, 233, 312, 238, 322, 245, 328, 255, 320, 265, 310, 270,
        280, 270, fill=gradient('whiteSmoke', 'darkGrey', start='top'))
Polygon(100, 230, 35, 235, 35, 240, 100, 270,
        fill=gradient('whiteSmoke', 'darkGrey', start='top'))

# airplane wings
Polygon(185, 270, 175, 270, 170, 280, fill='darkGrey')
Polygon(165, 255, 200, 255, 145, 285, fill='gainsboro')

# airplane windows
Line(100, 245, 295, 245, dashes=True)
Polygon(300, 238, 300, 245, 320, 245, 310, 238)

# sun
sun = Circle(375, 30, 50, fill=gradient('yellow', 'beige'), border='gold')

# clouds (cloud1 farthest left, cloud2 middle, cloud3 farthest right)
cloud1 = Oval(650, -225, 750, 450, fill='white')
cloud2 = Oval(800, -350, 500, 350, fill='white')
cloud3 = Oval(1000, -200, 600, 400, fill='white')

def moveSun(dy):
    sun.centerY += dy

def moveClouds(dx, dy):
    # dx is the amount the clouds move left, dy the amount they move down.
    cloud1.centerX -= dx
    cloud2.centerX -= dx
    cloud3.centerX -= dx
    cloud1.centerY += dy
    cloud2.centerY += dy
    cloud3.centerY += dy

    # Wrap the clouds around.
    if (cloud3.right < 0):
        cloud1.centerX = 800
        cloud2.centerX = 950
        cloud3.centerX = 1150

def liftLandingGear():
    # Hide all of the wheels.
    frontWheel.visible = False
    frontSupport.visible = False
    backWheel1.visible = False
    backSupport1.visible = False

def takeOff():
    # Rotate the ground as if the plane tilted up.
    grass.rotateAngle += 0.25
    runway.rotateAngle += 0.25
    centerLines.rotateAngle += 0.25

    # Move the ground down as if the plane is lifting off.
    grass.centerY += 5
    runway.centerY += 5
    centerLines.centerY += 5

def onKeyPress(key):
    if (key == 'space'):
        liftLandingGear()

def onKeyHold(keys):
    # Move the runway lines to make it seem like the runway is moving.
    if ('right' in keys):
        centerLines.centerX -= 10
        centerLines.x2 = 400

    # If both right and up keys are held down, the plane should be flying.
    # Until the grass has dropped below the canvas, the plane should in takeoff
    # mode and the sun should move down by 2 pixels at a time.
    if (('right' in keys) and ('up' in keys)):
        if (grass.top < 400):
            takeOff()
            moveSun(2)

        # Once the ground is gone, check if the 3rd cloud's top value is
        # less than 350. If it is, move the cloud down and to the left by 5.
        elif (cloud3.top < 350):
            moveClouds(5, 5)

        # If the first two statements are false, then check if the
        # sun's centerY value is greater than 30. If it is, then move the
        # clouds left by 5 and the sun up by 2.
        elif (sun.centerY > 30):
            moveClouds(5, 0)
            moveSun(-2)

        # If nothing above was true, you should just move the clouds left by 5.
        else:
            moveClouds(5, 0)
",regular,3
2119,Creative task 2,5.4,# Fill me in!,,creative,30
2120,Creative task 3,5.4,# Fill me in!,,creative,30
2126,Pull up stick person,6.1.3,"app.background = gradient(rgb(150, 225, 175), rgb(95, 180, 155), start='top')

leftArm = Line(200, 190, 140, 100, fill=rgb(70, 75, 75), lineWidth=5)
rightArm = Line(200, 190, 260, 100, fill=rgb(70, 75, 75), lineWidth=5)
stickPerson = Group(
    Circle(200, 140, 30, fill=rgb(70, 75, 75)),
    Line(200, 170, 200, 275, fill=rgb(70, 75, 75), lineWidth=6),
    Line(200, 275, 150, 325, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 275, 250, 325, fill=rgb(70, 75, 75), lineWidth=5),
    leftArm,
    rightArm
    )
stickPerson.bottom = 325

# pull up bar
Line(50, 100, 350, 100,
     fill=gradient('gainsboro', 'silver', 'gainsboro', start='top'), lineWidth=6)
Line(50, 100, 50, 400,
     fill=gradient('gainsboro', 'silver', 'gainsboro', start='top'), lineWidth=6)
Line(350, 100, 350, 400,
     fill=gradient('gainsboro', 'silver', 'gainsboro', start='top'), lineWidth=6)

pullUpCounter = Label(0, 100, 60, fill=rgb(70, 75, 75), size=25)

def onKeyPress(key):
    # Increase the number of pull-ups done.
    ### Place Your Code Here ###

    # Move the stickPerson group up.
    ### (HINT: Use the bottom property!)
    ### Place Your Code Here ###

    # Then change the left and right arm, so they are gripping the bar.
    ### (HINT: Change the y2 values of the arms.)
    ### Place Your Code Here ###
    pass

def onKeyRelease(key):
    # Move the stickPerson group down.
    ### (HINT: Use the bottom property!)
    ### Place Your Code Here ###

    # Then change the left and right arm, so they are gripping the bar.
    ### (HINT: Reset the y2 values of the arms.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(150, 225, 175), rgb(95, 180, 155), start='top')

leftArm = Line(200, 190, 140, 100, fill=rgb(70, 75, 75), lineWidth=5)
rightArm = Line(200, 190, 260, 100, fill=rgb(70, 75, 75), lineWidth=5)
stickPerson = Group(
    Circle(200, 140, 30, fill=rgb(70, 75, 75)),
    Line(200, 170, 200, 275, fill=rgb(70, 75, 75), lineWidth=6),
    Line(200, 275, 150, 325, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 275, 250, 325, fill=rgb(70, 75, 75), lineWidth=5),
    leftArm,
    rightArm
    )
stickPerson.bottom = 325

# pull up bar
Line(50, 100, 350, 100,
     fill=gradient('gainsboro', 'silver', 'gainsboro', start='top'), lineWidth=6)
Line(50, 100, 50, 400,
     fill=gradient('gainsboro', 'silver', 'gainsboro', start='top'), lineWidth=6)
Line(350, 100, 350, 400,
     fill=gradient('gainsboro', 'silver', 'gainsboro', start='top'), lineWidth=6)

pullUpCounter = Label(0, 100, 60, fill=rgb(70, 75, 75), size=25)

def onKeyPress(key):
    # Increase the number of pull-ups done.
    pullUpCounter.value += 1

    # Move the stickPerson group up.
    # Then change the left and right arm, so they are gripping the bar.
    stickPerson.bottom = 250
    leftArm.y2 = 100
    rightArm.y2 = 100

def onKeyRelease(key):
    # Move the stickPerson group down.
    # Then change the left and right arm, so they are gripping the bar.
    stickPerson.bottom = 325
    leftArm.y2 = 100
    rightArm.y2 = 100
",regular,1
2130,Ghost colors,6.1.3,"app.background = 'black'

# buttons
cyanButton = Circle(100, 350, 20, fill='cyan')
magentaButton = Circle(200, 350, 20, fill='magenta')
yellowButton = Circle(300, 350, 20, fill='yellow')

ghost = Group(
    Circle(200, 150, 100),
    Rect(100, 150, 200, 100),
    Circle(125, 250, 25),
    Circle(175, 250, 25),
    Circle(225, 250, 25),
    Circle(275, 250, 25)
    )

# ghost eyes
Circle(150, 150, 20)
Circle(250, 150, 20)

def onMousePress(mouseX, mouseY):
    # If the mouse clicks on a color button, the ghost should change color
    # accordingly.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# buttons
cyanButton = Circle(100, 350, 20, fill='cyan')
magentaButton = Circle(200, 350, 20, fill='magenta')
yellowButton = Circle(300, 350, 20, fill='yellow')

ghost = Group(
    Circle(200, 150, 100),
    Rect(100, 150, 200, 100),
    Circle(125, 250, 25),
    Circle(175, 250, 25),
    Circle(225, 250, 25),
    Circle(275, 250, 25)
    )

# ghost eyes
Circle(150, 150, 20)
Circle(250, 150, 20)

def onMousePress(mouseX, mouseY):
    # If the mouse clicks on a color button, the ghost should change color
    # accordingly.
    if (cyanButton.contains(mouseX, mouseY) == True):
        ghost.fill = 'cyan'
    elif (magentaButton.contains(mouseX, mouseY) == True):
        ghost.fill = 'magenta'
    elif (yellowButton.contains(mouseX, mouseY) == True):
        ghost.fill = 'yellow'
",regular,1
2129,Hungry giraffe,6.1.3,"app.background = 'lightSkyBlue'

# neck
giraffeNeck = Group(
    Rect(200, 200, 75, 400, align='top',
         fill=gradient('goldenrod', 'gold', 'gold', start='top')),
    Circle(180, 300, 15, fill='sienna'),
    Circle(220, 325, 15, fill='sienna'),
    Circle(185, 375, 20, fill='sienna'),
    Circle(225, 400, 10, fill='sienna'),
    Circle(180, 430, 10, fill='sienna'),
    Circle(220, 455, 15, fill='sienna'),
    Circle(185, 510, 20, fill='sienna'),
    Circle(225, 535, 10, fill='sienna')
    )

# face
giraffeFace = Group(
    Line(160, 155, 135, 130, fill='sienna', lineWidth=12),
    Circle(135, 130, 10, fill='sienna'),
    Line(240, 155, 265, 130, fill='sienna', lineWidth=12),
    Circle(265, 130, 10, fill='sienna'),
    Oval(200, 200, 135, 150, fill='gold'),
    Oval(200, 200, 100, 75, fill='moccasin', align='top'),
    Oval(165, 175, 10, 20, align='top'),
    Oval(235, 175, 10, 20, align='top'),
    Circle(185, 220, 3, fill='sienna'),
    Circle(215, 220, 3, fill='sienna')
    )

# smile
giraffeSmile = Group(
    Circle(200, 350, 15, fill='pink'),
    Rect(200, 350, 30, 15, fill='moccasin', align='bottom')
    )
giraffeSmile.visible = False

# leaf
leaf = Group(
    Line(0, 20, 7, 20, fill='sienna', lineWidth=1),
    Line(5, 20, 5, 22, fill='lightGreen', lineWidth=5),
    Line(5, 22, 30, 45, fill='lightGreen', lineWidth=5),
    Oval(50, 50, 50, 30, fill='lightGreen', rotateAngle=15),
    Polygon(72, 47, 85, 65, 55, 66, fill='lightGreen')
    )

def onMouseMove(mouseX, mouseY):
    # Move the giraffe's face to the same height as the mouse,
    # and neck accordingly.
    ### Place Your Code Here ###

    # If the giraffe reaches the leaf, it should eat the leaf and smile.
    # Otherwise, it shouldn't smile, and the leaf should stay in the
    # initial location.
    ### (HINT: The smile is 50 pixels below the center of the face.)
    ### (HINT: To place the leaf, use the center of the smile!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightSkyBlue'

# neck
giraffeNeck = Group(
    Rect(200, 200, 75, 400, align='top',
         fill=gradient('goldenrod', 'gold', 'gold', start='top')),
    Circle(180, 300, 15, fill='sienna'),
    Circle(220, 325, 15, fill='sienna'),
    Circle(185, 375, 20, fill='sienna'),
    Circle(225, 400, 10, fill='sienna'),
    Circle(180, 430, 10, fill='sienna'),
    Circle(220, 455, 15, fill='sienna'),
    Circle(185, 510, 20, fill='sienna'),
    Circle(225, 535, 10, fill='sienna')
    )

# face
giraffeFace = Group(
    Line(160, 155, 135, 130, fill='sienna', lineWidth=12),
    Circle(135, 130, 10, fill='sienna'),
    Line(240, 155, 265, 130, fill='sienna', lineWidth=12),
    Circle(265, 130, 10, fill='sienna'),
    Oval(200, 200, 135, 150, fill='gold'),
    Oval(200, 200, 100, 75, fill='moccasin', align='top'),
    Oval(165, 175, 10, 20, align='top'),
    Oval(235, 175, 10, 20, align='top'),
    Circle(185, 220, 3, fill='sienna'),
    Circle(215, 220, 3, fill='sienna')
    )

# smile
giraffeSmile = Group(
    Circle(200, 350, 15, fill='pink'),
    Rect(200, 350, 30, 15, fill='moccasin', align='bottom')
    )
giraffeSmile.visible = False

# leaf
leaf = Group(
    Line(0, 20, 7, 20, fill='sienna', lineWidth=1),
    Line(5, 20, 5, 22, fill='lightGreen', lineWidth=5),
    Line(5, 22, 30, 45, fill='lightGreen', lineWidth=5),
    Oval(50, 50, 50, 30, fill='lightGreen', rotateAngle=15),
    Polygon(72, 47, 85, 65, 55, 66, fill='lightGreen')
    )

def onMouseMove(mouseX, mouseY):
    # Move the giraffe's face to the same height as the mouse,
    # and neck accordingly.
    giraffeNeck.top = mouseY
    giraffeFace.centerY = mouseY

    # If the giraffe reaches the leaf, it should eat the leaf and smile.
    # Otherwise, it shouldn't smile, and the leaf should stay in the
    # initial location.
    if (mouseY < 100):
        giraffeSmile.centerY = giraffeFace.centerY + 50
        leaf.left = giraffeSmile.centerX
        leaf.top = giraffeSmile.centerY
        giraffeSmile.visible = True
    else:
        giraffeSmile.visible = False
        leaf.left = 0
        leaf.top = 20
",regular,3
2128,Metamorphosis,6.1.3,"app.background = 'skyBlue'

# Stores the current phase that the butterfly is in.
app.phase = 'caterpillar'

# tree
Rect(300, 0, 100, 400, fill=gradient('sienna', 'brown', start='left'))
Oval(-50, 420, 800, 500, fill=None,
     border=gradient('sienna', 'brown', start='top'), borderWidth=60)
Star(0, 80, 60, 6, fill=gradient('green', 'limeGreen'), roundness=50,
     rotateAngle=-20)
Line(10, 105, 50, 190, fill='sienna', lineWidth=25)

egg = RegularPolygon(290, 280, 20, 8, fill=gradient('papayaWhip', 'burlyWood'))

caterpillar = Group(
    RegularPolygon(40, 105, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    RegularPolygon(50, 125, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    RegularPolygon(60, 145, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    RegularPolygon(70, 165, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    Circle(40, 100, 2),
    Polygon(53, 98, 53, 115, 62, 117, 62, 132, 73, 138, 73, 154, 83, 157,
            fill=gradient('darkGreen', 'green', start='right-top'))
    )
caterpillar.opacity = 0

cocoon = Polygon(130, 250, 150, 275, 155, 315, 130, 335, 105, 315, 110, 275,
                 fill=gradient('limeGreen', 'darkGreen', 'black'), opacity=0)

butterfly = Group(
    Polygon(175, 85, 70, 5, 115, 115, 175, 95, 235, 115, 275, 5),
    Polygon(175, 100, 125, 125, 145, 155, 175, 100, 205, 155, 225, 125),
    Line(175, 85, 170, 71, fill='teal'),
    Line(175, 85, 180, 71, fill='teal'),

    # wing patterns
    Polygon(175, 90, 90, 30, 100, 55,
            fill=gradient('lime', 'darkGreen', start='right')),
    Polygon(175, 92, 105, 70, 120, 95,
            fill=gradient('lime', 'darkGreen', start='right')),
    Polygon(160, 115, 135, 130, 145, 140, fill=None, borderWidth=3,
            border=gradient('lime', 'darkGreen', start='left')),

    Polygon(175, 90, 260, 30, 250, 55,
            fill=gradient('lime', 'darkGreen', start='left')),
    Polygon(175, 92, 245, 70, 230, 95,
            fill=gradient('lime', 'darkGreen', start='left')),
    Polygon(190, 115, 215, 130, 205, 140, fill=None, borderWidth=3,
            border=gradient('lime', 'darkGreen', start='right')),

    # body and decoration
    Oval(175, 95, 9, 30, fill='teal'),
    Circle(145, 155, 4, fill='teal'),
    Circle(205, 155, 4, fill='teal'),
    )
butterfly.rotateAngle = 10
butterfly.opacity = 0

def onKeyHold(keys):
    # If 'space' is held, progresses the life cycle forward.
    if ('space' in keys):
        # In each phase of the butterfly's life, the opacities of the two
        # appropriate shapes (or groups) should increase or decrease by 2.
        ### (HINT: The final phase is already written for you below.)
        ### (HINT: The phases are changed at the end of the function, so
        #          look to see what they are called!)
        ### Place Your Code Here ###

        if ((app.phase == 'butterfly') and (butterfly.opacity < 100)):
            # Decrease the cocoon opacity and increase the butterfly opacity.
            cocoon.opacity -= 2
            butterfly.opacity += 2

        # Changes the phases.
        if ((caterpillar.opacity == 100) and (app.phase == 'caterpillar')):
            app.phase = 'cocoon'
        if ((cocoon.opacity == 100) and (app.phase == 'cocoon')):
            app.phase='butterfly'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'skyBlue'

# Stores the current phase that the butterfly is in.
app.phase = 'caterpillar'

# tree
Rect(300, 0, 100, 400, fill=gradient('sienna', 'brown', start='left'))
Oval(-50, 420, 800, 500, fill=None,
     border=gradient('sienna', 'brown', start='top'), borderWidth=60)
Star(0, 80, 60, 6, fill=gradient('green', 'limeGreen'), roundness=50,
     rotateAngle=-20)
Line(10, 105, 50, 190, fill='sienna', lineWidth=25)

egg = RegularPolygon(290, 280, 20, 8, fill=gradient('papayaWhip', 'burlyWood'))

caterpillar = Group(
    RegularPolygon(40, 105, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    RegularPolygon(50, 125, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    RegularPolygon(60, 145, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    RegularPolygon(70, 165, 15, 6, fill=gradient('darkGreen', 'green', 'yellow',
                                                 start='right-top')),
    Circle(40, 100, 2),
    Polygon(53, 98, 53, 115, 62, 117, 62, 132, 73, 138, 73, 154, 83, 157,
            fill=gradient('darkGreen', 'green', start='right-top'))
    )
caterpillar.opacity = 0

cocoon = Polygon(130, 250, 150, 275, 155, 315, 130, 335, 105, 315, 110, 275,
                 fill=gradient('limeGreen', 'darkGreen', 'black'), opacity=0)

butterfly = Group(
    Polygon(175, 85, 70, 5, 115, 115, 175, 95, 235, 115, 275, 5),
    Polygon(175, 100, 125, 125, 145, 155, 175, 100, 205, 155, 225, 125),
    Line(175, 85, 170, 71, fill='teal'),
    Line(175, 85, 180, 71, fill='teal'),

    # wing patterns
    Polygon(175, 90, 90, 30, 100, 55,
            fill=gradient('lime', 'darkGreen', start='right')),
    Polygon(175, 92, 105, 70, 120, 95,
            fill=gradient('lime', 'darkGreen', start='right')),
    Polygon(160, 115, 135, 130, 145, 140, fill=None, borderWidth=3,
            border=gradient('lime', 'darkGreen', start='left')),

    Polygon(175, 90, 260, 30, 250, 55,
            fill=gradient('lime', 'darkGreen', start='left')),
    Polygon(175, 92, 245, 70, 230, 95,
            fill=gradient('lime', 'darkGreen', start='left')),
    Polygon(190, 115, 215, 130, 205, 140, fill=None, borderWidth=3,
            border=gradient('lime', 'darkGreen', start='right')),

    # body and decoration
    Oval(175, 95, 9, 30, fill='teal'),
    Circle(145, 155, 4, fill='teal'),
    Circle(205, 155, 4, fill='teal'),
    )
butterfly.rotateAngle = 10
butterfly.opacity = 0

def onKeyHold(keys):
    # If 'space' is held, progresses the life cycle forward.
    if ('space' in keys):
        # In each phase of the butterfly's life, the opacities of the two
        # appropriate shapes (or groups) should increase or decrease by 2.
        # Decrease the egg opacity and increase the caterpillar opacity.
        if (app.phase == 'caterpillar'):
            egg.opacity -= 2
            caterpillar.opacity += 2

        # Decrease the caterpillar opacity and increase the cocoon opacity.
        if (app.phase == 'cocoon'):
            caterpillar.opacity -= 2
            cocoon.opacity += 2

        if ((app.phase == 'butterfly') and (butterfly.opacity < 100)):
            # Decrease the cocoon opacity and increase the butterfly opacity.
            cocoon.opacity -= 2
            butterfly.opacity += 2

        # Changes the phases.
        if ((caterpillar.opacity == 100) and (app.phase == 'caterpillar')):
            app.phase = 'cocoon'
        if ((cocoon.opacity == 100) and (app.phase == 'cocoon')):
            app.phase='butterfly'
",regular,1
2131,Helicopter,6.1.3,"app.background = gradient('deepSkyBlue', 'lightSkyBlue', start='top')

leftBlade = Polygon(190, 165, 130, 135, 130, 145, fill='lightGrey')
rightBlade = Polygon(205, 165, 265, 135, 265, 145, fill='grey')

helicopter = Group(
    Oval(200, 200, 100, 50, rotateAngle=-5),
    Circle(200, 165, 8),
    Polygon(190, 180, 192, 165, 208, 165, 210, 175),
    Polygon(235, 185, 245, 205, 320, 190, 320, 180),
    Polygon(325, 205, 330, 195, 325, 180, 330, 160, 325, 155, 320, 170, 315, 185)
    )
helicopter.fill = gradient('crimson', 'crimson', 'darkRed', start='top')

helicopter.add(
    Polygon(185, 180, 165, 190, 155, 205, 180, 200, fill='aqua'),
    Polygon(190, 180, 210, 180, 215, 200, 185, 200, fill='aqua'),
    Oval(168, 193, 36, 12, fill=gradient('azure', 'aqua', 'aqua'), rotateAngle=-35),
    Line(180, 220, 170, 235, fill=rgb(70, 75, 75)),
    Line(210, 220, 220, 235, fill=rgb(70, 75, 75)),
    Line(145, 235, 250, 235, fill=rgb(70, 75, 75), lineWidth=3),
    leftBlade, rightBlade
    )

def onKeyHold(keys):
    # Change the helicopter's position by 2 pixels depending on the key that is
    # pressed. Change the rotateAngle as well depending on if 'left' or 'right'
    # is pressed.
    ### Place Your Code Here ###

    # Alternate the color of the blades so they appear to be spinning.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'lightSkyBlue', start='top')

leftBlade = Polygon(190, 165, 130, 135, 130, 145, fill='lightGrey')
rightBlade = Polygon(205, 165, 265, 135, 265, 145, fill='grey')

helicopter = Group(
    Oval(200, 200, 100, 50, rotateAngle=-5),
    Circle(200, 165, 8),
    Polygon(190, 180, 192, 165, 208, 165, 210, 175),
    Polygon(235, 185, 245, 205, 320, 190, 320, 180),
    Polygon(325, 205, 330, 195, 325, 180, 330, 160, 325, 155, 320, 170, 315, 185)
    )
helicopter.fill = gradient('crimson', 'crimson', 'darkRed', start='top')

helicopter.add(
    Polygon(185, 180, 165, 190, 155, 205, 180, 200, fill='aqua'),
    Polygon(190, 180, 210, 180, 215, 200, 185, 200, fill='aqua'),
    Oval(168, 193, 36, 12, fill=gradient('azure', 'aqua', 'aqua'), rotateAngle=-35),
    Line(180, 220, 170, 235, fill=rgb(70, 75, 75)),
    Line(210, 220, 220, 235, fill=rgb(70, 75, 75)),
    Line(145, 235, 250, 235, fill=rgb(70, 75, 75), lineWidth=3),
    leftBlade, rightBlade
    )

def onKeyHold(keys):
    # Change the helicopter's position by 2 pixels depending on the key that is
    # pressed. Change the rotateAngle as well depending on if 'left' or 'right'
    # is pressed.
    if ('up' in keys):
        helicopter.centerY -= 2
    elif ('down' in keys):
        helicopter.centerY += 2

    if ('left' in keys):
        helicopter.centerX -= 2
        helicopter.rotateAngle = -15
    elif ('right' in keys):
        helicopter.centerX += 2
        helicopter.rotateAngle = 15
    else:
        helicopter.rotateAngle = 0

    # Alternate the color of the blades so they appear to be spinning.
    if (leftBlade.fill == 'lightGrey'):
        leftBlade.fill = 'grey'
        rightBlade.fill = 'lightGrey'
    else:
        leftBlade.fill = 'lightGrey'
        rightBlade.fill = 'grey'
",regular,2
2127,Jack in the box,6.1.3,"app.background = gradient('darkSlateBlue', 'fuchsia')

crank = Line(85, 270, 85, 225, fill='grey', lineWidth=6)
Circle(85, 270, 5, fill='grey')
handle = Rect(85, 225, 50, 20, fill='red', align='right')

# box
Polygon(155, 230, 105, 180, 235, 180, 285, 230, fill='mediumSpringGreen',
        border='black')
Line(235, 180, 235, 230)
Polygon(155, 230, 155, 360, 105, 310, 105, 180, fill='mediumSpringGreen',
        border='black')
Rect(155, 230, 130, 130, fill='lightGreen', border='black')
Star(220, 300, 50, 5, fill='red')
Line(125, 260, 125, 280, fill='tan', lineWidth=5)
Line(125, 270, 85, 270, fill='grey', lineWidth=10)

lid = Polygon(155, 230, 105, 180, 235, 180, 285, 230, fill='springGreen',
              border='black')

jack = Group(
    # body
    Oval(185, 175, 50, 140, fill='dodgerBlue', rotateAngle=-20),
    Rect(160, 233, 120, 15, fill='lightGreen'),

    # head and hat
    Circle(160, 95, 50, fill='navajoWhite'),
    Polygon(105, 90, 200, 60, 205, 65, 105, 95, fill='gold'),
    Polygon(105, 90, 130, 15, 200, 60, fill='red'),
    Circle(130, 15, 10, fill='gold'),

    # mouth
    Oval(165, 118, 60, 40, rotateAngle=-10),
    Oval(160, 112, 60, 30, fill='navajoWhite', rotateAngle=-15),
    Oval(180, 130, 25, 15, fill='crimson', rotateAngle=-10),

    # eyes
    Circle(140, 95, 8, fill='white'),
    Circle(140, 95, 4),
    Circle(175, 85, 10, fill='white'),
    Circle(175, 85, 5),

    # nose
    Circle(160, 105, 10, fill='red'),
    )
jack.visible = False

# Cover the bottom of Jack so it looks like he's inside the box.
Line(155, 230, 285, 230, lineWidth=5)

def onMousePress(mouseX, mouseY):
    # If mouse presses the handle, pull the handle down, open the box,
    # and show Jack.
    ### Place Your Code Here ###
    pass

def onMouseRelease(mouseX, mouseY):
    # If Jack is visible, push the handle up, close the box, and hide Jack.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('darkSlateBlue', 'fuchsia')

crank = Line(85, 270, 85, 225, fill='grey', lineWidth=6)
Circle(85, 270, 5, fill='grey')
handle = Rect(85, 225, 50, 20, fill='red', align='right')

# box
Polygon(155, 230, 105, 180, 235, 180, 285, 230, fill='mediumSpringGreen',
        border='black')
Line(235, 180, 235, 230)
Polygon(155, 230, 155, 360, 105, 310, 105, 180, fill='mediumSpringGreen',
        border='black')
Rect(155, 230, 130, 130, fill='lightGreen', border='black')
Star(220, 300, 50, 5, fill='red')
Line(125, 260, 125, 280, fill='tan', lineWidth=5)
Line(125, 270, 85, 270, fill='grey', lineWidth=10)

lid = Polygon(155, 230, 105, 180, 235, 180, 285, 230, fill='springGreen',
              border='black')

jack = Group(
    # body
    Oval(185, 175, 50, 140, fill='dodgerBlue', rotateAngle=-20),
    Rect(160, 233, 120, 15, fill='lightGreen'),

    # head and hat
    Circle(160, 95, 50, fill='navajoWhite'),
    Polygon(105, 90, 200, 60, 205, 65, 105, 95, fill='gold'),
    Polygon(105, 90, 130, 15, 200, 60, fill='red'),
    Circle(130, 15, 10, fill='gold'),

    # mouth
    Oval(165, 118, 60, 40, rotateAngle=-10),
    Oval(160, 112, 60, 30, fill='navajoWhite', rotateAngle=-15),
    Oval(180, 130, 25, 15, fill='crimson', rotateAngle=-10),

    # eyes
    Circle(140, 95, 8, fill='white'),
    Circle(140, 95, 4),
    Circle(175, 85, 10, fill='white'),
    Circle(175, 85, 5),

    # nose
    Circle(160, 105, 10, fill='red'),
    )
jack.visible = False

# Cover the bottom of Jack so it looks like he's inside the box.
Line(155, 230, 285, 230, lineWidth=5)

def onMousePress(mouseX, mouseY):
    # If the mouse presses the handle, pull the handle down, open the box,
    # and show Jack.
    if (handle.contains(mouseX, mouseY) == True):
        jack.visible = True
        lid.centerX += 130
        crank.centerY += 45
        handle.centerY += 90

def onMouseRelease(mouseX, mouseY):
    # If Jack is visible, push the handle up, close the box, and hide Jack.
    if (jack.visible == True):
        jack.visible = False
        lid.centerX -= 130
        crank.centerY -= 45
        handle.centerY -= 90
",regular,2
2137,Saloon at night,6.2.2,"# background and environment
sky = Rect(0, 0, 400, 250, fill=gradient('lightBlue', 'burlyWood', start='top'))
ground = Rect(0, 250, 400, 150, fill='lemonChiffon')
path = Polygon(175, 300, 225, 300, 250, 400, 150, 400, fill='navajoWhite')

windows = Group()
door = Group()

def drawThreeWindowPanes(x1, y1, x2, y2):
    # Use a dashed line to create three brown window panes and add it to the
    # windows group.
    ### (HINT: If you haven't used dashes before, take a look at the docs!)
    ### Place Your Code Here ###
    pass

def drawAllWindows():
    # bottom windows
    Rect(115, 230, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(125, 233, 125, 283)
    drawThreeWindowPanes(140, 233, 140, 283)

    Rect(250, 230, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(260, 233, 260, 283)
    drawThreeWindowPanes(275, 233, 275, 283)

    # top windows
    Rect(115, 157, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(125, 160, 125, 210)
    drawThreeWindowPanes(140, 160, 140, 210)

    Rect(183, 157, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(193, 160, 193, 210)
    drawThreeWindowPanes(208, 160, 208, 210)

    Rect(250, 157, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(260, 160, 260, 210)
    drawThreeWindowPanes(275, 160, 275, 210)

    windows.toFront()

def drawDoor():
    # Add the dark brown, rectangular doorway to the door group.
    ### Place Your Code Here ###

    door.toFront()

    Line(200, 250, 200, 300, fill='sienna')
    Line(185, 265, 185, 285, fill='peru', lineWidth=20, dashes=(1, 2))
    Line(215, 265, 215, 285, fill='peru', lineWidth=20, dashes=(1, 2))

def drawPorch():
    Polygon(100, 220, 300, 220, 325, 245, 75, 245,
            fill=gradient('saddleBrown', 'sienna', start='top'),
            border='saddleBrown')
    Rect(80, 300, 240, 10, fill='sienna', border='brown')
    Line(85, 245, 85, 300, fill='brown', lineWidth=8, dashes=(15, 1))
    Line(315, 245, 315, 300, fill='brown', lineWidth=8, dashes=(15, 1))
    Line(140, 245, 140, 300, fill='brown', lineWidth=8, dashes=(15, 1))
    Line(260, 245, 260, 300, fill='brown', lineWidth=8, dashes=(15, 1))

def drawSaloon():
    # bottom floor
    Rect(100, 150, 200, 150, fill='sienna')
    Line(200, 150, 200, 300, fill='burlyWood', lineWidth=200, dashes=(10, 1))

    # Add windows and doors to each group.
    drawAllWindows()
    drawDoor()

    # top floor
    Rect(125, 75, 150, 75, fill='sienna')
    Line(200, 75, 200, 150, fill='burlyWood', lineWidth=150, dashes=(12, 1))
    Rect(90, 140, 220, 10, fill='sienna', border='brown')
    Rect(120, 65, 160, 10, fill='sienna', border='brown')

    # building name
    Rect(150, 80, 100, 50, fill=gradient('peru', 'burlyWood', start='bottom'),
         border='saddleBrown', borderWidth=4)
    Label('Saloon', 200, 105, fill='saddleBrown', size=30)

    drawPorch()

drawSaloon()

def onMousePress(mouseX, mouseY):
    sky.fill = gradient('navy', 'rosyBrown', start='top')
    ground.fill = 'paleGoldenrod'
    path.fill = 'burlyWood'

    # Change the fill of all the windows and doors to their nighttime colors.
    ### Place Your Code Here ###


def onMouseRelease(mouseX, mouseY):
    sky.fill = gradient('lightBlue', 'burlyWood', start='top')
    ground.fill = 'lemonChiffon'
    path.fill = 'navajoWhite'

    # Change the fill of all the windows and doors to their daytime colors.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background and environment
sky = Rect(0, 0, 400, 250, fill=gradient('lightBlue', 'burlyWood', start='top'))
ground = Rect(0, 250, 400, 150, fill='lemonChiffon')
path = Polygon(175, 300, 225, 300, 250, 400, 150, 400, fill='navajoWhite')

windows = Group()
door = Group()

def drawThreeWindowPanes(x1, y1, x2, y2):
    # Use a dashed line to create three brown window panes and add it to the
    # windows group.
    windows.add(
        Line(x1, y1, x2, y2, fill='saddleBrown', lineWidth=14, dashes=(15, 2))
        )

def drawAllWindows():
    # bottom windows
    Rect(115, 230, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(125, 233, 125, 283)
    drawThreeWindowPanes(140, 233, 140, 283)

    Rect(250, 230, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(260, 233, 260, 283)
    drawThreeWindowPanes(275, 233, 275, 283)

    # top windows
    Rect(115, 157, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(125, 160, 125, 210)
    drawThreeWindowPanes(140, 160, 140, 210)

    Rect(183, 157, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(193, 160, 193, 210)
    drawThreeWindowPanes(208, 160, 208, 210)

    Rect(250, 157, 35, 55, fill='peru', border='brown')
    drawThreeWindowPanes(260, 160, 260, 210)
    drawThreeWindowPanes(275, 160, 275, 210)

    windows.toFront()

def drawDoor():
    # Add the dark brown, rectangular doorway to the door group.
    door.add(
        Rect(175, 250, 50, 50, fill='saddleBrown', border='sienna')
        )

    door.toFront()

    Line(200, 250, 200, 300, fill='sienna')
    Line(185, 265, 185, 285, fill='peru', lineWidth=20, dashes=(1, 2))
    Line(215, 265, 215, 285, fill='peru', lineWidth=20, dashes=(1, 2))

def drawPorch():
    Polygon(100, 220, 300, 220, 325, 245, 75, 245,
            fill=gradient('saddleBrown', 'sienna', start='top'),
            border='saddleBrown')
    Rect(80, 300, 240, 10, fill='sienna', border='brown')
    Line(85, 245, 85, 300, fill='brown', lineWidth=8, dashes=(15, 1))
    Line(315, 245, 315, 300, fill='brown', lineWidth=8, dashes=(15, 1))
    Line(140, 245, 140, 300, fill='brown', lineWidth=8, dashes=(15, 1))
    Line(260, 245, 260, 300, fill='brown', lineWidth=8, dashes=(15, 1))

def drawSaloon():
    # bottom floor
    Rect(100, 150, 200, 150, fill='sienna')
    Line(200, 150, 200, 300, fill='burlyWood', lineWidth=200, dashes=(10, 1))

    # Add windows and doors to each group.
    drawAllWindows()
    drawDoor()

    # top floor
    Rect(125, 75, 150, 75, fill='sienna')
    Line(200, 75, 200, 150, fill='burlyWood', lineWidth=150, dashes=(12, 1))
    Rect(90, 140, 220, 10, fill='sienna', border='brown')
    Rect(120, 65, 160, 10, fill='sienna', border='brown')

    # building name
    Rect(150, 80, 100, 50, fill=gradient('peru', 'burlyWood', start='bottom'),
         border='saddleBrown', borderWidth=4)
    Label('Saloon', 200, 105, fill='saddleBrown', size=30)

    drawPorch()

drawSaloon()

def onMousePress(mouseX, mouseY):
    sky.fill = gradient('navy', 'rosyBrown', start='top')
    ground.fill = 'paleGoldenrod'
    path.fill = 'burlyWood'

    # Change the fill of all the windows and doors to their nighttime colors.
    windows.fill = 'yellow'
    door.fill = 'yellow'

def onMouseRelease(mouseX, mouseY):
    sky.fill = gradient('lightBlue', 'burlyWood', start='top')
    ground.fill = 'lemonChiffon'
    path.fill = 'navajoWhite'

    # Change the fill of all the windows and doors to their daytime colors.
    windows.fill = 'saddleBrown'
    door.fill = 'saddleBrown'
",regular,1
2133,The floor is lava,6.2.2,"app.background = gradient('orange', 'red', 'orange')

steps = Group(
    Polygon(10, 345, 70, 320, 95, 375, 15, 390, fill='white'),
    Polygon(160, 360, 195, 330, 165, 320, fill='white'),
    Polygon(25, 240, 70, 260, 55, 220, fill='white'),
    Polygon(135, 155, 170, 130, 200, 175, fill='white'),
    Polygon(75, 60, 40, 75, 75, 100, fill='white'),
    Polygon(280, 125, 230, 90, 290, 95, fill='white'),
    Polygon(270, 280, 295, 310, 350, 270, fill='white'),
    Polygon(320, 165, 345, 200, 370, 155, fill='white')
    )

goal = Polygon(320, 15, 390, 5, 395, 50, 340, 70, fill='limeGreen')

Label('# of Steps', 250, 350, size=15)
numSteps = Label(0, 250, 370, size=25)

Label('Next foot:', 350, 350, size=15)
nextFootLabel = Label('R', 350, 370, size=25)

leftFoot = Group(
    Circle(30, 350, 8),
    Rect(30, 360, 16, 20, align='center'),
    Circle(30, 375, 8),
    Rect(30, 370, 16, 5, fill='white', align='top'),
    Label('L', 30, 355, fill='white')
    )

rightFoot = Group(
    Circle(60, 350, 8),
    Rect(60, 360, 16, 20, align='center'),
    Circle(60, 375, 8),
    Rect(60, 370, 16, 5, fill='white', align='top'),
    Label('R', 60, 355, fill='white')
    )

def winGame():
    Rect(200, 225, 200, 100, fill='lightGreen', align='center')
    Label('You win!', 200, 225, size=50)
    app.stop()

def loseGame(reason):
    Rect(200, 225, 200, 100, fill='pink', align='center')
    Label(reason, 200, 200, size=30)
    Label('You lose!', 200, 250, size=30)
    app.stop()

def onMousePress(mouseX, mouseY):
    # First, take the step.
    ### Place Your Code Here ###

    # After a step, increment the number of steps taken so far.
    numSteps.value += 1

    # Then check for win or lose. A step loses if any of the following occur:
    # 1 - The left foot centerX is bigger than the right foot centerX.
    # 2 - The distance between the feet's centerX or centerY is bigger than 175.
    # 3 - If the place clicked is not in the steps group or the goal.
    ### (HINT: Use the .hits() method to check if the game is won or the player
    #          stepped in the lava!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('orange', 'red', 'orange')

steps = Group(
    Polygon(10, 345, 70, 320, 95, 375, 15, 390, fill='white'),
    Polygon(160, 360, 195, 330, 165, 320, fill='white'),
    Polygon(25, 240, 70, 260, 55, 220, fill='white'),
    Polygon(135, 155, 170, 130, 200, 175, fill='white'),
    Polygon(75, 60, 40, 75, 75, 100, fill='white'),
    Polygon(280, 125, 230, 90, 290, 95, fill='white'),
    Polygon(270, 280, 295, 310, 350, 270, fill='white'),
    Polygon(320, 165, 345, 200, 370, 155, fill='white')
    )

goal = Polygon(320, 15, 390, 5, 395, 50, 340, 70, fill='limeGreen')

Label('# of Steps', 250, 350, size=15)
numSteps = Label(0, 250, 370, size=25)

Label('Next foot:', 350, 350, size=15)
nextFootLabel = Label('R', 350, 370, size=25)

leftFoot = Group(
    Circle(30, 350, 8),
    Rect(30, 360, 16, 20, align='center'),
    Circle(30, 375, 8),
    Rect(30, 370, 16, 5, fill='white', align='top'),
    Label('L', 30, 355, fill='white')
    )

rightFoot = Group(
    Circle(60, 350, 8),
    Rect(60, 360, 16, 20, align='center'),
    Circle(60, 375, 8),
    Rect(60, 370, 16, 5, fill='white', align='top'),
    Label('R', 60, 355, fill='white')
    )

def winGame():
    Rect(200, 225, 200, 100, fill='lightGreen', align='center')
    Label('You win!', 200, 225, size=50)
    app.stop()

def loseGame(reason):
    Rect(200, 225, 200, 100, fill='pink', align='center')
    Label(reason, 200, 200, size=30)
    Label('You lose!', 200, 250, size=30)
    app.stop()

def onMousePress(mouseX, mouseY):
    # First, take the step.
    if (nextFootLabel.value == 'L'):
        leftFoot.centerX = mouseX
        leftFoot.centerY = mouseY
        nextFootLabel.value = 'R'
    else:
        rightFoot.centerX = mouseX
        rightFoot.centerY = mouseY
        nextFootLabel.value = 'L'

    # After a step, increment the number of steps taken so far.
    numSteps.value += 1

    # Then check for win or lose. A step loses if any of the following occur:
    # 1 - The left foot centerX is bigger than the right foot centerX.
    # 2 - The distance between the feet's centerX or centerY is bigger than 175.
    # 3 - If the place clicked is not in the steps group or the goal.
    footDistanceX = rightFoot.centerX - leftFoot.centerX
    footDistanceY = rightFoot.centerY - leftFoot.centerY
    if (footDistanceX < 0):
        loseGame('Crossed feet!')
    elif ((footDistanceX > 175) or (footDistanceY > 175)):
        loseGame('Too far!')
    elif (goal.hits(mouseX, mouseY) == True):
        winGame()
    elif (steps.hits(mouseX, mouseY) == False):
        loseGame('Not a step!')
",regular,3
2134,Hippo,6.2.2,"app.background = 'forestGreen'

hippoBody = Group(
    Oval(200, 265, 135, 110, fill='lightCoral'),
    Circle(170, 305, 15, fill=rgb(205, 90, 90)),
    Circle(230, 305, 15, fill=rgb(205, 90, 90)),
    Rect(200, 305, 90, 15, fill='forestGreen', align='top'),
    Line(200, 260, 210, 280, fill=rgb(205, 90, 90), lineWidth=5)
    )

hippoFace = Group(
    Circle(220, 225, 10, fill='lightPink'),
    Circle(180, 225, 10, fill='lightPink'),
    Oval(200, 240, 65, 50, fill='lightPink'),
    Oval(200, 260, 75, 60, fill='lightPink'),
    Oval(190, 265, 6, 10, fill='hotPink'),
    Oval(210, 265, 6, 10, fill='hotPink'),
    Circle(185, 240, 12, fill='white'),
    Circle(215, 240, 12, fill='white'),
    Circle(185, 240, 4),
    Circle(215, 240, 4)
    )

hippo = Group(hippoBody, hippoFace)
hippo.isMovingForward = True

def onMousePress(mouseX, mouseY):
    # If the hippo is moving forward the width and height should increase.
    # If the hippo is moving backward the width and height should decrease.
    ### (HINT: What is the hippo's starting height? How many presses until the
    #          hippo has height 10 (its smallest height)? How much should the
    #          height change per press to go from the starting height to 10?)
    ### (HINT: Make sure the hippo's width and height never drop below 5.)
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    # If the 'f' key is pressed the hippo should be moving forward.
    # if the 'b' key is pressed the hippo should be moving backward.
    ### (HINT: Use the custom property to indicate which direction the hippo is
    #          moving!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'forestGreen'

hippoBody = Group(
    Oval(200, 265, 135, 110, fill='lightCoral'),
    Circle(170, 305, 15, fill=rgb(205, 90, 90)),
    Circle(230, 305, 15, fill=rgb(205, 90, 90)),
    Rect(200, 305, 90, 15, fill='forestGreen', align='top'),
    Line(200, 260, 210, 280, fill=rgb(205, 90, 90), lineWidth=5)
    )

hippoFace = Group(
    Circle(220, 225, 10, fill='lightPink'),
    Circle(180, 225, 10, fill='lightPink'),
    Oval(200, 240, 65, 50, fill='lightPink'),
    Oval(200, 260, 75, 60, fill='lightPink'),
    Oval(190, 265, 6, 10, fill='hotPink'),
    Oval(210, 265, 6, 10, fill='hotPink'),
    Circle(185, 240, 12, fill='white'),
    Circle(215, 240, 12, fill='white'),
    Circle(185, 240, 4),
    Circle(215, 240, 4)
    )

hippo = Group(hippoBody, hippoFace)
hippo.isMovingForward = True

def onMousePress(mouseX, mouseY):
    # If the hippo is moving forward the width and height should increase.
    # If the hippo is moving backward the width and height should decrease.
    if (hippo.isMovingForward == True):
        hippo.width += 10
        hippo.height += 10
    else:
        if ((hippo.width > 15) and (hippo.height > 15)):
            hippo.width -= 10
            hippo.height -= 10

def onKeyPress(key):
    # If the 'f' key is pressed the hippo should be moving forward.
    # If the 'b' key is pressed the hippo should be moving backward.
    if (key == 'f'):
        hippo.isMovingForward = True
        hippoFace.toFront()
    elif (key == 'b'):
        hippo.isMovingForward = False
        hippoFace.toBack()
",regular,2
2135,The maze,6.2.2,"app.background = 'mediumSeaGreen'
app.stepsPerSecond = 50

maze = Group(
    Line(45, 105, 45, 365, fill='sienna', lineWidth=10),
    Line(45, 365, 365, 365, fill='sienna', lineWidth=10),
    Line(365, 305, 365, 45, fill='sienna', lineWidth=10),
    Line(45, 45, 365, 45, fill='sienna', lineWidth=10),
    Line(115, 45, 115, 305, fill='sienna', lineWidth=10),
    Line(115, 245, 235, 245, fill='sienna', lineWidth=10),
    Line(175, 365, 175, 305, fill='sienna', lineWidth=10),
    Line(295, 365, 295, 105, fill='sienna', lineWidth=10),
    Line(235, 305, 235, 175, fill='sienna', lineWidth=10),
    Line(175, 105, 295, 105, fill='sienna', lineWidth=10),
    Line(175, 105, 175, 185, fill='sienna', lineWidth=10),
    Line(40, 100, 40, 360, fill='white', lineWidth=10),
    Line(40, 360, 360, 360, fill='white', lineWidth=10),
    Line(360, 300, 360, 40, fill='white', lineWidth=10),
    Line(40, 40, 360, 40, fill='white', lineWidth=10),
    Line(110, 40, 110, 300, fill='white', lineWidth=10),
    Line(110, 240, 230, 240, fill='white', lineWidth=10),
    Line(170, 360, 170, 300, fill='white', lineWidth=10),
    Line(290, 360, 290, 100, fill='white', lineWidth=10),
    Line(230, 300, 230, 170, fill='white', lineWidth=10),
    Line(170, 100, 290, 100, fill='white', lineWidth=10),
    Line(170, 100, 170, 180, fill='white', lineWidth=10),
    )

Label('Use arrow keys to move  /  Press r to restart', 200, 385, fill='white',
      size=15)

player = Circle(40, 72, 18, fill='orange', border='darkOrange')
player.score = Label(0, 40, 72, fill='white', bold=True)
player.gameOver = False

endOfGameMessage = Label('', 200, 200, fill='indigo', size=50, bold=True)
endOfGame = Group(
    Rect(200, 200, 300, 70, fill='lavender', align='center'),
    endOfGameMessage
    )
endOfGame.visible = False

def restartGame():
    player.centerX = 40
    player.centerY = 70
    player.score.centerX = player.centerX
    player.score.centerY = player.centerY
    player.score.value = 0
    player.gameOver = False
    endOfGame.visible = False

def finishGame(message):
    endOfGame.visible = True
    endOfGameMessage.value = message

def checkWin():
    # You should win the game when the player is at the end of the maze.
    ### (HINT: The player is at the end of the maze if its centerX is
    #          greater than 360 and if its centerY is between 300 and 360.)
    ### (HINT: If the condition is true, you should change a custom property
    #          of the player and use the finish game helper function.)
    ### Place Your Code Here ###
    pass

def checkLose():
    # You should lose the game when the player intersects the maze.
    ### (HINT: You should change a custom property of the player
    #          and use the finish game helper function.)
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    if (key == 'r'):
        restartGame()

def onKeyHold(keys):
    if (player.gameOver == False):
        if ('up' in keys):
            player.centerY -= 2
        if ('down' in keys):
            player.centerY += 2
        if ('left' in  keys):
            player.centerX -= 2
        if ('right' in keys):
            player.centerX += 2

        player.score.centerX = player.centerX
        player.score.centerY = player.centerY
        player.score.value += 1
        checkLose()
        checkWin()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'mediumSeaGreen'
app.stepsPerSecond = 50

maze = Group(
    Line(45, 105, 45, 365, fill='sienna', lineWidth=10),
    Line(45, 365, 365, 365, fill='sienna', lineWidth=10),
    Line(365, 305, 365, 45, fill='sienna', lineWidth=10),
    Line(45, 45, 365, 45, fill='sienna', lineWidth=10),
    Line(115, 45, 115, 305, fill='sienna', lineWidth=10),
    Line(115, 245, 235, 245, fill='sienna', lineWidth=10),
    Line(175, 365, 175, 305, fill='sienna', lineWidth=10),
    Line(295, 365, 295, 105, fill='sienna', lineWidth=10),
    Line(235, 305, 235, 175, fill='sienna', lineWidth=10),
    Line(175, 105, 295, 105, fill='sienna', lineWidth=10),
    Line(175, 105, 175, 185, fill='sienna', lineWidth=10),
    Line(40, 100, 40, 360, fill='white', lineWidth=10),
    Line(40, 360, 360, 360, fill='white', lineWidth=10),
    Line(360, 300, 360, 40, fill='white', lineWidth=10),
    Line(40, 40, 360, 40, fill='white', lineWidth=10),
    Line(110, 40, 110, 300, fill='white', lineWidth=10),
    Line(110, 240, 230, 240, fill='white', lineWidth=10),
    Line(170, 360, 170, 300, fill='white', lineWidth=10),
    Line(290, 360, 290, 100, fill='white', lineWidth=10),
    Line(230, 300, 230, 170, fill='white', lineWidth=10),
    Line(170, 100, 290, 100, fill='white', lineWidth=10),
    Line(170, 100, 170, 180, fill='white', lineWidth=10),
    )

Label('Use arrow keys to move  /  Press r to restart', 200, 385, fill='white',
      size=15)

player = Circle(40, 72, 18, fill='orange', border='darkOrange')
player.score = Label(0, 40, 72, fill='white', bold=True)
player.gameOver = False

endOfGameMessage = Label('', 200, 200, fill='indigo', size=50, bold=True)
endOfGame = Group(
    Rect(200, 200, 300, 70, fill='lavender', align='center'),
    endOfGameMessage
    )
endOfGame.visible = False

def restartGame():
    player.centerX = 40
    player.centerY = 70
    player.score.centerX = player.centerX
    player.score.centerY = player.centerY
    player.score.value = 0
    player.gameOver = False
    endOfGame.visible = False

def finishGame(message):
    endOfGame.visible = True
    endOfGameMessage.value = message

def checkWin():
    # You should win the game when the player is at the end of the maze.
    if ((player.centerX > 360) and (300 < player.centerY) and
        (player.centerY < 360)):
        player.gameOver = True
        finishGame('YOU WIN!')

def checkLose():
    # You should lose the game when the player intersects the maze.
    if (maze.hitsShape(player) == True):
        player.gameOver = True
        finishGame('YOU LOSE!')

def onKeyPress(key):
    if (key == 'r'):
        restartGame()

def onKeyHold(keys):
    if (player.gameOver == False):
        if ('up' in keys):
            player.centerY -= 2
        if ('down' in keys):
            player.centerY += 2
        if ('left' in  keys):
            player.centerX -= 2
        if ('right' in keys):
            player.centerX += 2

        player.score.centerX = player.centerX
        player.score.centerY = player.centerY
        player.score.value += 1
        checkLose()
        checkWin()
",regular,2
2136,Paint spill,6.2.2,"# background
Line(200, 0, 200, 400, fill='lightGrey', lineWidth=400, dashes=(30, 30))
Line(0, 200, 400, 200, fill='cornflowerBlue', lineWidth=400, opacity=50,
     dashes=(30, 30))
Line(0, 200, 400, 200, fill='grey', lineWidth=400, opacity=50, dashes=(3, 27))
Line(200, 0, 200, 400, fill='grey', lineWidth=400, opacity=50, dashes=(3, 27))

Label('All clean!', 200, 200, size=35)
Rect(360, 400, 100, 100, fill='grey', rotateAngle=-125, align='center')
Oval(330, 358, 100, 30, fill='dimGrey', border='slateGrey', borderWidth=5,
     rotateAngle=-35)

paint1 = Group(
    Circle(300, 300, 75, fill='mediumTurquoise'),
    Circle(350, 265, 75, fill='mediumTurquoise'),
    Circle(240, 325, 75, fill='mediumTurquoise')
    )

paint2 = Group(
    Circle(125, 280, 100, fill='mediumTurquoise'),
    Circle(200, 180, 100, fill='mediumTurquoise'),
    Circle(110, 180, 75, fill='mediumTurquoise')
    )

paint3 = Group(
    Circle(300, 180, 70, fill='mediumTurquoise'),
    Circle(270, 100, 60, fill='mediumTurquoise'),
    Circle(355, 140, 70, fill='mediumTurquoise')
    )

sponge = Rect(10, 10, 25, 50, fill='gold')

def onMouseMove(mouseX, mouseY):
    sponge.centerX = mouseX
    sponge.centerY = mouseY

    # Check if any of the paint groups hit the sponge and decrease their opacity
    # if so. When an opacity gets below 3, clear that paint group.
    ### (HINT: Use the hitsShape and clear methods.)
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Line(200, 0, 200, 400, fill='lightGrey', lineWidth=400, dashes=(30, 30))
Line(0, 200, 400, 200, fill='cornflowerBlue', lineWidth=400, opacity=50,
     dashes=(30, 30))
Line(0, 200, 400, 200, fill='grey', lineWidth=400, opacity=50, dashes=(3, 27))
Line(200, 0, 200, 400, fill='grey', lineWidth=400, opacity=50, dashes=(3, 27))

Label('All clean!', 200, 200, size=35)
Rect(360, 400, 100, 100, fill='grey', rotateAngle=-125, align='center')
Oval(330, 358, 100, 30, fill='dimGrey', border='slateGrey', borderWidth=5,
     rotateAngle=-35)

paint1 = Group(
    Circle(300, 300, 75, fill='mediumTurquoise'),
    Circle(350, 265, 75, fill='mediumTurquoise'),
    Circle(240, 325, 75, fill='mediumTurquoise')
    )

paint2 = Group(
    Circle(125, 280, 100, fill='mediumTurquoise'),
    Circle(200, 180, 100, fill='mediumTurquoise'),
    Circle(110, 180, 75, fill='mediumTurquoise')
    )

paint3 = Group(
    Circle(300, 180, 70, fill='mediumTurquoise'),
    Circle(270, 100, 60, fill='mediumTurquoise'),
    Circle(355, 140, 70, fill='mediumTurquoise')
    )

sponge = Rect(10, 10, 25, 50, fill='gold')

def onMouseMove(mouseX, mouseY):
    sponge.centerX = mouseX
    sponge.centerY = mouseY

    # Check if any of the paint groups hit the sponge and decrease their opacity
    # if so. When an opacity gets below 3, clear that paint group.
    if (paint1.hitsShape(sponge) == True):
        paint1.opacity -= 2
        if (paint1.opacity <= 2):
            paint1.clear()
    if (paint2.hitsShape(sponge) == True):
        paint2.opacity -= 2
        if (paint2.opacity <= 2):
            paint2.clear()
    if (paint3.hitsShape(sponge) == True):
        paint3.opacity -= 2
        if (paint3.opacity <= 2):
            paint3.clear()
",regular,1
2138,Step Events Checkpoint 2,6.3.1.1,"app.background = gradient('azure', 'lightBlue', 'blue')
app.stepsPerSecond = 5
app.counter = 0

# head and body
Circle(200, 110, 25)
Line(200, 135, 200, 225)

# upper arms
leftArm = Line(200, 150, 150, 175)
rightArm = Line(200, 150, 250, 125)

# legs
Line(200, 225, 250, 300)
Line(200, 225, 150, 300)

def toggleLeftArm():
    # Move the left arm down if currently up, up if currently down.
    if (leftArm.y2 == 125):
        leftArm.y2 = 175
    else:
        leftArm.y2 = 125

def toggleRightArm():
    # Move the right arm down if currently up, up if currently down.
    if (rightArm.y2 == 125):
        rightArm.y2 = 175
    else:
        rightArm.y2 = 125

def onStep():
    app.counter += 1

    # When app.counter is 1, call the left arm helper function.
    # When app.counter is 2, call the right arm helper function. Also, set
    # app.counter to be 0.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('azure', 'lightBlue', 'blue')
app.stepsPerSecond = 5
app.counter = 0

# head and body
Circle(200, 110, 25)
Line(200, 135, 200, 225)

# upper arms
leftArm = Line(200, 150, 150, 175)
rightArm = Line(200, 150, 250, 125)

# legs
Line(200, 225, 250, 300)
Line(200, 225, 150, 300)

def toggleLeftArm():
    # Move the left arm down if currently up, up if currently down.
    if (leftArm.y2 == 125):
        leftArm.y2 = 175
    else:
        leftArm.y2 = 125

def toggleRightArm():
    # Move the right arm down if currently up, up if currently down.
    if (rightArm.y2 == 125):
        rightArm.y2 = 175
    else:
        rightArm.y2 = 125

def onStep():
    app.counter += 1

    # When app.counter is 1, call the left arm helper function.
    # When app.counter is 2, call the right arm helper function. Also, set
    # app.counter to be 0.
    if (app.counter == 1):
        toggleLeftArm()
    if (app.counter == 2):
        toggleRightArm()
        app.counter = 0
",regular,1
2141,Rainy day,6.3.3,"app.background = 'darkGrey'
app.stepsPerSecond = 10

# cloud
Circle(210, 20, 50, fill='white', border='gainsboro', borderWidth=3)
Circle(130, 65, 70, fill='white', border='gainsboro', borderWidth=3)
Circle(280, 65, 60, fill='white', border='gainsboro', borderWidth=3)
Circle(200, 95, 80, fill='white', border='gainsboro')
Rect(165, 5, 20, 11, fill='white')
Rect(235, 10, 20, 13, fill='white')
Rect(115, 35, 155, 95, fill='white')

rain = Group()

def onStep():
    # Adds new raindrops.
    rain.add(
        Circle(200, 200, 7, fill=gradient('white', 'lightBlue')),
        Circle(115, 140, 7, fill=gradient('white', 'lightBlue')),
        Circle(280, 140, 7, fill=gradient('white', 'lightBlue'))
        )

    # Move the rain group down by 40. If the centerY of the rain gets
    # below 400, clear the group.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'darkGrey'
app.stepsPerSecond = 10

# cloud
Circle(210, 20, 50, fill='white', border='gainsboro', borderWidth=3)
Circle(130, 65, 70, fill='white', border='gainsboro', borderWidth=3)
Circle(280, 65, 60, fill='white', border='gainsboro', borderWidth=3)
Circle(200, 95, 80, fill='white', border='gainsboro')
Rect(165, 5, 20, 11, fill='white')
Rect(235, 10, 20, 13, fill='white')
Rect(115, 35, 155, 95, fill='white')

rain = Group()

def onStep():
    # Adds new raindrops.
    rain.add(
        Circle(200, 200, 7, fill=gradient('white', 'lightBlue')),
        Circle(115, 140, 7, fill=gradient('white', 'lightBlue')),
        Circle(280, 140, 7, fill=gradient('white', 'lightBlue'))
        )

    # Move the rain group down by 40. If the centerY of the rain gets
    # below 400, clear the group.
    rain.centerY += 40
    if (rain.centerY > 400):
        rain.clear()
",regular,1
2139,Floating Flamingo,6.3.3,"app.background = 'aliceBlue'

# legs
Line(230, 280, 230, 400, fill='gold', lineWidth=5)
Line(230, 290, 255, 315, fill='gold', lineWidth=5)
Line(255, 315, 200, 325, fill='gold', lineWidth=5)

# body
flamingoBody = Group(
    Oval(190, 255, 100, 70, fill='lightPink', align='left'),
    Oval(257, 245, 95, 60, fill=rgb(225, 130, 170), rotateAngle=15),
    Line(195, 250, 205, 125, fill='lightPink', lineWidth=10),
    Circle(180, 130, 10),
    Circle(180, 140, 10, fill='aliceBlue'),
    Circle(215, 123, 16, fill='lightPink', align='right'),
    Circle(195, 120, 3)
    )

# water
water = Rect(200, 400, 400, 20, align='bottom',
             fill=gradient('lightSkyBlue', 'deepSkyBlue', start='top'))

def onStep():
    # Move the water up until it gets close to the top of the screen.
    # Move the flamingo so that it floats on the rising water. It should rest
    # so that 20 pixels of body are in the water.
    ### (HINT: You shouldn't need to use app.stop to stop the water from rising
    #          too high.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'aliceBlue'

# legs
Line(230, 280, 230, 400, fill='gold', lineWidth=5)
Line(230, 290, 255, 315, fill='gold', lineWidth=5)
Line(255, 315, 200, 325, fill='gold', lineWidth=5)

# body
flamingoBody = Group(
    Oval(190, 255, 100, 70, fill='lightPink', align='left'),
    Oval(257, 245, 95, 60, fill=rgb(225, 130, 170), rotateAngle=15),
    Line(195, 250, 205, 125, fill='lightPink', lineWidth=10),
    Circle(180, 130, 10),
    Circle(180, 140, 10, fill='aliceBlue'),
    Circle(215, 123, 16, fill='lightPink', align='right'),
    Circle(195, 120, 3)
    )

# water
water = Rect(200, 400, 400, 20, align='bottom',
             fill=gradient('lightSkyBlue', 'deepSkyBlue', start='top'))

def onStep():
    # Move the water up until it gets close to the top of the screen.
    # Move the flamingo so that it floats on the rising water. It should rest
    # so that 20 pixels of body are in the water.
    if (water.top > 170):
        water.height += 1
        water.top -= 1
        if (flamingoBody.bottom > water.top + 20):
            flamingoBody.bottom = water.top + 20
",regular,2
2140,Sun and earth,6.3.3,"app.background = 'black'

Label('*Not to scale', 340, 370, fill='white', size=16)

sun = Star(200, 200, 35, 400, fill=gradient('orange', 'yellow', 'orangeRed'))

earth = Group(
    Circle(200, 200, 150, fill=None, border='darkGrey'),
    Circle(200, 50, 10, fill=gradient('green', 'royalBlue', start='left-top'))
    )
earth.direction = 'clockwise'

def onKeyPress(key):
    # Change the direction based on key.
    if (key == 'right'):
        earth.direction = 'clockwise'
    elif (key == 'left'):
        earth.direction = 'counterclockwise'

def onStep():
    # If the direction of the Earth is clockwise, add 3 to the rotateAngle.
    # Otherwise subtract 3.
    ### Place Your Code Here ###

    # Increase the number of points of the sun by 1.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

Label('*Not to scale', 340, 370, fill='white', size=16)

sun = Star(200, 200, 35, 400, fill=gradient('orange', 'yellow', 'orangeRed'))

earth = Group(
    Circle(200, 200, 150, fill=None, border='darkGrey'),
    Circle(200, 50, 10, fill=gradient('green', 'royalBlue', start='left-top'))
    )
earth.direction = 'clockwise'

def onKeyPress(key):
    # Change the direction based on key.
    if (key == 'right'):
        earth.direction = 'clockwise'
    elif (key == 'left'):
        earth.direction = 'counterclockwise'

def onStep():
    # If the direction of the Earth is clockwise, add 3 to the rotateAngle.
    # Otherwise subtract 3.
    if (earth.direction == 'clockwise'):
        earth.rotateAngle += 3
    else:
        earth.rotateAngle -= 3

    # Increase the number of points of the sun by 1.
    sun.points += 1
",regular,1
2142,Triforce,6.3.5,"app.background = 'mediumseaGreen'
app.stepsPerSecond = 20

# glow
rays = Star(200, 200, 175, 25, fill='lemonChiffon', roundness=5, opacity=0)
raysCover = Polygon(130, 165, 270, 165, 200, 285, fill='mediumSeaGreen')

# triforce symbol
top = RegularPolygon(0, -175, 80, 3,
                     fill=gradient('yellow', 'darkGoldenrod', start='right-top'),
                     border='goldenrod', borderWidth=4, rotateAngle=40)
bottomLeft = RegularPolygon(-170, 445, 80, 3,
                            fill=gradient('yellow', 'darkGoldenrod',
                                          start='right-top'),
                            border='goldenrod', borderWidth=4, rotateAngle=40)
bottomRight = RegularPolygon(570, 445, 80, 3,
                             fill=gradient('yellow', 'darkGoldenrod',
                                           start='right-top'),
                             border='goldenrod', borderWidth=4, rotateAngle=80)

def onStep():
    # If the top polygon's centerX is less than 200, then increase
    # its angle and centerX, centerY.
    if (top.centerX < 200):
        top.rotateAngle += 2
        top.centerX += 2
        top.centerY += 3

    # If the bottomLeft polygon's centerX is less than 130, then rotate
    # and move it up and right.
    ### (HINT: For each polygon the angles will always change by the same
    #          number, and they will take the same number of steps to get to
    #          their final location.)
    ### Place Your Code Here ###

    # If the bottomRight polygon's centerX is greater than 270, then rotate
    # it and move it up and left.
    ### Place Your Code Here ###

    # Otherwise, change the background, the fill for raysCover and
    # change the rays opacity.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'mediumseaGreen'
app.stepsPerSecond = 20

# glow
rays = Star(200, 200, 175, 25, fill='lemonChiffon', roundness=5, opacity=0)
raysCover = Polygon(130, 165, 270, 165, 200, 285, fill='mediumSeaGreen')

# triforce symbol
top = RegularPolygon(0, -175, 80, 3,
                     fill=gradient('yellow', 'darkGoldenrod', start='right-top'),
                     border='goldenrod', borderWidth=4, rotateAngle=40)
bottomLeft = RegularPolygon(-170, 445, 80, 3,
                            fill=gradient('yellow', 'darkGoldenrod',
                                          start='right-top'),
                            border='goldenrod', borderWidth=4, rotateAngle=40)
bottomRight = RegularPolygon(570, 445, 80, 3,
                             fill=gradient('yellow', 'darkGoldenrod',
                                           start='right-top'),
                             border='goldenrod', borderWidth=4, rotateAngle=80)

def onStep():
    # If the top polygon's centerX is less than 200, then increase
    # its angle and centerX, centerY.
    if (top.centerX < 200):
        top.rotateAngle += 2
        top.centerX += 2
        top.centerY += 3

    # If the bottomLeft polygon's centerX is less than 130, then rotate
    # and move it up and right.
    if (bottomLeft.centerX < 130):
        bottomLeft.rotateAngle += 2
        bottomLeft.centerX += 3
        bottomLeft.centerY -= 2

    # If the bottomRight polygon's centerX is greater than 270, then rotate
    # it and move it up and left.
    if (bottomRight.centerX > 270):
        bottomRight.rotateAngle -= 2
        bottomRight.centerX -= 3
        bottomRight.centerY -= 2

    # Otherwise, change the background, the fill for raysCover and
    # change the rays opacity.
    else:
        app.background = gradient('mediumSeaGreen', 'seaGreen')
        rays.opacity = 40
        raysCover.fill = gradient('mediumSeaGreen', 'seaGreen')
",regular,3
2144,Continuous cartwheels,6.3.5,"app.background = gradient(rgb(245, 240, 130), rgb(210, 200, 135), start='top')

app.stepsPerSecond = 20
app.degreesSinceLastCartwheel = 0

# floor
Line(0, 300, 400, 300, lineWidth=6,
     fill=gradient('gainsboro', rgb(197, 195, 198), 'gainsboro', start='bottom'))

stickPerson = Group(
    Circle(200, 125, 30, fill=rgb(70, 75, 75)),
    Line(200, 125, 200, 225, fill=rgb(70, 75, 75), lineWidth=6),
    Line(200, 225, 140, 275, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 225, 260, 275, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 175, 135, 100, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 175, 265, 100, fill=rgb(70, 75, 75), lineWidth=5),

    # These circles make the transition from legs to hands look more natural.
    Circle(150, 200, 30, opacity=0),
    Circle(250, 200, 30, opacity=0)
    )

cartwheelCounter = Label(0, 200, 330, fill=rgb(70, 75, 75), size=25)

def onStep():
    # Rotate and move the stick person by the same amount. And set the
    # bottom of the person onto the floor.
    ### (HINT: Looking at the differences between the canvas in the test
    #          cases will tell you how much the person should rotate
    #          and move!)
    ### Place Your Code Here ###

    # Implement wrap-around on the stick person.
    ### Place Your Code Here ###

    # Increase cartwheel count, each cartwheel is 360 degrees.
    ### (HINT: Use the app.degreesSinceLastCartwheel property and check if
    #          it is larger than or equal to 360.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(245, 240, 130), rgb(210, 200, 135), start='top')

app.stepsPerSecond = 20
app.degreesSinceLastCartwheel = 0

# floor
Line(0, 300, 400, 300, lineWidth=6,
     fill=gradient('gainsboro', rgb(197, 195, 198), 'gainsboro', start='bottom'))

stickPerson = Group(
    Circle(200, 125, 30, fill=rgb(70, 75, 75)),
    Line(200, 125, 200, 225, fill=rgb(70, 75, 75), lineWidth=6),
    Line(200, 225, 140, 275, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 225, 260, 275, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 175, 135, 100, fill=rgb(70, 75, 75), lineWidth=5),
    Line(200, 175, 265, 100, fill=rgb(70, 75, 75), lineWidth=5),

    # These circles make the transition from legs to hands look more natural.
    Circle(150, 200, 30, opacity=0),
    Circle(250, 200, 30, opacity=0)
    )

cartwheelCounter = Label(0, 200, 330, fill=rgb(70, 75, 75), size=25)

def onStep():
    # Rotate and move the stick person by the same amount. And set the
    # bottom of the person onto the floor.
    stickPerson.rotateAngle += 8
    stickPerson.centerX += 8
    stickPerson.bottom = 300

    # Implement wrap-around on the stick person.
    if (stickPerson.left >= 400):
        stickPerson.right = 0

    # Increase cartwheel count, each cartwheel is 360 degrees
    app.degreesSinceLastCartwheel += 8
    if (app.degreesSinceLastCartwheel >= 360):
        cartwheelCounter.value += 1
        app.degreesSinceLastCartwheel = 0
",regular,1
2143,DVD screensaver,6.3.5,"app.background = 'darkBlue'

icon = Group(
    Label('DVD', 220, 200, fill='white', size=50, bold=True),
    Oval(220, 230, 110, 20, fill='white'),
    Label('video', 220, 230, fill='darkBlue', size=15)
    )
icon.dx = 5
icon.dy = 5

def onStep():
    # Move the icon by the amount indicated by icon.dx and icon.dy.
    ### Place Your Code Here ###

    # Reverse the direction of the icon if it reaches an edge of the canvas.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'darkBlue'

icon = Group(
    Label('DVD', 220, 200, fill='white', size=50, bold=True),
    Oval(220, 230, 110, 20, fill='white'),
    Label('video', 220, 230, fill='darkBlue', size=15)
    )
icon.dx = 5
icon.dy = 5

def onStep():
    # Move the icon by the amount indicated by icon.dx and icon.dy.
    icon.centerX += icon.dx
    icon.centerY += icon.dy

    # Reverse the direction of the icon if it reaches an edge of the canvas.
    if ((icon.left <= 0) or (icon.right >= 400)):
        icon.dx = -icon.dx
    if ((icon.top <= 0) or (icon.bottom >= 400)):
        icon.dy = -icon.dy
",regular,1
2145,Feeding Fish,6.3.5,"app.background = gradient('cyan', 'deepSkyBlue', 'royalBlue', start='top')

# Run faster than the default.
app.stepsPerSecond = 60

# food
food = Circle(275, 0, 5, fill='orange')
Label('Food eaten:', 200, 345, fill='white', size=25)
foodCount = Label(0, 200, 375, fill='white', size=25)

# fish
fishBody = Oval(100, 200, 60, 40, fill=gradient('gold', 'yellow', start='left'))
fishTail = Polygon(70, 200, 60, 180, 60, 220,
                   fill=gradient('gold', 'yellow', start='left'))
fishEye = Circle(115, 195, 2)
fish = Group(fishBody, fishTail, fishEye)

# Start the fish right in the center of the canvas.
fish.centerX = 200
fish.centerY = 300

def onStep():
    # Move the fish horizontally by 5 pixels and the food vertically by 2 pixels.
    # Don't forget to wraparound!
    ### (HINT: Wrap the food using its centerY, not its top or bottom!)
    ### Place Your Code Here ###

    # If the fish eats the food, put it at the top again and increase the fish
    # size by 5 pixels. Otherwise, move the fish up or down 1 pixel towards
    # the food.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('cyan', 'deepSkyBlue', 'royalBlue', start='top')

# Run faster than the default.
app.stepsPerSecond = 60

# food
food = Circle(275, 0, 5, fill='orange')
Label('Food eaten:', 200, 345, fill='white', size=25)
foodCount = Label(0, 200, 375, fill='white', size=25)

# fish
fishBody = Oval(100, 200, 60, 40, fill=gradient('gold', 'yellow', start='left'))
fishTail = Polygon(70, 200, 60, 180, 60, 220,
                   fill=gradient('gold', 'yellow', start='left'))
fishEye = Circle(115, 195, 2)
fish = Group(fishBody, fishTail, fishEye)

# Start the fish right in the center of the canvas.
fish.centerX = 200
fish.centerY = 300

def onStep():
    # Move the fish horizontally by 5 pixels and the food vertically by 2 pixels.
    # Don't forget to wraparound!
    fish.centerX += 5
    food.centerY += 2
    if (fish.left > 400):
        fish.right = 0
    if (food.centerY > 400):
        food.centerY = 0

    # If the fish eats the food, put it at the top again and increase the fish's
    # size by 5 pixels.
    if (fishBody.hitsShape(food) == True):
        foodCount.value += 1
        food.centerY = 0
        fish.height += 5
        fish.width += 5

    # Otherwise, move the fish up or down 1 pixel towards the food.
    elif (fishBody.centerY <= food.centerY):
        fish.centerY += 1
    else:
        fish.centerY -= 1
",regular,2
2146,Boat In Ball Pool,6.3.5,"app.background = gradient('aliceBlue', 'lightBlue')

app.direction = None

boat = Group(
    Label('()', 200, 200, fill='red', size=150),
    Line(200, 160, 200, 280, fill='saddleBrown', lineWidth=30, dashes=(6, 20))
    )

paddle = Group(
    Line(100, 200, 300, 200, fill='gray', lineWidth=6),
    Rect(80, 190, 40, 20, fill='red'),
    Rect(280, 190, 40, 20, fill='red')
    )
boat.add(paddle)

ball = Circle(100, 100, 30, fill='coral')
ball.dx = 0
ball.dy = 10


def onKeyHold(keys):
    # Depending on what arrow key is held, moves the boat appropriately and
    # sets app.direction.
    if ('up' in keys):
        boat.rotateAngle = 0
        boat.centerY -= 5
        app.direction = 'up'
    elif ('down' in keys):
        boat.rotateAngle = 180
        boat.centerY += 5
        app.direction = 'down'
    elif ('left' in keys):
        boat.rotateAngle = -90
        boat.centerX -= 5
        app.direction = 'left'
    elif ('right' in keys):
        boat.rotateAngle = 90
        boat.centerX += 5
        app.direction = 'right'

    # Wrap the boat around in each direction if it goes off the canvas so that
    # it appears on the other side of the canvas.
    ### Place Your Code Here ###

def onStep():
    # The ball bounces if it hits the boat.
    if (boat.hitsShape(ball) == True):
        if (app.direction == 'up'):
            ball.dy = -10
        elif (app.direction == 'down'):
            ball.dy = 10
        elif (app.direction == 'left'):
            ball.dx = -10
        elif (app.direction == 'right'):
            ball.dx = 10

    # Bounces the ball in the x direction if it goes out of bounds.
    if ((ball.left < 0) or (ball.right > 400)):
        ball.dx *= -1

    # Also bounce the ball in the y direction if it goes out of bounds.
    ### Place Your Code Here ###


    # Move the ball using the dx and dy custom properties.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('aliceBlue', 'lightBlue')

app.direction = None

boat = Group(
    Label('()', 200, 200, fill='red', size=150),
    Line(200, 160, 200, 280, fill='saddleBrown', lineWidth=30, dashes=(6, 20))
    )

paddle = Group(
    Line(100, 200, 300, 200, fill='gray', lineWidth=6),
    Rect(80, 190, 40, 20, fill='red'),
    Rect(280, 190, 40, 20, fill='red')
    )
boat.add(paddle)

ball = Circle(100, 100, 30, fill='coral')
ball.dx = 0
ball.dy = 10


def onKeyHold(keys):
    # Depending on what arrow key is held, moves the boat appropriately and
    # sets app.direction.
    if ('up' in keys):
        boat.rotateAngle = 0
        boat.centerY -= 5
        app.direction = 'up'
    elif ('down' in keys):
        boat.rotateAngle = 180
        boat.centerY += 5
        app.direction = 'down'
    elif ('left' in keys):
        boat.rotateAngle = -90
        boat.centerX -= 5
        app.direction = 'left'
    elif ('right' in keys):
        boat.rotateAngle = 90
        boat.centerX += 5
        app.direction = 'right'

    # Wrap the boat around in each direction if it goes off the canvas so that
    # it appears on the other side of the canvas.
    if (boat.bottom < 0):
        boat.top = 400
    elif (boat.top > 400):
        boat.bottom = 0
    elif (boat.left > 400):
        boat.right = 0
    elif (boat.right < 0):
        boat.left = 400

def onStep():
    # The ball bounces if it hits the boat.
    if (boat.hitsShape(ball) == True):
        if (app.direction == 'up'):
            ball.dy = -10
        elif (app.direction == 'down'):
            ball.dy = 10
        elif (app.direction == 'left'):
            ball.dx = -10
        elif (app.direction == 'right'):
            ball.dx = 10

    # Bounces the ball in the x direction if it goes out of bounds.
    if ((ball.left < 0) or (ball.right > 400)):
        ball.dx *= -1

    # Also bounce the ball in the y direction if it goes out of bounds.
    if ((ball.top < 0) or (ball.bottom > 400)):
        ball.dy *= -1

    # Move the ball using the dx and dy custom properties.
    ball.centerX += ball.dx
    ball.centerY += ball.dy
",regular,2
2153,DDR Lite,6.4,"app.background = 'black'
app.stepsPerSecond = 40

Label('Dance Dance Revolution Lite', 200, 70,
      fill='white', size=22, font='monospace', bold=True)
Line(0, 150, 400, 150, fill='white', dashes=True)
Line(0, 250, 400, 250, fill='white', dashes=True)

score = Label(0, 200, 100, fill='white', size=20, font='monospace')
bottomText = Label('How close can you get?', 200, 330, fill='white', size=20,
                   font='monospace', bold=True)
circle = Circle(340, 200, 35, fill=None, border='white', borderWidth=3)
arrow = Group(
    Line(20, 177, 20, 222, fill='red', lineWidth=10),
    Line(0, 200, 20, 177, fill='red', lineWidth=9),
    Line(40, 200, 20, 177, fill='red', lineWidth=9)
    )
arrow.dx = 3

def resetArrow():
    # Rotate the arrow so that it appears randomized.
    x = arrow.centerX // 4
    arrow.rotateAngle = 90 * x - 360 * (x // 4)
    arrow.left = 0
    arrow.centerY = 200

def checkHit():
    # Check if the circle contains the arrow and update the text, score, and
    # speed. Then check if the circle hits the arrow and update the text.
    # Otherwise update the text to 'Missed' and decrease the score and speed.
    ### Fix Your Code Here ###
    if (1 == 2):
        bottomText.value = 'Right on!'
        score.value += 20
    elif (2 == 3):
        bottomText.value = 'Close!'
    else:
        bottomText.value = 'Missed'
        score.value -= 20

    if (arrow.dx <= 0):
        arrow.dx = 1

def onKeyPress(key):
    # If the correct arrow key is pressed, check to see if the arrow is
    # in the circle. Otherwise, change the value of bottomText.
    if (((key == 'up') and (arrow.rotateAngle == 0)) or
        ((key == 'right') and (arrow.rotateAngle == 90)) or
        ((key == 'down') and (arrow.rotateAngle == 180)) or
        ((key == 'left') and (arrow.rotateAngle == 270))):
        checkHit()
    else:
        bottomText.value = 'Wrong key!'
        score.value -= 50
        arrow.dx -= 1
        if (arrow.dx <= 0):
            arrow.dx = 1

    resetArrow()

def onStep():
    # Move arrow.centerX to the right using its custom property.
    # If the arrow moves off screen, change the value of bottomText and
    # score and reset the arrow.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 40

Label('Dance Dance Revolution Lite', 200, 70,
      fill='white', size=22, font='monospace', bold=True)
Line(0, 150, 400, 150, fill='white', dashes=True)
Line(0, 250, 400, 250, fill='white', dashes=True)

score = Label(0, 200, 100, fill='white', size=20, font='monospace')
bottomText = Label('How close can you get?', 200, 330, fill='white', size=20,
                   font='monospace', bold=True)
circle = Circle(340, 200, 35, fill=None, border='white', borderWidth=3)
arrow = Group(
    Line(20, 177, 20, 222, fill='red', lineWidth=10),
    Line(0, 200, 20, 177, fill='red', lineWidth=9),
    Line(40, 200, 20, 177, fill='red', lineWidth=9)
    )
arrow.dx = 3

def resetArrow():
    # Rotate the arrow so that it appears randomized.
    x = arrow.centerX // 4
    arrow.rotateAngle = 90 * x - 360 * (x // 4)
    arrow.left = 0
    arrow.centerY = 200

def checkHit():
    # Check if the circle contains the arrow and update the text, score, and
    # speed. Then check if the circle hits the arrow and update the text.
    # Otherwise update the text to 'Missed' and decrease the score and speed.
    if (circle.containsShape(arrow) == True):
        bottomText.value = 'Right on!'
        score.value += 20
        arrow.dx += 1
    elif (circle.hitsShape(arrow) == True):
        bottomText.value = 'Close!'
    else:
        bottomText.value = 'Missed'
        score.value -= 20
        arrow.dx -= 1

    if (arrow.dx <= 0):
        arrow.dx = 1

def onKeyPress(key):
    # If the correct arrow key is pressed, check to see if the arrow is
    # in the circle. Otherwise, change the value of bottomText.
    if (((key == 'up') and (arrow.rotateAngle == 0)) or
        ((key == 'right') and (arrow.rotateAngle == 90)) or
        ((key == 'down') and (arrow.rotateAngle == 180)) or
        ((key == 'left') and (arrow.rotateAngle == 270))):
        checkHit()
    else:
        bottomText.value = 'Wrong key!'
        score.value -= 50
        arrow.dx -= 1
        if (arrow.dx <= 0):
            arrow.dx = 1

    resetArrow()

def onStep():
    # Move arrow.centerX to the right using its custom property.
    # If the arrow moves off screen, change the value of bottomText and
    # score and reset the arrow.
    arrow.centerX += arrow.dx
    if (arrow.left > 400):
        bottomText.value = 'Missed'
        score.value -= 20
        resetArrow()
",regular,1
2147,Bumper cars,6.4,"app.background = 'darkRed'

# players
player1 = Group(
    Oval(30, 30, 60, 40, fill=gradient('salmon', 'white', start='left'),
         border='white', borderWidth=5),
    Line(10, 10, 25, 10, lineWidth=8),
    Line(40, 10, 55, 10, lineWidth=8),
    Line(10, 50, 25, 50, lineWidth=8),
    Line(40, 50, 55, 50, lineWidth=8),
    Oval(50, 30, 5, 20),
    Line(25, 20, 50, 25, fill='dimGrey'),
    Line(25, 40, 50, 35, fill='dimGrey'),
    Oval(30, 30, 20, 30, fill='dimGrey'),
    Circle(30, 30, 10),
    Polygon(5, 30, -5, -10, -10, -10, -10, -8)
    )

player2 = Group(
    Oval(370, 370, 60, 40, fill=gradient('cornflowerBlue', 'white', start='left'),
         border='white', borderWidth=5),
    Line(390, 390, 375, 390, lineWidth=8),
    Line(360, 390, 345, 390, lineWidth=8),
    Line(390, 350, 375, 350, lineWidth=8),
    Line(360, 350, 345, 350, lineWidth=8),
    Oval(350, 370, 5, 20),
    Line(375, 380, 350, 375, fill='dimGrey'),
    Line(375, 360, 350, 365, fill='dimGrey'),
    Oval(370, 370, 20, 30, fill='dimGrey'),
    Circle(370, 370, 10),
    Polygon(395, 370, 405, 410, 410, 410, 410, 408)
    )

offenseInfo = Label('Player 1 is on Offense', 200, 20, fill='salmon', size=24)
Label('Time until switch:', 180, 50, fill='white', size=15)
timer = Label(50, 250, 50, fill='white', size=15)

def wrapPlayer(player):
    if (player.centerX > 400):
        player.centerX = 0
    elif (player.centerX < 0):
        player.centerX = 400

    if (player.centerY > 400):
        player.centerY = 0
    elif (player.centerY < 0):
        player.centerY = 400

def onKeyHold(keys):
    # Move player1 in response to the keys w-a-s-d (up-left-down-right).
    # Turn the car to the appropriate angle for each direction it moves.
    ### Place Your Code Here ###

    # Move player2 in response to the respective arrow keys. Turn the car
    # to the appropriate angle for each direction it moves.
    ### Place Your Code Here ###

    # Call the helper function to wrap the players around when they leave the
    # canvas.
    ### Place Your Code Here ###

    # End the game if the cars collide, and then display the winner.
    ### Place Your Code Here ###
    pass

def onStep():
    # When the timer is 0, changes who is on offense and resets the timer.
    timer.value -= 1
    if (timer.value <= 0):
        if (offenseInfo.fill == 'cornflowerBlue'):
            offenseInfo.value = 'Player 1 is on Offense'
            offenseInfo.fill = 'salmon'
            app.background = 'darkRed'
        else:
            offenseInfo.value = 'Player 2 is on Offense'
            offenseInfo.fill = 'cornflowerBlue'
            app.background = 'darkBlue'

        timer.value = 50
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'darkRed'

# players
player1 = Group(
    Oval(30, 30, 60, 40, fill=gradient('salmon', 'white', start='left'),
         border='white', borderWidth=5),
    Line(10, 10, 25, 10, lineWidth=8),
    Line(40, 10, 55, 10, lineWidth=8),
    Line(10, 50, 25, 50, lineWidth=8),
    Line(40, 50, 55, 50, lineWidth=8),
    Oval(50, 30, 5, 20),
    Line(25, 20, 50, 25, fill='dimGrey'),
    Line(25, 40, 50, 35, fill='dimGrey'),
    Oval(30, 30, 20, 30, fill='dimGrey'),
    Circle(30, 30, 10),
    Polygon(5, 30, -5, -10, -10, -10, -10, -8)
    )

player2 = Group(
    Oval(370, 370, 60, 40, fill=gradient('cornflowerBlue', 'white', start='left'),
         border='white', borderWidth=5),
    Line(390, 390, 375, 390, lineWidth=8),
    Line(360, 390, 345, 390, lineWidth=8),
    Line(390, 350, 375, 350, lineWidth=8),
    Line(360, 350, 345, 350, lineWidth=8),
    Oval(350, 370, 5, 20),
    Line(375, 380, 350, 375, fill='dimGrey'),
    Line(375, 360, 350, 365, fill='dimGrey'),
    Oval(370, 370, 20, 30, fill='dimGrey'),
    Circle(370, 370, 10),
    Polygon(395, 370, 405, 410, 410, 410, 410, 408)
    )

offenseInfo = Label('Player 1 is on Offense', 200, 20, fill='salmon', size=24)
Label('Time until switch:', 180, 50, fill='white', size=15)
timer = Label(50, 250, 50, fill='white', size=15)

def wrapPlayer(player):
    if (player.centerX > 400):
        player.centerX = 0
    elif (player.centerX < 0):
        player.centerX = 400

    if (player.centerY > 400):
        player.centerY = 0
    elif (player.centerY < 0):
        player.centerY = 400

def onKeyHold(keys):
    # Move player1 in response to the keys w-a-s-d (up-left-down-right).
    # Turn the car to the appropriate angle for each direction it moves.
    if ('w' in keys):
        player1.centerY -= 10
        player1.rotateAngle = -90
    if ('a' in keys):
        player1.centerX -= 10
        player1.rotateAngle = 180
    if ('s' in keys):
        player1.centerY += 10
        player1.rotateAngle = 90
    if ('d' in keys):
        player1.centerX += 10
        player1.rotateAngle = 0

    # Move player2 in response to the respective arrow keys. Turn the car
    # to the appropriate angle for each direction it moves.
    if ('up' in keys):
        player2.centerY -= 10
        player2.rotateAngle = 90
    if ('left' in keys):
        player2.centerX -= 10
        player2.rotateAngle = 0
    if ('down' in keys):
        player2.centerY += 10
        player2.rotateAngle = -90
    if ('right' in keys):
        player2.centerX += 10
        player2.rotateAngle = 180

    # Call the helper function to wrap the players around when they leave the
    # canvas.
    wrapPlayer(player1)
    wrapPlayer(player2)

    # End the game if the cars collide, and then display the winner.
    if (player1.hitsShape(player2) == True):
        if (offenseInfo.fill == 'salmon'):
            offenseInfo.value = 'Player 1 Wins!'
        else:
            offenseInfo.value = 'Player 2 Wins!'

        app.stop()

def onStep():
    # When the timer is 0, changes who is on offense and resets the timer.
    timer.value -= 1
    if (timer.value <= 0):
        if (offenseInfo.fill == 'cornflowerBlue'):
            offenseInfo.value = 'Player 1 is on Offense'
            offenseInfo.fill = 'salmon'
            app.background = 'darkRed'
        else:
            offenseInfo.value = 'Player 2 is on Offense'
            offenseInfo.fill = 'cornflowerBlue'
            app.background = 'darkBlue'

        timer.value = 50
",regular,2
2148,Pulse,6.4,"app.background = gradient('mediumOrchid', 'indigo', start='bottom')
app.stepsPerSecond = 20

star = Star(200, 220, 50, 5, fill='cornflowerBlue')
ring = Star(200, 220, 5, 5, fill=None, border=gradient('white', 'yellow'),
            borderWidth=8)

score = Label(0, 350, 40, fill=None, border='white', size=50, bold=True)

gameOverLabel = Label('Game over', 200, 200, fill='navy', size=30, bold=True)
gameOverGroup = Group(
    Rect(200, 210, 200, 60, fill='aliceBlue', align='center'),
    gameOverLabel,
    Label('Press any key to play again', 200, 225, fill='navy')
    )
gameOverGroup.visible = False

def gameOver(message):
    gameOverLabel.value = message
    gameOverGroup.visible = True
    ring.visible = False

def restartGame():
    ring.radius = 5
    star.radius = 50
    score.value = 0
    gameOverGroup.visible = False
    ring.visible = True

def onKeyPress(key):
    # When a key is pressed while the game is over, restart.
    if (gameOverGroup.visible == True):
        restartGame()
    else:
        # If the ring was not close enough to the star, end the game.
        if (star.fill != 'mediumSeaGreen'):
            star.fill = 'orangeRed'
            gameOver('Oh No!!!')

        # Otherwise move on to the next round.
        else:
            ring.radius = 5
            star.radius += 10
            score.value += 1
            if (score.value == 15):
                gameOver('You Win!!!')

def onStep():
    # When game is in-play, increase the radius of the ring by the score + 1.
    # Depending on the size of the ring, set the color of star and end the
    # game if needed.
    ### (HINT: The player loses if the ring becomes larger than
    #          star.radius + 25.)
    ### (HINT: Use test cases to determine when the colors change.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('mediumOrchid', 'indigo', start='bottom')
app.stepsPerSecond = 20

star = Star(200, 220, 50, 5, fill='cornflowerBlue')
ring = Star(200, 220, 5, 5, fill=None, border=gradient('white', 'yellow'),
            borderWidth=8)

score = Label(0, 350, 40, fill=None, border='white', size=50, bold=True)

gameOverLabel = Label('Game over', 200, 200, fill='navy', size=30, bold=True)
gameOverGroup = Group(
    Rect(200, 210, 200, 60, fill='aliceBlue', align='center'),
    gameOverLabel,
    Label('Press any key to play again', 200, 225, fill='navy')
    )
gameOverGroup.visible = False

def gameOver(message):
    gameOverLabel.value = message
    gameOverGroup.visible = True
    ring.visible = False

def restartGame():
    ring.radius = 5
    star.radius = 50
    score.value = 0
    gameOverGroup.visible = False
    ring.visible = True

def onKeyPress(key):
    # When a key is pressed while the game is over, restart.
    if (gameOverGroup.visible == True):
        restartGame()
    else:
        # If the ring was not close enough to the star, end the game.
        if (star.fill != 'mediumSeaGreen'):
            star.fill = 'orangeRed'
            gameOver('Oh No!!!')

        # Otherwise move on to the next round.
        else:
            ring.radius = 5
            star.radius += 10
            score.value += 1
            if (score.value == 15):
                gameOver('You Win!!!')

def onStep():
    # When game is in-play, increase the radius of the ring by the score + 1.
    # Depending on the size of the ring, set the color of star and end the
    # game if needed.
    if (gameOverGroup.visible == False):
        ring.radius += 1 + score.value

        if (ring.radius < star.radius - 25):
            star.fill = 'cornflowerBlue'
        elif (ring.radius > star.radius + 25):
            star.fill = 'orangeRed'
            gameOver('Oh No!!!')
        else:
            star.fill = 'mediumSeaGreen'
",regular,2
2149,Tron,6.4,"app.background = rgb(35, 30, 30)

app.stepsPerSecond = 8
app.paused = True

# player
player = Rect(200, 200, 20, 20, fill=rgb(70, 75, 220), align='center')
player.speed = 21
player.dx = 0
player.dy = player.speed
player.offScreen = False

# The past locations of the player.
trail = Group()

# instructions
instructions = Group(
    Label('TRON', 200, 50, size=20),
    Label('Move with w,a,s,d', 200, 70),
    Label('The path starts moving down', 200, 85),
    Label('Press r to start or restart', 200, 100)
    )
instructions.fill = rgb(250, 245, 255)

# end game labels
endGameInfo = Group(
    Rect(200, 200, 250, 150, fill=rgb(185, 70, 50), align='center'),
    Label('GAME OVER', 200, 150, fill='white', size=30),
    Label('Score: ', 150, 185, fill='white', size=24, align='left'),
    Label('Restart with r', 200, 225, fill='white', size=18)
    )

endScore = Label(0, 240, 185, fill='white', size=24)
endGameInfo.add(endScore)
endGameInfo.visible = False

score = Label(0, 35, 30, fill='white', size=40)
score.visible = False

def restartGame():
    # Reset the player.
    player.centerX = 200
    player.centerY = 200
    player.dx = 0
    player.dy = player.speed
    player.offScreen = False

    # Reset the scores and info screens.
    score.value = 0
    score.visible = True
    endGameInfo.visible = False
    trail.clear()
    instructions.visible = False

    app.paused = False

def gameOver():
    # Hide the score, show the end game screen, and pause the app.
    score.visible = False

    endGameInfo.visible = True
    endScore.value = score.value
    endGameInfo.toFront()
    app.paused = True
    instructions.visible = True

def playerOffScreenTest():
    # Check if the player's centerX or centerY are off the screen and set
    # the custom property appropriately.
    ### Place Your Code Here ###
    pass

def setPlayerSpeed(newDx, newDy):
    player.dx = newDx
    player.dy = newDy

def onKeyPress(key):
    # Restart the game if 'r' is pressed.
    if (key == 'r'):
        restartGame()

    # Change the player's dx and dy.
    if (key == 'w'):
        setPlayerSpeed(0, -player.speed)
    elif (key == 'a'):
        setPlayerSpeed(-player.speed, 0)
    elif (key == 's'):
        setPlayerSpeed(0, player.speed)
    elif (key == 'd'):
        setPlayerSpeed(player.speed, 0)

def onStep():
    # Move the player and make sure they are on the screen.
    player.centerX += player.dx
    player.centerY += player.dy
    playerOffScreenTest()

    # If the player is offscreen or intersecting itself, then end the game.
    ### Place Your Code Here ###

    # Otherwise, add a copy of the current player to the group trail,
    # and increase the score by 1.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(35, 30, 30)

app.stepsPerSecond = 8
app.paused = True

# player
player = Rect(200, 200, 20, 20, fill=rgb(70, 75, 220), align='center')
player.speed = 21
player.dx = 0
player.dy = player.speed
player.offScreen = False

# The past locations of the player.
trail = Group()

# instructions
instructions = Group(
    Label('TRON', 200, 50, size=20),
    Label('Move with w,a,s,d', 200, 70),
    Label('The path starts moving down', 200, 85),
    Label('Press r to start or restart', 200, 100)
    )
instructions.fill = rgb(250, 245, 255)

# end game labels
endGameInfo = Group(
    Rect(200, 200, 250, 150, fill=rgb(185, 70, 50), align='center'),
    Label('GAME OVER', 200, 150, fill='white', size=30),
    Label('Score: ', 150, 185, fill='white', size=24, align='left'),
    Label('Restart with r', 200, 225, fill='white', size=18)
    )

endScore = Label(0, 240, 185, fill='white', size=24)
endGameInfo.add(endScore)
endGameInfo.visible = False

score = Label(0, 35, 30, fill='white', size=40)
score.visible = False

def restartGame():
    # Reset the player.
    player.centerX = 200
    player.centerY = 200
    player.dx = 0
    player.dy = player.speed
    player.offScreen = False

    # Reset the scores and info screens.
    score.value = 0
    score.visible = True
    endGameInfo.visible = False
    trail.clear()
    instructions.visible = False

    app.paused = False

def gameOver():
    # Hide the score, show the end game screen, and pause the app.
    score.visible = False

    endGameInfo.visible = True
    endScore.value = score.value
    endGameInfo.toFront()
    app.paused = True
    instructions.visible = True

def playerOffScreenTest():
    # Check if the player's centerX or centerY are off the screen and set
    # the custom property appropriately.
    if ((player.centerX < 0) or (player.centerX > 400) or
        (player.centerY < 0) or (player.centerY > 400)):
        player.offScreen = True

def setPlayerSpeed(newDx, newDy):
    player.dx = newDx
    player.dy = newDy

def onKeyPress(key):
    # Restart the game if 'r' is pressed.
    if (key == 'r'):
        restartGame()

    # Change the player's dx and dy.
    if (key == 'w'):
        setPlayerSpeed(0, -player.speed)
    elif (key == 'a'):
        setPlayerSpeed(-player.speed, 0)
    elif (key == 's'):
        setPlayerSpeed(0, player.speed)
    elif (key == 'd'):
        setPlayerSpeed(player.speed, 0)

def onStep():
    # Move the player and make sure they are on the screen.
    player.centerX += player.dx
    player.centerY += player.dy
    playerOffScreenTest()

    # If the player is offscreen or intersecting itself, then end the game.
    if ((player.offScreen == True) or (player.hitsShape(trail) == True)):
        gameOver()

    # Otherwise, add a copy of the current player to the group trail,
    # and increase the score by 1.
    else:
        trail.add(
            Rect(player.left, player.top, player.width, player.height,
                 fill=player.fill)
            )
        score.value += 1
",regular,3
2150,Up,6.4,"app.stepsPerSecond = 20
app.background = gradient('dodgerBlue', 'paleTurquoise', start='top')

# Organize the balloons together.
balloons = Group(
    Line(145, 50, 185, 270, fill='white', lineWidth=1),
    Circle(145, 50, 50,
           fill=gradient('plum', 'indigo', 'indigo', start='right-top')),
    Line(185, 110, 185, 270, fill='white', lineWidth=1),
    Circle(185, 110, 45,
           fill=gradient('lavender', 'mediumPurple', 'mediumPurple',
                         start='right-top')),
    Line(225, 50, 185, 270, fill='white', lineWidth=1),
    Circle(225, 50, 35,
           fill=gradient('plum', 'darkViolet', 'darkViolet', start='right-top')),
    Line(105, 120, 185, 270, fill='white', lineWidth=1),
    Circle(105, 120, 40,
           fill=gradient('plum', 'mediumVioletRed', 'mediumVioletRed',
                         start='right-top')),
    Line(265, 120, 185, 270, fill='white', lineWidth=1),
    Circle(265, 120, 35,
           fill=gradient('plum', 'purple', 'purple', start='right-top'))
    )

# Organize the house parts together.
house = Group(
    Rect(150, 350, 50, 50, fill='pink', border='white'),
    Rect(200, 350, 50, 50, fill='limeGreen', border='white'),
    Polygon(140, 350, 260, 350, 260, 300, 150, 300, fill='mediumSlateBlue',
            border='white', borderWidth=1),
    Polygon(200, 360, 200, 340, 225, 310, 250, 340, 250, 360,
            fill='lemonChiffon', border='white'),
    Polygon(160, 340, 160, 330, 170, 320, 180, 330, 180, 340,
            fill='lemonChiffon', border='white'),
    Rect(175, 380, 10, 20, fill='maroon', border='white'),
    Rect(150, 350, 50, 15, fill='cornflowerBlue', border='white'),
    Rect(180, 270, 10, 40, fill='brown', border='white', borderWidth=1),
    Rect(225, 380, 12, 20, fill='silver', border='mistyRose', align='center'),
    Rect(225, 340, 10, 18, fill='silver', border='mistyRose', align='center'),
    Rect(170, 333, 5, 9, fill='silver', border='mistyRose', align='center'),
    Rect(162, 385, 6, 12, fill='silver', border='mistyRose', align='center')
    )

# Combine the house and balloons into a single group.
upHouse = Group(balloons, house)

def onStep():
    # Move the house up 8 pixels, with wraparound.
    ### Place Your Code Here ###
    pass

def onKeyHold(keys):
    # If right or left keys are held, move in that direction by 5 with wraparound.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 20
app.background = gradient('dodgerBlue', 'paleTurquoise', start='top')

# Organize the balloons together.
balloons = Group(
    Line(145, 50, 185, 270, fill='white', lineWidth=1),
    Circle(145, 50, 50,
           fill=gradient('plum', 'indigo', 'indigo', start='right-top')),
    Line(185, 110, 185, 270, fill='white', lineWidth=1),
    Circle(185, 110, 45,
           fill=gradient('lavender', 'mediumPurple', 'mediumPurple',
                         start='right-top')),
    Line(225, 50, 185, 270, fill='white', lineWidth=1),
    Circle(225, 50, 35,
           fill=gradient('plum', 'darkViolet', 'darkViolet', start='right-top')),
    Line(105, 120, 185, 270, fill='white', lineWidth=1),
    Circle(105, 120, 40,
           fill=gradient('plum', 'mediumVioletRed', 'mediumVioletRed',
                         start='right-top')),
    Line(265, 120, 185, 270, fill='white', lineWidth=1),
    Circle(265, 120, 35,
           fill=gradient('plum', 'purple', 'purple', start='right-top'))
    )

# Organize the house parts together.
house = Group(
    Rect(150, 350, 50, 50, fill='pink', border='white'),
    Rect(200, 350, 50, 50, fill='limeGreen', border='white'),
    Polygon(140, 350, 260, 350, 260, 300, 150, 300, fill='mediumSlateBlue',
            border='white', borderWidth=1),
    Polygon(200, 360, 200, 340, 225, 310, 250, 340, 250, 360,
            fill='lemonChiffon', border='white'),
    Polygon(160, 340, 160, 330, 170, 320, 180, 330, 180, 340,
            fill='lemonChiffon', border='white'),
    Rect(175, 380, 10, 20, fill='maroon', border='white'),
    Rect(150, 350, 50, 15, fill='cornflowerBlue', border='white'),
    Rect(180, 270, 10, 40, fill='brown', border='white', borderWidth=1),
    Rect(225, 380, 12, 20, fill='silver', border='mistyRose', align='center'),
    Rect(225, 340, 10, 18, fill='silver', border='mistyRose', align='center'),
    Rect(170, 333, 5, 9, fill='silver', border='mistyRose', align='center'),
    Rect(162, 385, 6, 12, fill='silver', border='mistyRose', align='center')
    )

# Combine the house and balloons into a single group.
upHouse = Group(balloons, house)

def onStep():
    # Move the house up 8 pixels, with wraparound.
    upHouse.centerY -= 8
    if (upHouse.bottom < 0):
        upHouse.top = 400

def onKeyHold(keys):
    # If right or left keys are held, move in that direction by 5 with wraparound.
    if ('right' in keys):
        upHouse.right += 5
    if ('left' in keys):
        upHouse.right -= 5

    if (upHouse.left > 400):
        upHouse.right = 0
    elif (upHouse.right < 0):
        upHouse.left = 400
",regular,1
2151,Weight lifting stick person,6.4,"app.background = gradient(rgb(230, 120, 70), rgb(225, 215, 135), start='top')

# stick figure
Circle(200, 200, 30, fill=rgb(70, 75, 75))
Line(200, 200, 200, 300, fill=rgb(70, 75, 75), lineWidth=6)
Line(200, 300, 150, 350, fill=rgb(70, 75, 75), lineWidth=5)
Line(200, 300, 250, 350, fill=rgb(70, 75, 75), lineWidth=5)
leftArm = Line(200, 250, 150, 300, fill=rgb(70, 75, 75), lineWidth=5)
rightArm = Line(200, 250, 250, 300, fill=rgb(70, 75, 75), lineWidth=5)

# Define the weight as a group.
### Place Your Code Here ###
# weight =
Line(100, 300, 300, 300, lineWidth=6,
     fill=gradient('gainsboro', rgb(195, 195, 200), start='bottom'))
Rect(75, 270, 15, 60, fill=rgb(70, 75, 75), border=rgb(195, 195, 200))
Rect(90, 260, 15, 80, fill=rgb(70, 75, 75), border=rgb(195, 195, 200))
Rect(310, 270, 15, 60, fill=rgb(70, 75, 75), border=rgb(195, 195, 200))
Rect(295, 260, 15, 80, fill=rgb(70, 75, 75), border=rgb(195, 195, 200))

liftedCounter = Label(0, 200, 100, fill=rgb(70, 75, 75), size=25)

def onKeyPress(key):
    # Move the weight up.
    ### Place Your Code Here ###

    # Move the left and right arms to lift the weight.
    ### (HINT: Set the y2 values of arms to the height of the weight's center.)
    ### Place Your Code Here ###
    pass

    liftedCounter.value += 1

def onKeyRelease(key):
    # Move the arms and weight back to their original positions.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(230, 120, 70), rgb(225, 215, 135), start='top')

# stick figure
Circle(200, 200, 30, fill=rgb(70, 75, 75))
Line(200, 200, 200, 300, fill=rgb(70, 75, 75), lineWidth=6)
Line(200, 300, 150, 350, fill=rgb(70, 75, 75), lineWidth=5)
Line(200, 300, 250, 350, fill=rgb(70, 75, 75), lineWidth=5)
leftArm = Line(200, 250, 150, 300, fill=rgb(70, 75, 75), lineWidth=5)
rightArm = Line(200, 250, 250, 300, fill=rgb(70, 75, 75), lineWidth=5)

# Define the weight as a group.
weight = Group(
    Line(100, 300, 300, 300, lineWidth=6,
        fill=gradient('gainsboro', rgb(195, 195, 200), start='bottom')),
    Rect(75, 270, 15, 60, fill=rgb(70, 75, 75), border=rgb(195, 195, 200)),
    Rect(90, 260, 15, 80, fill=rgb(70, 75, 75), border=rgb(195, 195, 200)),
    Rect(310, 270, 15, 60, fill=rgb(70, 75, 75), border=rgb(195, 195, 200)),
    Rect(295, 260, 15, 80, fill=rgb(70, 75, 75), border=rgb(195, 195, 200))
    )

liftedCounter = Label(0, 200, 100, fill=rgb(70, 75, 75), size=25)

def onKeyPress(key):
    # Move the weight up.
    weight.centerY = 140

    # Move the left and right arms to lift the weight.
    leftArm.y2 = 140
    rightArm.y2 = 140

    liftedCounter.value += 1

def onKeyRelease(key):
    # Move the arms and weight back to their original positions.
    leftArm.y2 = 300
    rightArm.y2 = 300
    weight.centerY = 300
",regular,1
2152,Rotating tardis,6.4,"app.background = gradient(rgb(0, 30, 70), 'black')
app.stepsPerSecond = 15

tardis = Group(
    Rect(200, 390, 200, 20, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Rect(200, 245, 180, 270, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Rect(200, 255, 140, 250, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Rect(200, 95, 200, 40, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),

    # frame
    Rect(200, 95, 180, 25, align='center'),
    Rect(200, 75, 180, 10, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Polygon(120, 70, 120, 50, 190, 30, 210, 30, 280, 50, 280, 70,
            fill=rgb(55, 105, 155), border=rgb(0, 30, 70)),
    Rect(200, 20, 20, 15, fill='lightYellow', border=rgb(0, 30, 70),
         borderWidth=3, align='center'),
    Polygon(185, 10, 200, 0, 215, 10, fill=rgb(55, 105, 155),
            border=rgb(0, 30, 70)),

    # top windows
    Rect(145, 150, 50, 50, fill='lightYellow', border=rgb(0, 30, 70)),
    Rect(205, 150, 50, 50, fill='lightYellow', border=rgb(0, 30, 70)),
    Line(170, 150, 170, 200, fill=rgb(0, 30, 70)),
    Line(230, 150, 230, 200, fill=rgb(0, 30, 70)),
    Line(145, 175, 195, 175, fill=rgb(0, 30, 70)),
    Line(205, 175, 255, 175, fill=rgb(0, 30, 70)),

    # more windows
    Rect(145, 210, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(150, 215, 35, 40, fill='gainsboro', border=rgb(0, 30, 70)),
    Rect(210, 210, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(145, 270, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(210, 270, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(145, 330, 45, 40, fill=None, border=rgb(0, 30, 70)),
    Rect(210, 330, 45, 40, fill=None, border=rgb(0, 30, 70))
    )


def onStep():
    # Move the Tardis right by 25 pixels, rotate it clockwise 5 degrees, and
    # increase the size by 5.
    ### Place Your Code Here ###

    # If the width of the Tardis reaches 400 pixels make the Tardis upright,
    # reset the width and height to 25 and 50, and center the Tardis
    # vertically in the canvas.
    ### Place Your Code Here ###

    # Implement wraparound.
    if (tardis.left > 400):
        tardis.right = 0
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(0, 30, 70), 'black')
app.stepsPerSecond = 15

tardis = Group(
    Rect(200, 390, 200, 20, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Rect(200, 245, 180, 270, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Rect(200, 255, 140, 250, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Rect(200, 95, 200, 40, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),

    # frame
    Rect(200, 95, 180, 25, align='center'),
    Rect(200, 75, 180, 10, fill=rgb(55, 105, 155), border=rgb(0, 30, 70),
         borderWidth=4, align='center'),
    Polygon(120, 70, 120, 50, 190, 30, 210, 30, 280, 50, 280, 70,
            fill=rgb(55, 105, 155), border=rgb(0, 30, 70)),
    Rect(200, 20, 20, 15, fill='lightYellow', border=rgb(0, 30, 70),
         borderWidth=3, align='center'),
    Polygon(185, 10, 200, 0, 215, 10, fill=rgb(55, 105, 155),
            border=rgb(0, 30, 70)),

    # top windows
    Rect(145, 150, 50, 50, fill='lightYellow', border=rgb(0, 30, 70)),
    Rect(205, 150, 50, 50, fill='lightYellow', border=rgb(0, 30, 70)),
    Line(170, 150, 170, 200, fill=rgb(0, 30, 70)),
    Line(230, 150, 230, 200, fill=rgb(0, 30, 70)),
    Line(145, 175, 195, 175, fill=rgb(0, 30, 70)),
    Line(205, 175, 255, 175, fill=rgb(0, 30, 70)),

    # more windows
    Rect(145, 210, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(150, 215, 35, 40, fill='gainsboro', border=rgb(0, 30, 70)),
    Rect(210, 210, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(145, 270, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(210, 270, 45, 50, fill=None, border=rgb(0, 30, 70)),
    Rect(145, 330, 45, 40, fill=None, border=rgb(0, 30, 70)),
    Rect(210, 330, 45, 40, fill=None, border=rgb(0, 30, 70))
    )


def onStep():
    # Move the Tardis right by 25 pixels, rotate it clockwise 5 degrees, and
    # increase the size by 5.
    tardis.centerX += 25
    tardis.rotateAngle += 5
    tardis.width += 5
    tardis.height += 5

    # If the width of the Tardis reaches 400 pixels make the Tardis upright,
    # reset the width and height to 25 and 50, and center the Tardis
    # vertically in the canvas.
    if (tardis.width >= 400):
        tardis.rotateAngle = 0
        tardis.width = 25
        tardis.height = 50
        tardis.centerY = 200
    # Implement wraparound.
    if (tardis.left > 400):
        tardis.right = 0
",regular,2
2132,Beach ball,6.4,"app.background = gradient('lightSteelBlue', 'skyBlue', start='top')

# ocean and beach
Rect(0, 190, 400, 190, fill=gradient('darkBlue', 'royalBlue', start='top'))
Polygon(0, 300, 270, 335, 400, 300, 400, 400, 0, 400,
        fill=gradient('paleGoldenrod', 'burlyWood', start='top'))
Polygon(0, 295, 270, 330, 400, 295, 400, 300, 270, 340, 0, 300, fill='white')

wave = Oval(220, 250, 700, 60, fill='darkBlue', border='steelBlue', opacity=50)
Rect(0, 200, 400, 30, fill='darkBlue')

shadow = Oval(200, 370, 125, 12, fill='darkKhaki', opacity=60)

beachBall = Group(
    Polygon(200, 300, 150, 250, 200, 225, fill='red'),
    Polygon(200, 300, 200, 225, 250, 250, fill='blue'),
    Polygon(200, 300, 250, 250, 275, 300, fill='green'),
    Polygon(275, 300, 200, 300, 250, 350, fill='purple'),
    Polygon(250, 350, 200, 300, 200, 375, fill='yellow'),
    Polygon(200, 375, 200, 300, 150, 350, fill='orange'),
    Polygon(200, 300, 150, 350, 125, 300, fill='fuchsia'),
    Polygon(150, 250, 200, 300, 125, 300, fill='slateBlue'),
    Circle(200, 300, 68, fill=gradient('white', 'black'), opacity=15)
    )
beachBall.direction = 1

def onKeyHold(keys):
    # Moves the wave in and out and fade appropriately.
    wave.opacity += 2 * beachBall.direction
    wave.height += beachBall.direction

    # The ball should rotate and roll until it reaches the end of the canvas
    # at which point it should reverse direction.
    ### (HINT: Use beachBall.direction to move and rotate in the correct
    #          direction. Then multiply it by -1 to reverse direction.)
    ### Place Your Code Here ###

    shadow.centerX = beachBall.centerX
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightSteelBlue', 'skyBlue', start='top')

# ocean and beach
Rect(0, 190, 400, 190, fill=gradient('darkBlue', 'royalBlue', start='top'))
Polygon(0, 300, 270, 335, 400, 300, 400, 400, 0, 400,
        fill=gradient('paleGoldenrod', 'burlyWood', start='top'))
Polygon(0, 295, 270, 330, 400, 295, 400, 300, 270, 340, 0, 300, fill='white')

wave = Oval(220, 250, 700, 60, fill='darkBlue', border='steelBlue', opacity=50)
Rect(0, 200, 400, 30, fill='darkBlue')

shadow = Oval(200, 370, 125, 12, fill='darkKhaki', opacity=60)

beachBall = Group(
    Polygon(200, 300, 150, 250, 200, 225, fill='red'),
    Polygon(200, 300, 200, 225, 250, 250, fill='blue'),
    Polygon(200, 300, 250, 250, 275, 300, fill='green'),
    Polygon(275, 300, 200, 300, 250, 350, fill='purple'),
    Polygon(250, 350, 200, 300, 200, 375, fill='yellow'),
    Polygon(200, 375, 200, 300, 150, 350, fill='orange'),
    Polygon(200, 300, 150, 350, 125, 300, fill='fuchsia'),
    Polygon(150, 250, 200, 300, 125, 300, fill='slateBlue'),
    Circle(200, 300, 68, fill=gradient('white', 'black'), opacity=15)
    )
beachBall.direction = 1

def onKeyHold(keys):
    # Moves the wave in and out and fade appropriately.
    wave.opacity += 2 * beachBall.direction
    wave.height += beachBall.direction

    # The ball should rotate and roll until it reaches the end of the canvas
    # at which point it should reverse direction.
    beachBall.rotateAngle += 5 * beachBall.direction
    beachBall.centerX += 6 * beachBall.direction
    if ((beachBall.right >= 400) or (beachBall.left <= 0)):
        beachBall.direction *= -1

    shadow.centerX = beachBall.centerX
",regular,2
2156,Creative task 1,6.5,# Fill me in!,,creative,30
2154,Beach,6.5,"# sky
sky = Rect(0, 0, 400, 600, fill=gradient('skyBlue', 'lightSkyBlue', 'pink',
                                         'lightSalmon', start='top'))

# sun
outerSun = Circle(200, 0, 5, fill='orange', opacity=50)
innerSun = Circle(200, 0, 70, fill='gold')

# ocean
topWave = Rect(0, 200, 400, 60, fill='dodgerBlue')
midWave = Rect(0, 260, 400, 40, fill='deepSkyBlue')
lowWave = Rect(0, 300, 400, 200, fill='turquoise')

# The sun's reflections on the water.
sunReflections = Group(
    Oval(200, 204, 120, 5, fill='gold'),
    Oval(165, 210, 80, 5, fill='gold'),
    Oval(255, 210, 70, 5, fill='gold'),
    Oval(230, 217, 95, 5, fill='gold'),
    Oval(190, 223, 60, 5, fill='gold'),
    Oval(235, 232, 60, 5, fill='gold'),
    Oval(155, 232, 60, 5, fill='gold')
    )
sunReflections.opacity = 0

# foam
Polygon(0, 400, 0, 280, 300, 335, 400, 320, 400, 400, fill='white')

# sand
Polygon(0, 400, 0, 290, 300, 360, 400, 330, 400, 400, fill='wheat')
Polygon(0, 335, 400, 390, 400, 400, 0, 400, fill='burlyWood')

def onMouseMove(mouseX, mouseY):
    # Move the waves.
    topWave.height = 40 + (mouseY / 60)
    midWave.top = topWave.bottom
    midWave.height = 30 + (mouseY / 20)
    lowWave.top = midWave.bottom

def onStep():
    # As long as the sun hasn't reached the horizon, make the sun reflections
    # gradually appear.
    if (innerSun.centerY < 200):
        if ((sunReflections.opacity < 100) and (innerSun.bottom > 200)):
            sunReflections.opacity += 3

        # Change the sky color (shift the sky down).
        sky.top -= 5

        # Move the sun and increase the radius of the glow.
        innerSun.centerY += 3
        outerSun.centerY += 3
        outerSun.radius = innerSun.centerY / 2
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# sky
sky = Rect(0, 0, 400, 600, fill=gradient('skyBlue', 'lightSkyBlue', 'pink',
                                         'lightSalmon', start='top'))

# sun
outerSun = Circle(200, 0, 5, fill='orange', opacity=50)
innerSun = Circle(200, 0, 70, fill='gold')

# ocean
topWave = Rect(0, 200, 400, 60, fill='dodgerBlue')
midWave = Rect(0, 260, 400, 40, fill='deepSkyBlue')
lowWave = Rect(0, 300, 400, 200, fill='turquoise')

# The sun's reflections on the water.
sunReflections = Group(
    Oval(200, 204, 120, 5, fill='gold'),
    Oval(165, 210, 80, 5, fill='gold'),
    Oval(255, 210, 70, 5, fill='gold'),
    Oval(230, 217, 95, 5, fill='gold'),
    Oval(190, 223, 60, 5, fill='gold'),
    Oval(235, 232, 60, 5, fill='gold'),
    Oval(155, 232, 60, 5, fill='gold')
    )
sunReflections.opacity = 0

# foam
Polygon(0, 400, 0, 280, 300, 335, 400, 320, 400, 400, fill='white')

# sand
Polygon(0, 400, 0, 290, 300, 360, 400, 330, 400, 400, fill='wheat')
Polygon(0, 335, 400, 390, 400, 400, 0, 400, fill='burlyWood')

def onMouseMove(mouseX, mouseY):
    # Move the waves.
    topWave.height = 40 + (mouseY / 60)
    midWave.top = topWave.bottom
    midWave.height = 30 + (mouseY / 20)
    lowWave.top = midWave.bottom

def onStep():
    # As long as the sun hasn't reached the horizon, make the sun reflections
    # gradually appear.
    if (innerSun.centerY < 200):
        if ((sunReflections.opacity < 100) and (innerSun.bottom > 200)):
            sunReflections.opacity += 3

        # Change the sky color (shift the sky down).
        sky.top -= 5

        # Move the sun and increase the radius of the glow.
        innerSun.centerY += 3
        outerSun.centerY += 3
        outerSun.radius = innerSun.centerY / 2
",sample,1
2155,Airhockey,6.5,"app.background = 'white'
app.stepsPerSecond = 30

# board and lines
Rect(200, 200, 295, 375, fill=rgb(55, 75, 120), align='center')
Circle(200, 10, 40, fill=None, border='fireBrick', borderWidth=3)
Circle(200, 390, 40, fill=None, border='cornflowerBlue', borderWidth=3)
Rect(200, 5, 90, 10, fill=app.background, align='center')
Rect(200, 395, 90, 10, fill=app.background, align='center')
Line(50, 85, 350, 85, fill='fireBrick')
Line(50, 305, 350, 305, fill='cornflowerBlue')
Line(50, 200, 350, 200, fill='azure', dashes=True)
Circle(200, 200, 25, fill=rgb(55, 75, 120), border='azure')
Circle(200, 200, 3, fill='azure')

# border
Circle(60, 20, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(340, 20, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(60, 380, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(340, 380, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(65, 25, 13, fill=rgb(55, 75, 120))
Circle(335, 25, 13, fill=rgb(55, 75, 120))
Circle(65, 375, 13, fill=rgb(55, 75, 120))
Circle(335, 375, 13, fill=rgb(55, 75, 120))
Line(60, 10, 340, 10, fill='midnightBlue', lineWidth=5)
Line(50, 20, 50, 380, fill='midnightBlue', lineWidth=5)
Line(350, 20, 350, 380, fill='midnightBlue', lineWidth=5)
Line(60, 390, 340, 390, fill='midnightBlue', lineWidth=5)

# score for blue player
scoreB = Label(0, 25, 360, fill='royalBlue', size=30)

# score for red goalie
scoreR = Label(0, 375, 40, fill='fireBrick', size=30)

# hockey puck
puck = Circle(200, 200, 10, fill='snow', border='grey')
puck.dx = 3
puck.dy = 3
puck.numHits = 0

player = Group(
    Circle(200, 365, 12, fill='royalBlue'),
    Circle(200, 365, 8, fill='cornflowerBlue')
    )
goalie = Group(
    Circle(200, 35, 12, fill='fireBrick'),
    Circle(200, 35, 8, fill='crimson')
    )

def resetPuck():
    puck.centerX = 200
    puck.centerY = 200
    puck.dx = 3
    puck.dy = 3
    puck.numHits = 0

def hitPuck(paddle):
    # Deflect the puck differently based on if it hits on the left, middle,
    # or right.
    if (puck.centerX - paddle.centerX >= 4):
        puck.dx = 3 + puck.numHits
    elif (paddle.centerX - puck.centerX >= 4):
        puck.dx = -3 - puck.numHits
    else:
        puck.dx = 0

    # Deflect the puck differently based on if it hits on the top or bottom.
    if (puck.centerY - paddle.centerY >= 6):
        puck.dy = 3 + puck.numHits
    elif (paddle.centerY - puck.centerY >= 6):
        puck.dy = -3 - puck.numHits

    if (puck.numHits <= 10):
        puck.numHits += 1

def onMouseMove(mouseX, mouseY):
    if ((mouseX >= 60) and (mouseX <= 340) and (mouseY > 200)):
        player.centerX = mouseX
        player.centerY = mouseY

def onKeyPress(key):
    if (key == 'r'):
        resetPuck()

def onStep():
    puck.centerX += puck.dx
    puck.centerY += puck.dy

    # If there is a goal, increment the score and reset the puck.
    if ((puck.centerX >= 165) and (puck.centerX <= 235) and
        ((puck.centerY <= 20) or (puck.centerY >= 380))):
        if (puck.centerY <= 20):
            scoreB.value += 1
        elif (puck.centerY >= 380):
            scoreR.value += 1

        resetPuck()

    # Bounce the puck if necessary.
    if ((puck.centerX <= 60) or (puck.centerX >= 340)):
        puck.dx *= -1
    if ((puck.centerY <= 20) or (puck.centerY >= 380)):
        puck.dy *= -1

    # Move the goalie.
    if (puck.centerX - goalie.centerX < 0):
        goalie.centerX -= 5
    elif (puck.centerX - goalie.centerX > 0):
        goalie.centerX += 5
    if (goalie.centerX < 135):
        goalie.centerX = 135
    elif (goalie.centerX > 265):
        goalie.centerX = 265

    if (puck.hitsShape(player) == True):
        hitPuck(player)
    if (goalie.hitsShape(puck) == True):
        hitPuck(goalie)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'white'
app.stepsPerSecond = 30

# board and lines
Rect(200, 200, 295, 375, fill=rgb(55, 75, 120), align='center')
Circle(200, 10, 40, fill=None, border='fireBrick', borderWidth=3)
Circle(200, 390, 40, fill=None, border='cornflowerBlue', borderWidth=3)
Rect(200, 5, 90, 10, fill=app.background, align='center')
Rect(200, 395, 90, 10, fill=app.background, align='center')
Line(50, 85, 350, 85, fill='fireBrick')
Line(50, 305, 350, 305, fill='cornflowerBlue')
Line(50, 200, 350, 200, fill='azure', dashes=True)
Circle(200, 200, 25, fill=rgb(55, 75, 120), border='azure')
Circle(200, 200, 3, fill='azure')

# border
Circle(60, 20, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(340, 20, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(60, 380, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(340, 380, 10, fill=None, border='midnightBlue', borderWidth=5)
Circle(65, 25, 13, fill=rgb(55, 75, 120))
Circle(335, 25, 13, fill=rgb(55, 75, 120))
Circle(65, 375, 13, fill=rgb(55, 75, 120))
Circle(335, 375, 13, fill=rgb(55, 75, 120))
Line(60, 10, 340, 10, fill='midnightBlue', lineWidth=5)
Line(50, 20, 50, 380, fill='midnightBlue', lineWidth=5)
Line(350, 20, 350, 380, fill='midnightBlue', lineWidth=5)
Line(60, 390, 340, 390, fill='midnightBlue', lineWidth=5)

# score for blue player
scoreB = Label(0, 25, 360, fill='royalBlue', size=30)

# score for red goalie
scoreR = Label(0, 375, 40, fill='fireBrick', size=30)

# hockey puck
puck = Circle(200, 200, 10, fill='snow', border='grey')
puck.dx = 3
puck.dy = 3
puck.numHits = 0

player = Group(
    Circle(200, 365, 12, fill='royalBlue'),
    Circle(200, 365, 8, fill='cornflowerBlue')
    )
goalie = Group(
    Circle(200, 35, 12, fill='fireBrick'),
    Circle(200, 35, 8, fill='crimson')
    )

def resetPuck():
    puck.centerX = 200
    puck.centerY = 200
    puck.dx = 3
    puck.dy = 3
    puck.numHits = 0

def hitPuck(paddle):
    # Deflect the puck differently based on if it hits on the left, middle,
    # or right.
    if (puck.centerX - paddle.centerX >= 4):
        puck.dx = 3 + puck.numHits
    elif (paddle.centerX - puck.centerX >= 4):
        puck.dx = -3 - puck.numHits
    else:
        puck.dx = 0

    # Deflect the puck differently based on if it hits on the top or bottom.
    if (puck.centerY - paddle.centerY >= 6):
        puck.dy = 3 + puck.numHits
    elif (paddle.centerY - puck.centerY >= 6):
        puck.dy = -3 - puck.numHits

    if (puck.numHits <= 10):
        puck.numHits += 1

def onMouseMove(mouseX, mouseY):
    if ((mouseX >= 60) and (mouseX <= 340) and (mouseY > 200)):
        player.centerX = mouseX
        player.centerY = mouseY

def onKeyPress(key):
    if (key == 'r'):
        resetPuck()

def onStep():
    puck.centerX += puck.dx
    puck.centerY += puck.dy

    # If there is a goal, increment the score and reset the puck.
    if ((puck.centerX >= 165) and (puck.centerX <= 235) and
        ((puck.centerY <= 20) or (puck.centerY >= 380))):
        if (puck.centerY <= 20):
            scoreB.value += 1
        elif (puck.centerY >= 380):
            scoreR.value += 1

        resetPuck()

    # Bounce the puck if necessary.
    if ((puck.centerX <= 60) or (puck.centerX >= 340)):
        puck.dx *= -1
    if ((puck.centerY <= 20) or (puck.centerY >= 380)):
        puck.dy *= -1

    # Move the goalie.
    if (puck.centerX - goalie.centerX < 0):
        goalie.centerX -= 5
    elif (puck.centerX - goalie.centerX > 0):
        goalie.centerX += 5
    if (goalie.centerX < 135):
        goalie.centerX = 135
    elif (goalie.centerX > 265):
        goalie.centerX = 265

    if (puck.hitsShape(player) == True):
        hitPuck(player)
    if (goalie.hitsShape(puck) == True):
        hitPuck(goalie)
",sample,1
2157,Creative task 2,6.5,# Fill me in!,,creative,30
2161,Collaborative task,6.5,# Fill me in!,,creative,30
2160,Semester Project,6.5,# Fill me in!,,creative,30
2159,Creative task 4,6.5,# Fill me in!,,creative,30
2158,Creative task 3,6.5,# Fill me in!,,creative,30
2165,Bow and arrow,7.1.2,"# background
Rect(0, 0, 400, 300, fill=gradient('lightSkyBlue', 'lightCyan', start='top'))
Rect(0, 300, 400, 100, fill=gradient('seaGreen', 'darkOliveGreen', start='top'))

# points
Label('Score:', 10, 25, size=24, align='left')
score = Label(0, 110, 26, size=28)

# stick person
Circle(80, 220, 20)
Line(80, 220, 80, 330, lineWidth=3)
Line(80, 330, 100, 380, lineWidth=3)
Line(80, 330, 60, 380, lineWidth=3)
leftArm = Line(80, 255, 100, 280, lineWidth=3)
rightArm = Line(80, 255, 125, 280, lineWidth=3)

# target
target = Group(
    Line(325, 265, 310, 302, fill='burlyWood'),
    Line(325, 265, 340, 302, fill='burlyWood'),
    Circle(325, 265, 25, fill='burlyWood'),
    Circle(325, 265, 22, fill='ghostWhite'),
    Circle(325, 265, 15, fill='crimson', border='deepSkyBlue', borderWidth=7),
    Circle(325, 265, 3, fill='yellow')
    )

# bow and arrow
### (HINT: The bow is defined as an arc!)
bow = Arc(100, 280, 50, 160, 0, 180, fill=None,
          border=gradient('saddleBrown', 'burlyWood', start='left'), borderWidth=5)

arrow = Line(100, 280, 200, 280, lineWidth=3, arrowEnd=True,
             fill=gradient('lightGrey', 'saddleBrown', start='right'))

def resetArrow():
    arrow.rotateAngle = 0
    arrow.x1 = 100
    arrow.y1 = 280
    arrow.x2 = 200
    arrow.y2 = 280
    arrow.lineWidth = 3
    leftArm.x2 = arrow.left

def resetBow():
    bow.startAngle = 0
    bow.sweepAngle = 180
    bow.width = 25
    bow.right = 125

def onMousePress(mouseX, mouseY):
    resetArrow()

def onMouseRelease(mouseX, mouseY):
    arrow.width = 30
    arrow.lineWidth = 1

    if (bow.sweepAngle < 130):
        arrow.right = 325
        arrow.centerY = 265
        score.value += 10
    elif (arrow.centerX < 150):
        arrow.rotateAngle = 30
        arrow.right = 300
        arrow.bottom = 310

    resetBow()

def onMouseDrag(mouseX, mouseY):
    if (bow.sweepAngle >= 125):
        # Pull back the arrow and increase the startAngle of the bow. Then decrease
        # the sweepAngle of the bow and increase the width and keep the right of
        # the bow in the same place.
        ### (HINT: Use the test cases to determine how much to change the
        #          properties.)
        ### Place Your Code Here ###

        # Moves the left arm.
        leftArm.x2 = arrow.left

def onKeyPress(key):
    # Do not change this function! It is for testing purposes only!
    if (key == 'q'):
        arrow.left = 56
        bow.startAngle = 22
        bow.sweepAngle = 136
        bow.width = 69
        bow.right = 125
        leftArm.x2 = arrow.left
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 300, fill=gradient('lightSkyBlue', 'lightCyan', start='top'))
Rect(0, 300, 400, 100, fill=gradient('seaGreen', 'darkOliveGreen', start='top'))

# points
Label('Score:', 10, 25, size=24, align='left')
score = Label(0, 110, 26, size=28)

# stick person
Circle(80, 220, 20)
Line(80, 220, 80, 330, lineWidth=3)
Line(80, 330, 100, 380, lineWidth=3)
Line(80, 330, 60, 380, lineWidth=3)
leftArm = Line(80, 255, 100, 280, lineWidth=3)
rightArm = Line(80, 255, 125, 280, lineWidth=3)

# target
target = Group(
    Line(325, 265, 310, 302, fill='burlyWood'),
    Line(325, 265, 340, 302, fill='burlyWood'),
    Circle(325, 265, 25, fill='burlyWood'),
    Circle(325, 265, 22, fill='ghostWhite'),
    Circle(325, 265, 15, fill='crimson', border='deepSkyBlue', borderWidth=7),
    Circle(325, 265, 3, fill='yellow')
    )

# bow and arrow
### (HINT: The bow is defined as an arc!)
bow = Arc(100, 280, 50, 160, 0, 180, fill=None,
          border=gradient('saddleBrown', 'burlyWood', start='left'), borderWidth=5)

arrow = Line(100, 280, 200, 280, lineWidth=3, arrowEnd=True,
             fill=gradient('lightGrey', 'saddleBrown', start='right'))

def resetArrow():
    arrow.rotateAngle = 0
    arrow.x1 = 100
    arrow.y1 = 280
    arrow.x2 = 200
    arrow.y2 = 280
    arrow.lineWidth = 3
    leftArm.x2 = arrow.left

def resetBow():
    bow.startAngle = 0
    bow.sweepAngle = 180
    bow.width = 25
    bow.right = 125

def onMousePress(mouseX, mouseY):
    resetArrow()

def onMouseRelease(mouseX, mouseY):
    arrow.width = 30
    arrow.lineWidth = 1

    if (bow.sweepAngle < 130):
        arrow.right = 325
        arrow.centerY = 265
        score.value += 10
    elif (arrow.centerX < 150):
        arrow.rotateAngle = 30
        arrow.right = 300
        arrow.bottom = 310

    resetBow()

def onMouseDrag(mouseX, mouseY):
    if (bow.sweepAngle >= 125):
        # Pull back the arrow and increase the startAngle of the bow. Then decrease
        # the sweepAngle of the bow and increase the width and keep the right of
        # the bow in the same place.
        arrow.left -= 2
        bow.startAngle += 1
        bow.sweepAngle -= 2
        bow.width += 2
        bow.right = 125

        # Moves the left arm.
        leftArm.x2 = arrow.left

def onKeyPress(key):
    # Do not change this function! It is for testing purposes only!
    if (key == 'q'):
        arrow.left = 56
        bow.startAngle = 22
        bow.sweepAngle = 136
        bow.width = 69
        bow.right = 125
        leftArm.x2 = arrow.left
",regular,2
2167,Man and pizza,7.1.2,"app.background = rgb(105, 140, 35)
app.stepsPerSecond = 2.5

def drawVeggie(x,y):
    v = Group(
        Line(115, 235, 123, 245, fill='forestGreen', lineWidth=5),
        Line(120, 235, 128, 245, fill='forestGreen', lineWidth=5)
        )
    v.centerX = x
    v.centerY = y

def drawPizza():
    # pizza
    Arc(210, 310, 300, 300, 270, 60, fill=rgb(140, 70, 20))
    Arc(210, 310, 280, 280, 270, 60, fill=rgb(250, 190, 80))
    Arc(210, 310, 280, 280, 270, 30, fill=rgb(255, 230, 180))

    # pepperoni
    Circle(160, 280, 10, fill=rgb(205, 50, 50))
    Circle(160, 250, 10, fill=rgb(205, 50, 50))
    Circle(130, 290, 10, fill=rgb(205, 50, 50))
    Circle(95, 295, 10, fill=rgb(205, 50, 50))
    Circle(135, 225, 10, fill=rgb(205, 50, 50))

    drawVeggie(115, 235)
    drawVeggie(150, 270)
    drawVeggie(145, 220)
    drawVeggie(95, 275)

drawPizza()

bite1 = Circle(225, 305, 5, fill=rgb(105, 140, 35))
bite2 = Circle(180, 355, 5, fill=rgb(105, 140, 35))

# face
Circle(350, 230, 150, fill=rgb(140, 70, 20))
Oval(380, 400, 120, 220, fill=rgb(140, 70, 20), rotateAngle=-30)
eye = Line(250, 205, 285, 205, lineWidth=5)

mouth = Arc(305, 270, 200, 200, 230, 40, fill=rgb(105, 140, 35))

# hat
Polygon(230, 125, 470, 125, 420, 25, 280, 25, fill=rgb(210, 180, 140))
Polygon(235, 115, 230, 125, 470, 125, 465, 115, fill='white')
Polygon(230, 125, 225, 115, 218, 118, 225, 135, 475, 135, 482, 118, 475, 115,
        470, 125)
Line(245, 95, 400, 95, lineWidth=10, dashes=True)

def onStep():
    # As long as the bites don't cover the pizza, move the mouth. Also, increase
    # both of the bites' radii when the person bites down.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(105, 140, 35)
app.stepsPerSecond = 2.5

def drawVeggie(x,y):
    v = Group(
        Line(115, 235, 123, 245, fill='forestGreen', lineWidth=5),
        Line(120, 235, 128, 245, fill='forestGreen', lineWidth=5)
        )
    v.centerX = x
    v.centerY = y

def drawPizza():
    # pizza
    Arc(210, 310, 300, 300, 270, 60, fill=rgb(140, 70, 20))
    Arc(210, 310, 280, 280, 270, 60, fill=rgb(250, 190, 80))
    Arc(210, 310, 280, 280, 270, 30, fill=rgb(255, 230, 180))

    # pepperoni
    Circle(160, 280, 10, fill=rgb(205, 50, 50))
    Circle(160, 250, 10, fill=rgb(205, 50, 50))
    Circle(130, 290, 10, fill=rgb(205, 50, 50))
    Circle(95, 295, 10, fill=rgb(205, 50, 50))
    Circle(135, 225, 10, fill=rgb(205, 50, 50))

    drawVeggie(115, 235)
    drawVeggie(150, 270)
    drawVeggie(145, 220)
    drawVeggie(95, 275)

drawPizza()

bite1 = Circle(225, 305, 5, fill=rgb(105, 140, 35))
bite2 = Circle(180, 355, 5, fill=rgb(105, 140, 35))

# face
Circle(350, 230, 150, fill=rgb(140, 70, 20))
Oval(380, 400, 120, 220, fill=rgb(140, 70, 20), rotateAngle=-30)
eye = Line(250, 205, 285, 205, lineWidth=5)

mouth = Arc(305, 270, 200, 200, 230, 40, fill=rgb(105, 140, 35))

# hat
Polygon(230, 125, 470, 125, 420, 25, 280, 25, fill=rgb(210, 180, 140))
Polygon(235, 115, 230, 125, 470, 125, 465, 115, fill='white')
Polygon(230, 125, 225, 115, 218, 118, 225, 135, 475, 135, 482, 118, 475, 115,
        470, 125)
Line(245, 95, 400, 95, lineWidth=10, dashes=True)

def onStep():
    # As long as the bites don't cover the pizza, move the mouth. Also, increase
    # both of the bites' radii when the person bites down.
    if (bite1.radius <= 175):
        if (mouth.sweepAngle == 20):
            mouth.sweepAngle = 40
            mouth.startAngle = 230
        elif (mouth.sweepAngle == 40):
            bite1.radius += 25
            bite2.radius += 25
            mouth.sweepAngle = 20
            mouth.startAngle = 240
",regular,2
2164,Pacman,7.1.2,"app.background = 'black'

# background
Line(125, 0, 125, 400, fill='blue', lineWidth=20, opacity=20, dashes=(100, 200))
Line(275, 0, 275, 400, fill='blue', lineWidth=20, opacity=20, dashes=(100, 200))
Line(0, 100, 400, 100, fill='blue', lineWidth=20, opacity=20, dashes=(125, 150))
Line(0, 300, 400, 300, fill='blue', lineWidth=20, opacity=20, dashes=(125, 150))

# pellets
Circle(200, 415, 30, fill='gold', opacity=40)
Circle(200, -15, 30, fill='gold', opacity=40)
Circle(200, 70, 30, fill='gold', opacity=40)
Circle(200, 330, 30, fill='gold', opacity=40)

# cherry
Line(255, 230, 285, 145, fill='gold', lineWidth=5)
Line(315, 230, 280, 160, fill='gold', lineWidth=5)
Rect(280, 145, 10, 22, fill='gold', rotateAngle=20)
Circle(255, 235, 25, fill='red')
Circle(315, 235, 25, fill='red')

# Draw Pacman.
### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# background
Line(125, 0, 125, 400, fill='blue', lineWidth=20, opacity=20, dashes=(100, 200))
Line(275, 0, 275, 400, fill='blue', lineWidth=20, opacity=20, dashes=(100, 200))
Line(0, 100, 400, 100, fill='blue', lineWidth=20, opacity=20, dashes=(125, 150))
Line(0, 300, 400, 300, fill='blue', lineWidth=20, opacity=20, dashes=(125, 150))

# pellets
Circle(200, 415, 30, fill='gold', opacity=40)
Circle(200, -15, 30, fill='gold', opacity=40)
Circle(200, 70, 30, fill='gold', opacity=40)
Circle(200, 330, 30, fill='gold', opacity=40)

# cherry
Line(255, 230, 285, 145, fill='gold', lineWidth=5)
Line(315, 230, 280, 160, fill='gold', lineWidth=5)
Rect(280, 145, 10, 22, fill='gold', rotateAngle=20)
Circle(255, 235, 25, fill='red')
Circle(315, 235, 25, fill='red')

# Draw Pacman.
Arc(100, 200, 175, 175, 135, 270, fill='yellow')
Circle(105, 150, 10)
",regular,1
2168,Firefly,7.1.2,"app.background = 'midnightBlue'
app.stepsPerSecond = 5

# grass
Oval(150, 250, 150, 300, fill='darkGreen', rotateAngle=350)
Oval(130, 250, 150, 300, fill='midnightBlue', rotateAngle=350)
Oval(130, 300, 120, 280, fill='darkGreen')
Oval(145, 300, 120, 280, fill='midnightBlue')
Rect(0, 350, 400, 50, fill='darkGreen')

glow = Star(200, 220, 100, 200, fill='white', opacity=0)

# firefly
body = Arc(200, 190, 120, 160, 155, 50, fill='yellow')
Oval(200, 210, 25, 40)
Oval(200, 180, 25, 35, fill='fireBrick')
Line(197, 165, 196, 140)
Line(203, 165, 204, 140)
Arc(190, 172, 15, 15, 200, 180)
Arc(210, 172, 15, 15, 340, 180)
wingPosition1 = Group(
    Arc(200, 200, 160, 160, 185, 85, fill='darkGrey', opacity=80),
    Arc(200, 200, 160, 160, 90, 85, fill='darkGrey', opacity=80)
    )
wingPosition2 = Group(
    Arc(200, 200, 160, 160, 205, 50, fill='darkGrey', opacity=80),
    Arc(200, 200, 160, 160, 105, 50, fill='darkGrey', opacity=80)
    )
wingPosition2.visible = False

def onMouseMove(mouseX, mouseY):
    # If the mouse is hovering over the firefly's body, make it glow.
    ### Place Your Code Here ###
    pass

def onStep():
    # Move the wings back and forth by changing the visibility of the wing
    # positions.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'midnightBlue'
app.stepsPerSecond = 5

# grass
Oval(150, 250, 150, 300, fill='darkGreen', rotateAngle=350)
Oval(130, 250, 150, 300, fill='midnightBlue', rotateAngle=350)
Oval(130, 300, 120, 280, fill='darkGreen')
Oval(145, 300, 120, 280, fill='midnightBlue')
Rect(0, 350, 400, 50, fill='darkGreen')

glow = Star(200, 220, 100, 200, fill='white', opacity=0)

# firefly
body = Arc(200, 190, 120, 160, 155, 50, fill='yellow')
Oval(200, 210, 25, 40)
Oval(200, 180, 25, 35, fill='fireBrick')
Line(197, 165, 196, 140)
Line(203, 165, 204, 140)
Arc(190, 172, 15, 15, 200, 180)
Arc(210, 172, 15, 15, 340, 180)
wingPosition1 = Group(
    Arc(200, 200, 160, 160, 185, 85, fill='darkGrey', opacity=80),
    Arc(200, 200, 160, 160, 90, 85, fill='darkGrey', opacity=80)
    )
wingPosition2 = Group(
    Arc(200, 200, 160, 160, 205, 50, fill='darkGrey', opacity=80),
    Arc(200, 200, 160, 160, 105, 50, fill='darkGrey', opacity=80)
    )
wingPosition2.visible = False

def onMouseMove(mouseX, mouseY):
    # If the mouse is hovering over the firefly's body, make it glow.
    if (body.contains(mouseX, mouseY) == True):
        glow.opacity = 30
    else:
        glow.opacity = 0

def onStep():
    # Move the wings back and forth by changing the visibility of the wing
    # positions.
    if (wingPosition1.visible == True):
        wingPosition1.visible = False
        wingPosition2.visible = True
    else:
        wingPosition1.visible = True
        wingPosition2.visible = False
",regular,1
2166,Fire alarm,7.1.2,"app.background = rgb(130, 130, 130)

app.fireAlarmOn = False

# wall, floor, and fire
Rect(0, 300, 400, 100, fill='dimGrey')
Rect(100, 100, 125, 200, fill=rgb(50, 50, 50))
Star(400, 400, 150, 24, fill=gradient('orange', 'orangeRed', 'fireBrick'),
     roundness=80)
Star(400, 400, 100, 20, fill=gradient('yellow', 'orange', 'orangeRed'),
     roundness=85)
Star(400, 400, 40, 16, fill=gradient('white', 'yellow', 'orange'), roundness=90)

# Draw the exit sign.
### Place Your Code Here ###
pass

# pull station
lever = Group(
    Line(58, 180, 82, 180, fill='white', lineWidth=6),
    Line(70, 180, 70, 190, fill='white', lineWidth=6)
    )
pullStation = Group(
    Rect(50, 160, 40, 50, fill='salmon', borderWidth=4,
         border=gradient('lightCoral', 'fireBrick', start='left-top')),
    Rect(58, 170, 24, 14, fill='fireBrick'),
    lever
    )

# alarm
Rect(235, 100, 40, 50, fill='salmon', borderWidth=4,
     border=gradient('lightCoral', 'fireBrick', start='left-top'))
Line(255, 110, 255, 130, fill='fireBrick', lineWidth=24, dashes=(1, 3))
Rect(240, 138, 30, 12, fill='white')

# sign and alarm light covers
lightUp = Group(
    Rect(125, 60, 75, 30, opacity=40),
    Rect(240, 138, 30, 12, opacity=40)
    )

roomLights = Rect(0, 0, 400, 400, fill='fireBrick', opacity=0)
flashingLight = Arc(255, 145, 200, 200, 0, 10, fill='white', opacity=0)

def onMousePress(mouseX, mouseY):
    # If the pull station is clicked, swap between having the fire alarm on and off.
    ### Fix Your Code Here ###
    if (app.fireAlarmOn == False):
        app.fireAlarmOn = True
        lever.centerY += 10
        lightUp.opacity = 0
        flashingLight.opacity = 50
        roomLights.opacity = 20
    else:
        app.fireAlarmOn = False
        lever.centerY -= 10
        lightUp.opacity = 40
        flashingLight.opacity = 0
        roomLights.opacity = 0

def onStep():
    # If the fire alarm is on, increase the sweepAngle and startAngle of the
    # flashing light.
    ### (HINT: Use the test cases to determine how much to increase the
    #          properties.)
    ### (HINT: The sweepAngle should never be bigger than 360, if it is, set
    #          it back to 10.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(130, 130, 130)

app.fireAlarmOn = False

# wall, floor, and fire
Rect(0, 300, 400, 100, fill='dimGrey')
Rect(100, 100, 125, 200, fill=rgb(50, 50, 50))
Star(400, 400, 150, 24, fill=gradient('orange', 'orangeRed', 'fireBrick'),
     roundness=80)
Star(400, 400, 100, 20, fill=gradient('yellow', 'orange', 'orangeRed'),
     roundness=85)
Star(400, 400, 40, 16, fill=gradient('white', 'yellow', 'orange'), roundness=90)

# Draw the exit sign.
Rect(125, 60, 75, 30, fill='mediumSeaGreen', border='white', borderWidth=4)
Label('EXIT', 175, 75, fill='white', bold=True)
Line(135, 75, 155, 75, fill='white', arrowStart=True, lineWidth=1)

# pull station
lever = Group(
    Line(58, 180, 82, 180, fill='white', lineWidth=6),
    Line(70, 180, 70, 190, fill='white', lineWidth=6)
    )
pullStation = Group(
    Rect(50, 160, 40, 50, fill='salmon', borderWidth=4,
         border=gradient('lightCoral', 'fireBrick', start='left-top')),
    Rect(58, 170, 24, 14, fill='fireBrick'),
    lever
    )

# alarm
Rect(235, 100, 40, 50, fill='salmon', borderWidth=4,
     border=gradient('lightCoral', 'fireBrick', start='left-top'))
Line(255, 110, 255, 130, fill='fireBrick', lineWidth=24, dashes=(1, 3))
Rect(240, 138, 30, 12, fill='white')

# sign and alarm light covers
lightUp = Group(
    Rect(125, 60, 75, 30, opacity=40),
    Rect(240, 138, 30, 12, opacity=40)
    )

roomLights = Rect(0, 0, 400, 400, fill='fireBrick', opacity=0)
flashingLight = Arc(255, 145, 200, 200, 0, 10, fill='white', opacity=0)

def onMousePress(mouseX, mouseY):
    # If the pull station is clicked, swap between having the fire alarm on and off.
    if (pullStation.hits(mouseX, mouseY) == True):
        if (app.fireAlarmOn == False):
            app.fireAlarmOn = True
            lever.centerY += 10
            lightUp.opacity = 0
            flashingLight.opacity = 50
            roomLights.opacity = 20
        else:
            app.fireAlarmOn = False
            lever.centerY -= 10
            lightUp.opacity = 40
            flashingLight.opacity = 0
            roomLights.opacity = 0

def onStep():
    # If the fire alarm is on, increase the sweepAngle and startAngle of the
    # flashing light.
    if (app.fireAlarmOn == True):
        flashingLight.sweepAngle += 10
        flashingLight.startAngle += 5

        if (flashingLight.sweepAngle >= 360):
            flashingLight.sweepAngle = 10
",regular,2
2170,Jellyfish or squid,7.2.2,"app.background = rgb(55, 225, 205)
app.stepsPerSecond = 25

# body
outerHead = Oval(200, 300, 210, 220, fill=rgb(250, 200, 230))
animal = Oval(200, 300,  180, 200, fill=rgb(250, 220, 240))
animal.type = 'jellyfish'
Rect(95, 300, 210, 100, fill=rgb(55, 225, 205))

# tentacles
tentacles = Line(120, 340, 280, 340, fill=rgb(250, 220, 240), lineWidth=80,
                 dashes=(20, 15))

# eyes
Circle(155, 265, 10)
Circle(245, 265, 10)
Circle(155, 260, 5, fill='grey')
Circle(245, 260, 5, fill='grey')

# mouth
Circle(200, 265, 15, fill=rgb(250, 120, 180))
mouthCover = Rect(185, 250, 30, 15, fill=rgb(250, 220, 240))

# bubbles
bubble1 = Circle(120, 30, 40, fill=gradient('lightCyan', 'lavender'), opacity=20,
                 border=gradient('powderBlue', 'cornflowerBlue', start='top'))
bubble2 = Circle(120, 90, 30, fill=bubble1.fill, border=bubble1.border,
                 opacity=40)
bubble3 = Circle(120, 150, 20, fill=bubble1.fill, border=bubble1.border,
                 opacity=60)
bubble4 = Circle(120, 210, 10, fill=bubble1.fill, border=bubble1.border,
                 opacity=80)
bubble5 = Circle(120, 270, 1, fill=bubble1.fill, border=bubble1.border)

ink = Polygon(180, 300, 170, 335, 145, 375, 110, 400, 290, 400, 255, 375,
              230, 335, 220, 300, opacity=85, visible=False)

def moveBubble(bubble):
    bubble.centerY -= 3
    bubble.radius += 1
    bubble.opacity -= 1
    if (bubble.opacity <= 2):
        bubble.centerY = 270
        bubble.radius = 1
        bubble.opacity = 90

def onMousePress(mouseX, mouseY):
    if (animal.type == 'squid'):
        ink.visible = True
        tentacles.toFront()

def onKeyPress(key):
    # Define these local variables depending on what animal is showing.
    ### (HINT: Use the custom property animal.type!)
    ### Fix Your Code Here ###
    backColor = rgb(250, 200, 230)
    frontColor = rgb(250, 220, 240)
    animalHeight = 200
    animal.type = 'jellyfish'

    # Uses the local variables to set the animal's properties.
    outerHead.fill = backColor
    outerHead.height = animalHeight + 20
    animal.fill = frontColor
    animal.height = animalHeight

    mouthCover.fill = frontColor
    tentacles.fill = frontColor

    ink.visible = False

def onStep():
    # Moves each of the bubbles and wrap them around when needed.
    moveBubble(bubble1)
    moveBubble(bubble2)
    moveBubble(bubble3)
    moveBubble(bubble4)
    moveBubble(bubble5)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(55, 225, 205)
app.stepsPerSecond = 25

# body
outerHead = Oval(200, 300, 210, 220, fill=rgb(250, 200, 230))
animal = Oval(200, 300,  180, 200, fill=rgb(250, 220, 240))
animal.type = 'jellyfish'
Rect(95, 300, 210, 100, fill=rgb(55, 225, 205))

# tentacles
tentacles = Line(120, 340, 280, 340, fill=rgb(250, 220, 240), lineWidth=80,
                 dashes=(20, 15))

# eyes
Circle(155, 265, 10)
Circle(245, 265, 10)
Circle(155, 260, 5, fill='grey')
Circle(245, 260, 5, fill='grey')

# mouth
Circle(200, 265, 15, fill=rgb(250, 120, 180))
mouthCover = Rect(185, 250, 30, 15, fill=rgb(250, 220, 240))

# bubbles
bubble1 = Circle(120, 30, 40, fill=gradient('lightCyan', 'lavender'), opacity=20,
                 border=gradient('powderBlue', 'cornflowerBlue', start='top'))
bubble2 = Circle(120, 90, 30, fill=bubble1.fill, border=bubble1.border,
                 opacity=40)
bubble3 = Circle(120, 150, 20, fill=bubble1.fill, border=bubble1.border,
                 opacity=60)
bubble4 = Circle(120, 210, 10, fill=bubble1.fill, border=bubble1.border,
                 opacity=80)
bubble5 = Circle(120, 270, 1, fill=bubble1.fill, border=bubble1.border)

ink = Polygon(180, 300, 170, 335, 145, 375, 110, 400, 290, 400, 255, 375,
              230, 335, 220, 300, opacity=85, visible=False)

def moveBubble(bubble):
    bubble.centerY -= 3
    bubble.radius += 1
    bubble.opacity -= 1
    if (bubble.opacity <= 2):
        bubble.centerY = 270
        bubble.radius = 1
        bubble.opacity = 90

def onMousePress(mouseX, mouseY):
    if (animal.type == 'squid'):
        ink.visible = True
        tentacles.toFront()

def onKeyPress(key):
    # Define these local variables depending on what animal is showing.
    if (animal.type == 'jellyfish'):
        backColor = 'black'
        frontColor = 'dimGrey'
        animalHeight = 380
        animal.type = 'squid'
    else:
        backColor = rgb(250, 200, 230)
        frontColor = rgb(250, 220, 240)
        animalHeight = 200
        animal.type = 'jellyfish'

    # Uses the local variables to set the animal's properties.
    outerHead.fill = backColor
    outerHead.height = animalHeight + 20
    animal.fill = frontColor
    animal.height = animalHeight

    mouthCover.fill = frontColor
    tentacles.fill = frontColor

    ink.visible = False

def onStep():
    # Moves each of the bubbles and wrap them around when needed.
    moveBubble(bubble1)
    moveBubble(bubble2)
    moveBubble(bubble3)
    moveBubble(bubble4)
    moveBubble(bubble5)
",regular,2
2169,Fading background,7.2.2,"app.stepsPerSecond = 50
app.steps = 0
app.innerBlueIncreasing = True

background = Rect(0, 0, 400, 400)

def onStep():
    # Increases steps up to 250.
    if ((app.steps <= 250) and (app.innerBlueIncreasing == True)):
        app.steps += 1

    # Then decreases steps to 0. Then increases again, and repeats.
    elif (app.steps >= 0):
        app.steps -= 1

        # Keeps track of if we are increasing or decreasing steps.
        app.innerBlueIncreasing = False
        if (app.steps == 0):
            app.innerBlueIncreasing = True

    # Set the following variables using app.steps to indicate the amount of blue
    # and green in the background.
    ### (HINT: The inner blue variable should be equal to the current
    #          app.steps and the outer green variable should be equal
    #          to 255 minus app.steps.)
    ### Fix Your Code Here ###
    # innerBlue =
    # outerGreen =

    # Use the local variables to define the proper colors below.
    ### Fix Your Code Here ###
    # innerColor = rgb(255, 0, 0)
    # outerColor = rgb(0, 0, 255)

    # Finally, set the background to a gradient using the inner and outer color
    # local variables.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 50
app.steps = 0
app.innerBlueIncreasing = True

background = Rect(0, 0, 400, 400)

def onStep():
    # Increases steps up to 250.
    if ((app.steps <= 250) and (app.innerBlueIncreasing == True)):
        app.steps += 1

    # Then decreases steps to 0. Then increases again, and repeats.
    elif (app.steps >= 0):
        app.steps -= 1

        # Keeps track of if we are increasing or decreasing steps.
        app.innerBlueIncreasing = False
        if (app.steps == 0):
            app.innerBlueIncreasing = True

    # Set the following variables using app.steps to indicate the amount of blue
    # and green in the background.
    innerBlue = app.steps
    outerGreen = 255 - app.steps

    # Use the local variables to define the proper colors below.
    innerColor = rgb(255, 0, innerBlue)
    outerColor = rgb(0, outerGreen, 255)

    # Finally, set the background to a gradient using the inner and outer color
    # local variables.
    background.fill = gradient(innerColor, outerColor)
",regular,1
2171,Colorful targets,7.2.2,"Rect(0, 0, 400, 400, fill='lavender')

def onMousePress(mouseX, mouseY):
    # Uncomment the local variables below so your code doesn't crash.
    ### Fix Your Code Here ###
    # color1 = rgb(mouseX // 2, mouseY // 2, 255)
    # color2 = rgb(255, mouseX // 2, mouseY // 2)
    # radius = 20

    # Change the variable names below for the code to work.
    ### Fix Your Code Here ###
    Circle(mouseX, mouseY, 4 * radius, fill=color)
    Circle(mouseX, mouseY, 3 * radius, fill=color)
    Circle(mouseX, mouseY, 2 * radius, fill=color)
    Circle(mouseX, mouseY, radius, fill=color)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Rect(0, 0, 400, 400, fill='lavender')

def onMousePress(mouseX, mouseY):
    color1 = rgb(mouseX // 2, mouseY // 2, 255)
    color2 = rgb(255, mouseX // 2, mouseY // 2)
    radius = 20

    Circle(mouseX, mouseY, 4 * radius, fill=color1)
    Circle(mouseX, mouseY, 3 * radius, fill=color2)
    Circle(mouseX, mouseY, 2 * radius, fill=color1)
    Circle(mouseX, mouseY, radius, fill=color2)
",regular,1
2172,Punching bag,7.2.2,"app.background = rgb(60, 30, 20)

Rect(0, 280, 400, 120, fill='peru')

# spring and glove
spring1 = Oval(0, 200, 40, 75, fill=None, border='grey')
spring2 = Oval(10, 200, 40, 75, fill=None, border='grey')
spring3 = Oval(20, 200, 40, 75, fill=None, border='grey')
spring4 = Oval(30, 200, 40, 75, fill=None, border='grey')
spring5 = Oval(40, 200, 40, 75, fill=None, border='grey')

glove = Group(
    Oval(80, 170, 42, 32, fill=gradient('red', 'crimson', start='right-top'),
         border='darkRed', rotateAngle=-30),
    Oval(80, 200, 85, 75, fill=gradient('red', 'crimson', start='right-bottom'),
         border='darkRed'),
    Oval(80, 170, 40, 30, fill=gradient('red', 'crimson', start='right-top'),
         rotateAngle=-30),
    Rect(50, 200, 30, 75, fill=gradient('red', 'crimson', start='right'),
         border='darkRed', align='center'),
    Line(100, 167, 85, 175, fill='darkRed')
    )

# punching bag
punchingBag = Group(
    Oval(325, 350, 100, 50, fill=gradient('red', 'crimson', start='left'),
         border='darkRed'),
    Rect(275, 100, 100, 250, fill=gradient('red', 'crimson', start='left')),
    Oval(325, 100, 100, 50, fill=gradient('red', 'crimson', start='left'),
         border='darkRed')
    )
cord = Line(325, 0, 325, 100, fill='white', lineWidth=4, dashes=True)

# comic-style hit symbol
hit = Star(275, 200, 40, 11, fill=gradient('yellow', 'orange'),
           border='darkRed', visible=False)

def onMouseMove(mouseX, mouseY):
    gapSize = mouseX / 5

    # Move each of the springs the same distance from each other.
    ### (HINT: All of the springs are related in a similar manner. A spring's
    #          centerX value is equal to the previous spring's centerX
    #          plus the gapSize.)
    ### Place Your Code Here ###

    glove.centerX = mouseX

    # If the glove's centerX value is too large, display the hit star and
    # update the position of it and the punching bag appropriately.
    ### Place Your Code Here ###

    # Otherwise, reset both the hit star and the punching bag.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(60, 30, 20)

Rect(0, 280, 400, 120, fill='peru')

# spring and glove
spring1 = Oval(0, 200, 40, 75, fill=None, border='grey')
spring2 = Oval(10, 200, 40, 75, fill=None, border='grey')
spring3 = Oval(20, 200, 40, 75, fill=None, border='grey')
spring4 = Oval(30, 200, 40, 75, fill=None, border='grey')
spring5 = Oval(40, 200, 40, 75, fill=None, border='grey')

glove = Group(
    Oval(80, 170, 42, 32, fill=gradient('red', 'crimson', start='right-top'),
         border='darkRed', rotateAngle=-30),
    Oval(80, 200, 85, 75, fill=gradient('red', 'crimson', start='right-bottom'),
         border='darkRed'),
    Oval(80, 170, 40, 30, fill=gradient('red', 'crimson', start='right-top'),
         rotateAngle=-30),
    Rect(50, 200, 30, 75, fill=gradient('red', 'crimson', start='right'),
         border='darkRed', align='center'),
    Line(100, 167, 85, 175, fill='darkRed')
    )

# punching bag
punchingBag = Group(
    Oval(325, 350, 100, 50, fill=gradient('red', 'crimson', start='left'),
         border='darkRed'),
    Rect(275, 100, 100, 250, fill=gradient('red', 'crimson', start='left')),
    Oval(325, 100, 100, 50, fill=gradient('red', 'crimson', start='left'),
         border='darkRed')
    )
cord = Line(325, 0, 325, 100, fill='white', lineWidth=4, dashes=True)

# comic-style hit symbol
hit = Star(275, 200, 40, 11, fill=gradient('yellow', 'orange'),
           border='darkRed', visible=False)

def onMouseMove(mouseX, mouseY):
    gapSize = mouseX / 5

    # Move each of the springs the same distance from each other.
    spring2.centerX = spring1.centerX + gapSize
    spring3.centerX = spring2.centerX + gapSize
    spring4.centerX = spring3.centerX + gapSize
    spring5.centerX = spring4.centerX + gapSize

    glove.centerX = mouseX

    # If the glove's centerX value is too large, display the hit star and
    # update the position of it and the punching bag appropriately.
    if (glove.centerX >= 230):
        punchingBag.left = glove.right
        hit.centerX = glove.right
        hit.visible = True

    # Otherwise, reset both the hit star and the punching bag.
    else:
        punchingBag.left = 275
        hit.visible = False


    cord.x2 = punchingBag.centerX
",regular,3
2174,Supernovas,7.3.2,"app.background = gradient('black', 'midnightBlue')

# background stars
Star(20, 50, 5, 8, fill='gold', roundness=40)
Star(280, 30, 5, 5, fill='white')
Star(170, 300, 5, 8, fill='white', roundness=40)
Star(340, 150, 5, 5, fill='gold')
Star(50, 350, 5, 8, fill='gold', roundness=40)
Star(250, 220, 5, 5, fill='white')
Star(380, 380, 5, 5, fill='gold')
Star(75, 100, 5, 8, fill='white', roundness=40)
Star(80, 210, 5, 8, fill='white', roundness=40)
Star(175, 80, 5, 8, fill='gold', roundness=40)
Star(80, 310, 5, 6, fill='gold', roundness=30)
Star(300, 330, 5, 9, fill='gold')

def drawNova1(x, y):
    # This draws 20 RegularPolygons and uses the looping variable to calculate new
    # properties for each polygon!
    for i in range(20):
        red = i * 10 + 40
        green = 255 - i * 10
        blue = 255 - i * 10
        starColor = rgb(red, green, blue)

        RegularPolygon(x, y, 50 - 2 * i, 6, fill=None, border=starColor,
                       borderWidth=10, rotateAngle=i*10, opacity=i*5)

    RegularPolygon(x, y, 12, 6, fill=rgb(230, 65, 65), border=rgb(230, 65, 65),
                   borderWidth=10, rotateAngle=190, opacity=95)

def drawNova2(x, y):
    # Fix the loop so that it draws the correct number of RegularPolygons.
    ### (HINT: What is the difference between the largest and smallest red
    #          value? You know that we decrease the red by 10 every time.
    #          How does that help?)
    ### Fix Your Code Here ###
    for i in range(1):
        red = 255 - i * 10
        green = 255 - i * 10
        blue = i * 10 + 40
        starColor = rgb(red, green, blue)

        RegularPolygon(x, y, 60 - 3 * i, 5, fill=None, border=starColor,
                       borderWidth=10, rotateAngle=i*(-15), opacity=i*7)

    # This covers the center of the nova.
    RegularPolygon(x, y, 18, 5, fill=rgb(115, 115, 180),
                   border=rgb(115, 115, 180), borderWidth=10, opacity=98,
                   rotateAngle=-211)

def drawNova3(x, y):
    # Fix the colors of this nova type.
    ### (HINT: Use the inspector and first look only at the red values in the
    #          rgb. How does it change? Then do the same for green and blue.)
    ### Fix Your Code Here ###
    for i in range(30):
        red = 255
        green = 255
        blue = 0
        starColor = rgb(red, green, blue)

        RegularPolygon(x, y, 40 - i, 5, fill=None, border=starColor,
                       borderWidth=10, rotateAngle=i*10, opacity=i*3)

def onMousePress(mouseX, mouseY):
    # Calls the appropriate function to create a supernova.
    if ((mouseX >= 200) and (mouseY <= 200)):
        drawNova2(mouseX, mouseY)
    elif ((mouseX < 200) and (mouseY > 200)):
        drawNova3(mouseX, mouseY)
    else:
        drawNova1(mouseX, mouseY)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('black', 'midnightBlue')

# background stars
Star(20, 50, 5, 8, fill='gold', roundness=40)
Star(280, 30, 5, 5, fill='white')
Star(170, 300, 5, 8, fill='white', roundness=40)
Star(340, 150, 5, 5, fill='gold')
Star(50, 350, 5, 8, fill='gold', roundness=40)
Star(250, 220, 5, 5, fill='white')
Star(380, 380, 5, 5, fill='gold')
Star(75, 100, 5, 8, fill='white', roundness=40)
Star(80, 210, 5, 8, fill='white', roundness=40)
Star(175, 80, 5, 8, fill='gold', roundness=40)
Star(80, 310, 5, 6, fill='gold', roundness=30)
Star(300, 330, 5, 9, fill='gold')

def drawNova1(x, y):
    # This draws 20 RegularPolygons and uses the looping variable to calculate new
    # properties for each polygon!
    for i in range(20):
        red = i * 10 + 40
        green = 255 - i * 10
        blue = 255 - i * 10
        starColor = rgb(red, green, blue)

        RegularPolygon(x, y, 50 - 2 * i, 6, fill=None, border=starColor,
                       borderWidth=10, rotateAngle=i*10, opacity=i*5)

    RegularPolygon(x, y, 12, 6, fill=rgb(230, 65, 65), border=rgb(230, 65, 65),
                   borderWidth=10, rotateAngle=190, opacity=95)

def drawNova2(x, y):
    # Fix the loop so that it draws the correct number of RegularPolygons.
    for i in range(15):
        red = 255 - i * 10
        green = 255 - i * 10
        blue = i * 10 + 40
        starColor = rgb(red, green, blue)

        RegularPolygon(x, y, 60 - 3 * i, 5, fill=None, border=starColor,
                       borderWidth=10, rotateAngle=i*(-15), opacity=i*7)

    # This covers the center of the nova.
    RegularPolygon(x, y, 18, 5, fill=rgb(115, 115, 180),
                   border=rgb(115, 115, 180), borderWidth=10, opacity=98,
                   rotateAngle=-211)

def drawNova3(x, y):
    # Fix the colors of this nova type.
    for i in range(30):
        red = 255 - i * 8
        green = 255 - i * 8
        blue = i * 8
        starColor = rgb(red, green, blue)

        RegularPolygon(x, y, 40 - i, 5, fill=None, border=starColor,
                       borderWidth=10, rotateAngle=i*10, opacity=i*3)

def onMousePress(mouseX, mouseY):
    # Calls the appropriate function to create a supernova.
    if ((mouseX >= 200) and (mouseY <= 200)):
        drawNova2(mouseX, mouseY)
    elif ((mouseX < 200) and (mouseY > 200)):
        drawNova3(mouseX, mouseY)
    else:
        drawNova1(mouseX, mouseY)
",regular,1
2175,The green duck,7.3.2,"app.background = 'paleTurquoise'

# title and instructions
Label('The Green Duck', 10, 10, size=30, align='left-top')
Label('Up and down change duck count', 20, 45, align='left-top')
Label('Left and right move green duck', 20, 65, align='left-top')

# water and sun
Rect(0, 200, 400, 200, fill='dodgerBlue')
Circle(350, 50, 50, fill='gold')

ducks = Group()
ducks.greenDuckPosition = 0
ducks.count = 5
ducks.maxCount = 20

def drawDuck(position, color):
    # First draws full-size duck near (0,0).
    duck = Group(
        Oval(10, 8, 20, 8, fill='orange'),
        Circle(30, 8, 20, fill=color),
        Oval(50, 33, 60, 50, fill=color),
        Circle(25, 3, 2)
        )

    # Now moves and resizes the duck as needed.
    scale = (400 / ducks.count) / duck.width
    duck.width *= scale
    duck.height *= scale
    duck.centerX = (position + 0.5) * duck.width
    duck.bottom = 210
    ducks.add(duck)

def drawDucks():
    # Call drawDuck to draw the appropriate number of ducks.
    # All of the ducks are yellow except the one at green duck position.
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    # Add or remove ducks when arrow keys are pressed.
    if ((key == 'up') and (ducks.count < ducks.maxCount)):
        ducks.count += 1
    elif (key == 'down'):
        if (ducks.count > 3):
            ducks.count -= 1

    # Move the green duck when key pressed.
    elif (key == 'right'):
        ducks.greenDuckPosition += 1
    elif (key == 'left'):
        ducks.greenDuckPosition -= 1

    # Adjust green duck position if needed.
    if (ducks.greenDuckPosition < 0):
        ducks.greenDuckPosition = ducks.count - 1
    elif (ducks.greenDuckPosition >= ducks.count):
        ducks.greenDuckPosition = 0

    # Remove old ducks and draw new ones.
    ducks.clear()
    drawDucks()

drawDucks()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'paleTurquoise'

# title and instructions
Label('The Green Duck', 10, 10, size=30, align='left-top')
Label('Up and down change duck count', 20, 45, align='left-top')
Label('Left and right move green duck', 20, 65, align='left-top')

# water and sun
Rect(0, 200, 400, 200, fill='dodgerBlue')
Circle(350, 50, 50, fill='gold')

ducks = Group()
ducks.greenDuckPosition = 0
ducks.count = 5
ducks.maxCount = 20

def drawDuck(position, color):
    # First draws full-size duck near (0,0).
    duck = Group(
        Oval(10, 8, 20, 8, fill='orange'),
        Circle(30, 8, 20, fill=color),
        Oval(50, 33, 60, 50, fill=color),
        Circle(25, 3, 2)
        )

    # Now moves and resizes the duck as needed.
    scale = (400 / ducks.count) / duck.width
    duck.width *= scale
    duck.height *= scale
    duck.centerX = (position + 0.5) * duck.width
    duck.bottom = 210
    ducks.add(duck)

def drawDucks():
    # Call drawDuck to draw the appropriate number of ducks.
    # All of the ducks are yellow except the one at green duck position.
    for i in range(ducks.count):
        if (i == ducks.greenDuckPosition):
            drawDuck(i, 'lime')
        else:
            drawDuck(i, 'yellow')

def onKeyPress(key):
    # Add or remove ducks whe key pressed.
    if ((key == 'up') and (ducks.count < ducks.maxCount)):
        ducks.count += 1
    elif (key == 'down'):
        if (ducks.count > 3):
            ducks.count -= 1

    # Move the green duck when key pressed.
    elif (key == 'right'):
        ducks.greenDuckPosition += 1
    elif (key == 'left'):
        ducks.greenDuckPosition -= 1

    # Adjust green duck position if needed.
    if (ducks.greenDuckPosition < 0):
        ducks.greenDuckPosition = ducks.count - 1
    elif (ducks.greenDuckPosition >= ducks.count):
        ducks.greenDuckPosition = 0

    # Remove old ducks and draw new ones.
    ducks.clear()
    drawDucks()

drawDucks()
",regular,2
2173,Puffy magician,7.3.2,"app.background = 'black'

# seating
Rect(0, 150, 400, 120, fill='saddleBrown', opacity=80)
Line(200, 148, 200, 230, fill='sienna', lineWidth=400, opacity=80, dashes=(3, 37))

# stage
Oval(425, 100, 125, 450, fill='crimson', rotateAngle=-30)
Rect(0, 270, 400, 130, fill=rgb(60, 60, 60))
Line(240, 295, 240, 400, fill='chocolate', lineWidth=10)
Polygon(0, 280, 250, 280, 235, 400, 0, 400, fill='peru')

def drawAudience():
    # The code that actually draws all of these shapes is correct. But the positions
    # are all wrong, and only 3 people are drawn! Use a loop to draw the bottom
    # and top row of the audience and another loop to draw the middle row.
    ### Fix Your Code Here ###
    cx = 200

    # top row
    head1 = Circle(cx, 150, 10, fill='peachPuff')
    Arc(cx, 188, 40, 55, 270, 180, fill='mediumPurple', opacity=90)

    # bottom row
    head2 = Circle(cx, 222, 14, fill='peachPuff')
    Arc(cx, 270, 50, 65, 270, 180, fill='mediumSeaGreen', opacity=90)

    headsMovingLeft.add(head1, head2)

    # middle row
    head = Circle(cx, 185, 12, fill='peachPuff')
    Arc(cx, 228, 45, 60, 270, 180, fill='tomato', opacity=90)

    headsMovingRight.add(head)

headsMovingLeft = Group()
headsMovingRight = Group()
drawAudience()

puffy = Group(
    # feet
    Oval(84, 340, 6, 16, fill='orange', rotateAngle=50),
    Oval(85, 340, 6, 16, fill='orange', rotateAngle=20),
    Oval(86, 341, 6, 16, fill='orange', rotateAngle=-10),
    Oval(126, 340, 6, 16, fill='orange', rotateAngle=-50),
    Oval(125, 340, 6, 16, fill='orange', rotateAngle=-20),
    Oval(124, 341, 6, 16, fill='orange', rotateAngle=10),

    # wings
    Oval(75, 294, 21, 40, rotateAngle=-40),
    Oval(75, 297, 12, 36, fill='white', rotateAngle=-40),
    Oval(135, 294, 21, 40, rotateAngle=40),
    Oval(135, 297, 12, 36, fill='white', rotateAngle=40),
    Oval(105, 295, 50, 75),

    # belly
    Circle(105, 320, 25, fill='white', border='black', borderWidth=4),

    # body
    Oval(97, 297, 21, 60, fill='white'),
    Oval(113, 297, 21, 60, fill='white'),
    Circle(97, 280, 3),
    Circle(113, 280, 3),
    Polygon(100, 287, 107, 294, 110, 287, fill='orange')
    )

hat = Group(
    Rect(20, 255, 170, 20, fill=rgb(30, 30, 30), border='dimGray'),
    Rect(60, 275, 90, 80, fill=rgb(30, 30, 30), border='dimGray'),
    Rect(62, 275, 86, 10, fill='snow')
    )

wand = Group(
    Rect(200, 200, 50, 6, rotateAngle=45, opacity=80),
    Rect(202, 180, 6, 6, fill='orangeRed', rotateAngle=45, opacity=80)
    )

def onMousePress(mouseX, mouseY):
    if ((hat.hits(mouseX, mouseY) == True) and (puffy.centerX < 200)):
        if (puffy.centerY >= 220):
            puffy.centerY -= 20
            headsMovingLeft.centerX -= 1
            headsMovingRight.centerX += 2

    elif ((puffy.hits(mouseX, mouseY) == True) and (puffy.centerY <= 220)):
        puffy.centerX = 310
        puffy.centerY = 340

def onMouseMove(mouseX, mouseY):
    wand.centerX = mouseX
    wand.centerY = mouseY
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# seating
Rect(0, 150, 400, 120, fill='saddleBrown', opacity=80)
Line(200, 148, 200, 230, fill='sienna', lineWidth=400, opacity=80, dashes=(3, 37))

# stage
Oval(425, 100, 125, 450, fill='crimson', rotateAngle=-30)
Rect(0, 270, 400, 130, fill=rgb(60, 60, 60))
Line(240, 295, 240, 400, fill='chocolate', lineWidth=10)
Polygon(0, 280, 250, 280, 235, 400, 0, 400, fill='peru')

def drawAudience():
    # The code that actually draws all of these shapes is correct. But the positions
    # are all wrong, and only 3 people are drawn! Use a loop to draw the bottom
    # and top row of the audience and another loop to draw the middle row.
    for i in range(5):
        cx = 30 + i * 80

        # top row
        head1 = Circle(cx, 150, 10, fill='peachPuff')
        Arc(cx, 188, 40, 55, 270, 180, fill='mediumPurple', opacity=90)

        # bottom row
        head2 = Circle(cx, 222, 14, fill='peachPuff')
        Arc(cx, 270, 50, 65, 270, 180, fill='mediumSeaGreen', opacity=90)

        headsMovingLeft.add(head1, head2)

    for i in range(4):
        cx = 68 + i * 80

        # middle row
        head = Circle(cx, 185, 12, fill='peachPuff')
        Arc(cx, 228, 45, 60, 270, 180, fill='tomato', opacity=90)

        headsMovingRight.add(head)

headsMovingLeft = Group()
headsMovingRight = Group()
drawAudience()

puffy = Group(
    # feet
    Oval(84, 340, 6, 16, fill='orange', rotateAngle=50),
    Oval(85, 340, 6, 16, fill='orange', rotateAngle=20),
    Oval(86, 341, 6, 16, fill='orange', rotateAngle=-10),
    Oval(126, 340, 6, 16, fill='orange', rotateAngle=-50),
    Oval(125, 340, 6, 16, fill='orange', rotateAngle=-20),
    Oval(124, 341, 6, 16, fill='orange', rotateAngle=10),

    # wings
    Oval(75, 294, 21, 40, rotateAngle=-40),
    Oval(75, 297, 12, 36, fill='white', rotateAngle=-40),
    Oval(135, 294, 21, 40, rotateAngle=40),
    Oval(135, 297, 12, 36, fill='white', rotateAngle=40),
    Oval(105, 295, 50, 75),

    # belly
    Circle(105, 320, 25, fill='white', border='black', borderWidth=4),

    # body
    Oval(97, 297, 21, 60, fill='white'),
    Oval(113, 297, 21, 60, fill='white'),
    Circle(97, 280, 3),
    Circle(113, 280, 3),
    Polygon(100, 287, 107, 294, 110, 287, fill='orange')
    )

hat = Group(
    Rect(20, 255, 170, 20, fill=rgb(30, 30, 30), border='dimGray'),
    Rect(60, 275, 90, 80, fill=rgb(30, 30, 30), border='dimGray'),
    Rect(62, 275, 86, 10, fill='snow')
    )

wand = Group(
    Rect(200, 200, 50, 6, rotateAngle=45, opacity=80),
    Rect(202, 180, 6, 6, fill='orangeRed', rotateAngle=45, opacity=80)
    )

def onMousePress(mouseX, mouseY):
    if ((hat.hits(mouseX, mouseY) == True) and (puffy.centerX < 200)):
        if (puffy.centerY >= 220):
            puffy.centerY -= 20
            headsMovingLeft.centerX -= 1
            headsMovingRight.centerX += 2

    elif ((puffy.hits(mouseX, mouseY) == True) and (puffy.centerY <= 220)):
        puffy.centerX = 310
        puffy.centerY = 340

def onMouseMove(mouseX, mouseY):
    wand.centerX = mouseX
    wand.centerY = mouseY
",regular,1
2176,Highway,7.3.2,"# background and mountains
Rect(0, 0, 400, 120,
     fill=gradient('mediumPurple', 'lightSteelBlue', 'thistle', start='top'))
Polygon(0, 400, 0, 90, 64, 93, 107, 90, 182, 83, 252, 84, 317, 93, 367, 81,
        400, 80, 400, 400, fill='whiteSmoke')
Polygon(0, 400, 0, 105, 55, 100, 100, 115, 170, 113, 220, 100, 300, 105, 360,
        110, 400, 105, 400, 400, fill='snow')
Polygon(0, 400, 0, 120, 145, 115, 200, 120, 273, 118, 400, 120, 400, 400,
        fill=gradient('whiteSmoke', 'gainsboro'))
Polygon(20, 400, 200, 120, 380, 400, fill='gray')

# stars
Line(0, 20, 400, 20, fill='white', dashes=(1, 30))
Line(10, 40, 400, 40, fill='white', dashes=(1, 40))
Line(5, 60, 400, 60, fill='white', dashes=(1, 30))
Line(0, 80, 400, 80, fill='white', dashes=(1, 40))

def drawRoad():
    # These variables are used to draw the dashes on the highway.
    thickness = 10
    length = 20
    y = 400
    lineGap = 50

    # Draw 10 dashes in the middle of the road using lines of different
    # thickness and length. After drawing each line, decrease y by the lineGap,
    # thickness by 1, length by 2 and the lineGap itself by 5.
    ### (HINT: Each line should start at a y coordinate of y and end at
    #          a y coordinate of (y-length).)
    ### Place Your Code Here ###

def drawLamp(x, bottom, width, facing):
    # Draws a lamp with the given parameters.
    lamp = Group(
        Line(200, 300, 200, 200, fill='dimGray', lineWidth=3)
        )

    if (facing == 'right'):
        lamp.add(
            Line(200, 215, 210, 200, fill='dimGray', lineWidth=3),
            Line(210, 200, 220, 200, fill='dimGray', lineWidth=3),
            Circle(220, 205, 5, fill='dimGray'),
            Polygon(220, 205, 205, 300, 235, 300,
                    fill=gradient('orange', 'yellow', start='top'), opacity=30),
            Oval(220, 300, 30, 10, fill='yellow', opacity=30)
            )
    elif (facing == 'left'):
        lamp.add(
            Line(200, 215, 190, 200, fill='dimGray', lineWidth=3),
            Line(190, 200, 180, 200, fill='dimGray', lineWidth=3),
            Circle(180, 205, 5, fill='dimGray'),
            Polygon(180, 205, 165, 300, 195, 300,
                    fill=gradient('orange', 'yellow', start='top'), opacity=30),
            Oval(180, 300, 30, 10, fill='yellow', opacity=30)
            )

    lamp.width = width
    lamp.height = 3 * width
    lamp.centerX = x
    lamp.bottom = bottom

def drawLamps():
    # These variables are used to draw the lamps on the highway.
    rightX = 215
    leftX = 185
    xGap = 35
    y = 150
    yGap = 60
    width = 10

    # Draw 5 lamps on either side of the road using the provided variables and
    # helper function. On each pass through the loop, change the rightX and
    # leftX by the xGap, y by the yGap and width by 5.
    ### (HINT: Lamps on the left side of the road should be facing right,
    #          and lamps on the right should be facing left.)
    ### (HINT: Don't use two separate loops for the lamps on the left and
    #          the lamps on the right. It's easier to draw them both in one!)
    ### Place Your Code Here ###

drawRoad()

# overlay
Rect(0, 0, 400, 400, fill=rgb(10, 5, 30), opacity=20)

drawLamps()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background and mountains
Rect(0, 0, 400, 120,
     fill=gradient('mediumPurple', 'lightSteelBlue', 'thistle', start='top'))
Polygon(0, 400, 0, 90, 64, 93, 107, 90, 182, 83, 252, 84, 317, 93, 367, 81,
        400, 80, 400, 400, fill='whiteSmoke')
Polygon(0, 400, 0, 105, 55, 100, 100, 115, 170, 113, 220, 100, 300, 105, 360,
        110, 400, 105, 400, 400, fill='snow')
Polygon(0, 400, 0, 120, 145, 115, 200, 120, 273, 118, 400, 120, 400, 400,
        fill=gradient('whiteSmoke', 'gainsboro'))
Polygon(20, 400, 200, 120, 380, 400, fill='gray')

# stars
Line(0, 20, 400, 20, fill='white', dashes=(1, 30))
Line(10, 40, 400, 40, fill='white', dashes=(1, 40))
Line(5, 60, 400, 60, fill='white', dashes=(1, 30))
Line(0, 80, 400, 80, fill='white', dashes=(1, 40))

def drawRoad():
    # These variables are used to draw the dashes on the highway.
    thickness = 10
    length = 20
    y = 400
    lineGap = 50

    # Draw 10 dashes in the middle of the road using lines of different
    # thickness and length. After drawing each line, decrease y by the lineGap,
    # thickness by 1, length by 2 and the lineGap itself by 5.
    for i in range(10):
        Line(200, y, 200, y - length, fill='lightGray', lineWidth=thickness)
        y -= lineGap
        thickness -= 1
        length -= 2
        lineGap -= 5

def drawLamp(x, bottom, width, facing):
    # Draws a lamp with the given parameters.
    lamp = Group(
        Line(200, 300, 200, 200, fill='dimGray', lineWidth=3)
        )

    if (facing == 'right'):
        lamp.add(
            Line(200, 215, 210, 200, fill='dimGray', lineWidth=3),
            Line(210, 200, 220, 200, fill='dimGray', lineWidth=3),
            Circle(220, 205, 5, fill='dimGray'),
            Polygon(220, 205, 205, 300, 235, 300,
                    fill=gradient('orange', 'yellow', start='top'), opacity=30),
            Oval(220, 300, 30, 10, fill='yellow', opacity=30)
            )
    elif (facing == 'left'):
        lamp.add(
            Line(200, 215, 190, 200, fill='dimGray', lineWidth=3),
            Line(190, 200, 180, 200, fill='dimGray', lineWidth=3),
            Circle(180, 205, 5, fill='dimGray'),
            Polygon(180, 205, 165, 300, 195, 300,
                    fill=gradient('orange', 'yellow', start='top'), opacity=30),
            Oval(180, 300, 30, 10, fill='yellow', opacity=30)
            )

    lamp.width = width
    lamp.height = 3 * width
    lamp.centerX = x
    lamp.bottom = bottom

def drawLamps():
    # These variables are used to draw the lamps on the highway.
    rightX = 215
    leftX = 185
    xGap = 35
    y = 150
    yGap = 60
    width = 10

    # Draw 5 lamps on either side of the road using the provided variables and
    # helper function. On each pass through the loop, change the rightX and
    # leftX by the xGap, y by the yGap and width by 5.
    for i in range(5):
        drawLamp(leftX, y, width, 'right')
        drawLamp(rightX, y, width, 'left')
        width += 5
        rightX += xGap
        leftX -= xGap
        y += yGap

drawRoad()

# overlay
Rect(0, 0, 400, 400, fill=rgb(10, 5, 30), opacity=20)

drawLamps()
",regular,2
2177,Indoor rainy day,7.3.2,"app.background = 'darkGrey'
app.stepsPerSecond = 20

bigRain = Group()
smallRain = Group()

cloud1 = Group()
cloud2 = Group()
cloud3 = Group()

def drawClouds():
    # Fill in the range for each of the for loops to draw the circles that make up
    # the clouds.
    ### Fix Your Code Here ###
    for i in range(0):
        cloud1.add(
            Circle(i * 60 + 60, 60, 55, fill='white', border='gainsboro')
            )
    cloud1.add(Oval(150, 60, 360, 80, fill='white'))

    for i in range(0):
        cloud2.add(
            Circle(i * 40 + 390, 50, 45, fill='snow', border='gainsboro')
            )
    cloud2.add(Oval(430, 50, 150, 70, fill='snow'))

    for i in range(0):
        cloud3.add(
            Circle(i * 60 + 590, 60, 65, fill='whiteSmoke', border='gainsboro')
            )
    cloud3.add(Oval(710, 60, 340, 90, fill='whiteSmoke'))

drawClouds()

# window
Rect(0, 0, 400, 400, fill=None, border='moccasin', borderWidth=30)
Rect(30, 30, 340, 340, fill=None, border='saddleBrown', borderWidth=20)
Line(200, 40, 200, 360, fill='saddleBrown', lineWidth=5)
Line(40, 200, 360, 200, fill='saddleBrown', lineWidth=5)
Rect(35, 35, 330, 330, fill=None, border='maroon', borderWidth=4)
Line(15, 375, 385, 375, fill='burlyWood', lineWidth=12)
Line(20, 385, 380, 385, fill='tan', lineWidth=8)

def drawRain():
    # Draw a single horizontal row of rain drops. Each drop of rain contains a
    # big rain drop, and a small rain drop that has lower opacity and lineWidth.
    for i in range(0):
        ### (HINT: Use the inspector and count the drops horizontally to
        #          determine the range of the loop. The y-position of each
        #          drop starts at 100 for the big drops and at 70 for the
        #          smaller drops. The x-position depends on i.)
        ### (HINT: We've already defined some groups for you at the top of
        #          the code.)
        ### Place Your Code Here ###
        pass

def onStep():
    drawRain()

    # Moves the rain groups and clears all rain if it gets to the bottom.
    bigRain.centerY += 20
    smallRain.centerY += 20
    if (bigRain.bottom > 400):
        bigRain.clear()
    if (smallRain.bottom > 400):
        smallRain.clear()

    # Moves the clouds so that they wraparound.
    cloud1.centerX -= 2
    cloud2.centerX -= 2
    cloud3.centerX -= 2
    if (cloud1.centerX <= -230):
        cloud1.centerX = 630
    if (cloud2.centerX <= -230):
        cloud2.centerX = 630
    if (cloud3.centerX <= -230):
        cloud3.centerX = 630
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'darkGrey'
app.stepsPerSecond = 20

bigRain = Group()
smallRain = Group()

cloud1 = Group()
cloud2 = Group()
cloud3 = Group()

def drawClouds():
    # Fill in the range for each of the for loops to draw the circles that make up
    # the clouds.
    for i in range(6):
        cloud1.add(
            Circle(i * 60 + 60, 60, 55, fill='white', border='gainsboro')
            )
    cloud1.add(Oval(150, 60, 360, 80, fill='white'))

    for i in range(4):
        cloud2.add(
            Circle(i * 40 + 390, 50, 45, fill='snow', border='gainsboro')
            )
    cloud2.add(Oval(430, 50, 150, 70, fill='snow'))

    for i in range(5):
        cloud3.add(
            Circle(i * 60 + 590, 60, 65, fill='whiteSmoke', border='gainsboro')
            )
    cloud3.add(Oval(710, 60, 340, 90, fill='whiteSmoke'))

drawClouds()

# window
Rect(0, 0, 400, 400, fill=None, border='moccasin', borderWidth=30)
Rect(30, 30, 340, 340, fill=None, border='saddleBrown', borderWidth=20)
Line(200, 40, 200, 360, fill='saddleBrown', lineWidth=5)
Line(40, 200, 360, 200, fill='saddleBrown', lineWidth=5)
Rect(35, 35, 330, 330, fill=None, border='maroon', borderWidth=4)
Line(15, 375, 385, 375, fill='burlyWood', lineWidth=12)
Line(20, 385, 380, 385, fill='tan', lineWidth=8)

def drawRain():
    # Draw a single horizontal row of rain drops. Each drop of rain contains a
    # big rain drop, and a small rain drop that has lower opacity and lineWidth.
    for i in range(12):
        x1 = i * 25 + 55
        x2 = x1 + 1

        bigRain.add(
            Line(x1, 100, x1 + 10, 80, fill='lightBlue')
            )
        smallRain.add(
            Line(x2, 70, x2 + 10, 50, fill='lightBlue', lineWidth=1, opacity=75)
            )

def onStep():
    drawRain()

    # Moves the rain groups and clears all rain if it gets to the bottom.
    bigRain.centerY += 20
    smallRain.centerY += 20
    if (bigRain.bottom > 400):
        bigRain.clear()
    if (smallRain.bottom > 400):
        smallRain.clear()

    # Moves the clouds so that they wraparound.
    cloud1.centerX -= 2
    cloud2.centerX -= 2
    cloud3.centerX -= 2
    if (cloud1.centerX <= -230):
        cloud1.centerX = 630
    if (cloud2.centerX <= -230):
        cloud2.centerX = 630
    if (cloud3.centerX <= -230):
        cloud3.centerX = 630
",regular,3
2182,Dancing stick people,7.3.4,"app.background = gradient('lightBlue', 'royalBlue')

sticks = Group()
sticks.toBack()

sticks.rightArmsUp = False
sticks.leftArmsUp = False

def drawStick(headX, headY):
    stick = Group()
    stick.leftArm = Line(headX, headY + 25, headX - 15, headY + 35)
    stick.rightArm = Line(headX, headY + 25, headX + 15, headY + 35)
    stick.add(
        # head
        Circle(headX, headY, 15),

        stick.leftArm,
        stick.rightArm,

        # body
        Line(headX, headY, headX, headY + 50),

        # legs
        Line(headX, headY + 50, headX - 10, headY + 75),
        Line(headX, headY + 50, headX + 10, headY + 75)
        )

    # The stick figure was created with its arms down, so we have to raise
    # them now if needed.
    if (sticks.rightArmsUp == True):
        stick.rightArm.y2 -= 20
    if (sticks.leftArmsUp == True):
        stick.leftArm.y2 -= 20
    sticks.add(stick)

def onMousePress(mouseX, mouseY):
    drawStick(mouseX, mouseY)

def toggleLeftArms():
    # Depending on if the left arm is up or down, changes the dy value.
    if (sticks.leftArmsUp == True):
        dy = 20
        sticks.leftArmsUp = False
    else:
        dy = -20
        sticks.leftArmsUp = True

    # For each stickman, moves the left arm by dy.
    for stick in sticks.children:
        stick.leftArm.y2 += dy

def toggleRightArms():
    # If the right arm is up, set dy to 20 and rightArmsUp to False.
    # Otherwise, set dy to -20 and rightArmsUp to True.
    ### Place Your Code Here ###

    # For each stickman, move the right arm by dy.
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    if (key == 'left'):
        toggleLeftArms()
    elif (key == 'right'):
        toggleRightArms()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightBlue', 'royalBlue')

sticks = Group()
sticks.toBack()

sticks.rightArmsUp = False
sticks.leftArmsUp = False

def drawStick(headX, headY):
    stick = Group()
    stick.leftArm = Line(headX, headY + 25, headX - 15, headY + 35)
    stick.rightArm = Line(headX, headY + 25, headX + 15, headY + 35)
    stick.add(
        # head
        Circle(headX, headY, 15),

        stick.leftArm,
        stick.rightArm,

        # body
        Line(headX, headY, headX, headY + 50),

        # legs
        Line(headX, headY + 50, headX - 10, headY + 75),
        Line(headX, headY + 50, headX + 10, headY + 75)
        )

    # The stick was created with its arms down, so we have to raise
    # them now if needed.
    if (sticks.rightArmsUp == True):
        stick.rightArm.y2 -= 20
    if (sticks.leftArmsUp == True):
        stick.leftArm.y2 -= 20
    sticks.add(stick)

def onMousePress(mouseX, mouseY):
    drawStick(mouseX, mouseY)

def toggleLeftArms():
    # Depending on if the left arm is up or down, changes the dy value.
    if (sticks.leftArmsUp == True):
        dy = 20
        sticks.leftArmsUp = False
    else:
        dy = -20
        sticks.leftArmsUp = True

    # For each stickman, moves the left arm by dy.
    for stick in sticks.children:
        stick.leftArm.y2 += dy

def toggleRightArms():
    # If the right arm is up, set dy to 20 and rightArmsUp to False.
    # Otherwise, set dy to -20 and rightArmsUp to True.
    if (sticks.rightArmsUp == True):
        dy = 20
        sticks.rightArmsUp = False
    else:
        dy = -20
        sticks.rightArmsUp = True

    # For each stickman, move the right arm by dy.
    for stick in sticks.children:
        stick.rightArm.y2 += dy

def onKeyPress(key):
    if (key == 'left'):
        toggleLeftArms()
    elif (key == 'right'):
        toggleRightArms()
",regular,1
2179,Patterned circles,7.3.4,"app.background = 'black'

waves = Group()
waves.maxSize = 300
waves.minSize = 10
waves.stepSize = 10

def makePattern():
    for i in range(25):
        # Color 1 should have a blue rgb value of i * 10,
        # color 2 should have a red rgb value of i * 10, and all other
        # parts of the rgbs should be 0.
        ### Fix Your Code Here ###
        color1 = rgb(255, 0, 0)
        color2 = rgb(0, 0, 255)

        # Add a new circle to the pattern group.
        waves.add(
            Circle(200, 200, (i + 1) * 10, fill=None,
                   border=gradient(color1, color2, start='top'), borderWidth=12)
            )

makePattern()

def onStep():
    # For each wave when the current circle is bigger than or equal to
    # the maximum size, reset the radius to the minimum size.
    # Otherwise, increase the radius by the stepSize.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

waves = Group()
waves.maxSize = 300
waves.minSize = 10
waves.stepSize = 10

def makePattern():
    for i in range(25):
        # Color 1 should have a blue rgb value of i * 10,
        # color 2 should have a red rgb value of i * 10, and all other
        # parts of the rgbs should be 0.
        color1 = rgb(0, 0, i * 10)
        color2 = rgb(i * 10, 0, 0)

        # Add a new circle to the pattern group.
        waves.add(
            Circle(200, 200, (i + 1) * 10, fill=None,
                   border=gradient(color1, color2, start='top'), borderWidth=12)
            )

makePattern()

def onStep():
    # For each wave when the current circle is bigger than or equal to
    # the maximum size, reset the radius to the minimum size.
    # Otherwise, increase the radius by the stepSize.
    for wave in waves.children:
        if (wave.radius >= waves.maxSize):
            wave.radius = waves.minSize
        else:
            wave.radius += waves.stepSize
",regular,2
2180,Growing stars,7.3.4,"app.background = 'black'
app.stepsPerSecond = 30

app.counter = 0

stars = Group()
stars.nextFill = 'orange'

def onStep():
    app.counter += 1

    # Adds a star every 10 steps.
    if (app.counter == 10):
        # Resets the counter and change the fill color.
        app.counter = 0
        if (stars.nextFill == 'orange'):
            stars.nextFill = 'yellow'
        else:
            stars.nextFill = 'orange'

        # Adds a new star to the stars group.
        stars.add(
            Star(200, 200, 10, 5, fill=stars.nextFill)
            )

    # Increase each star's radius by 5 until it is larger than 700, at which
    # point remove the star from the group.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 30

app.counter = 0

stars = Group()
stars.nextFill = 'orange'

def onStep():
    app.counter += 1

    # Adds a star every 10 steps.
    if (app.counter == 10):
        # Resets the counter and change the fill color.
        app.counter = 0
        if (stars.nextFill == 'orange'):
            stars.nextFill = 'yellow'
        else:
            stars.nextFill = 'orange'

        # Adds a new star to the stars group.
        stars.add(
            Star(200, 200, 10, 5, fill=stars.nextFill)
            )

    # Increase each star's radius by 5 until it is larger than 700, at which
    # point remove the star from the group.
    for eachStar in stars.children:
        eachStar.radius += 5
        if (eachStar.radius > 700):
            stars.remove(eachStar)
",regular,1
2181,Animated pokey,7.3.4,"app.background = gradient('skyBlue', 'orange', start='top')

app.stepsPerSecond = 10
app.steps = 0

# background
Rect(0, 275, 400, 125, fill='gold')
Polygon(140, 275, 240, 155, 290, 175, 330, 120, 465, 275, fill=rgb(235, 185, 0))
Polygon(0, 275, 60, 185, 100, 240, 135, 220, 190, 275, fill=rgb(255, 235, 60))

pokeys = Group()
pokeys.bodyPieceDx = 2
pokeyEyes = Group()
pokeyEyes.dy = 1

def drawPokeyFace(x, y):
    pokeyColor = gradient('gold', 'orange', start='left-top')
    head = Group(
        # head spikes
        RegularPolygon(x - 20, y - 15, 18, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=-45),
        RegularPolygon(x, y - 25, 18, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1),
        RegularPolygon(x + 20, y - 15, 18, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=45),

        # head and eyes
        Circle(x, y, 30, fill=pokeyColor, border='black', borderWidth=1),
        Oval(x - 10, y - 5, 15, 18),
        Oval(x + 10, y - 5, 15, 18),

        # mouth
        Oval(x, y + 15, 30, 15),
        Oval(x, y + 10, 30, 10, fill=pokeyColor)
        )

    # eyes
    eye1 = Circle(x - 7, y - 7, 3, fill='white')
    eye2 = Circle(x + 7, y - 2, 3, fill='white')
    pokeyEyes.add(eye1, eye2)

    head.add(pokeyEyes)
    pokeys.add(head)

def drawPokeyBodyPiece(x, y):
    pokeyColor = gradient('gold', 'orange', start='left-top')
    bodyPiece = Group(
        # whiskers
        Line(x - 25, y + 25, x + 25, y - 25),
        Line(x - 25, y - 25, x + 25, y + 25),

        # spikes and body
        RegularPolygon(x - 30, y - 5, 12, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=35),
        RegularPolygon(x + 30, y + 5, 15, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=-25),

        # body
        Circle(x, y, 30, fill=pokeyColor, border='black', borderWidth=1)
        )

    pokeys.add(bodyPiece)

def onStep():
    # Every 5 steps, switches the direction of the eyes and body pieces.
    if (app.steps == 5):
        pokeys.bodyPieceDx *= -1
        pokeyEyes.dy *= -1
        app.steps = 0

    # Sway each body piece side to side, alternating the direction of the
    # movement.
    ### (HINT: Use a local variable to track the current dx and change its
    #          sign on every pass of the loop.)
    ### Place Your Code Here ###

    # Move the eyes up and down, alternating the direction each eye moves.
    ### (HINT: Use a local variable to track the current dy and change its
    #          sign on every pass of the loop.)
    ### Place Your Code Here ###

    app.steps += 1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('skyBlue', 'orange', start='top')

app.stepsPerSecond = 10
app.steps = 0

# background
Rect(0, 275, 400, 125, fill='gold')
Polygon(140, 275, 240, 155, 290, 175, 330, 120, 465, 275, fill=rgb(235, 185, 0))
Polygon(0, 275, 60, 185, 100, 240, 135, 220, 190, 275, fill=rgb(255, 235, 60))

pokeys = Group()
pokeys.bodyPieceDx = 2
pokeyEyes = Group()
pokeyEyes.dy = 1

def drawPokeyFace(x, y):
    pokeyColor = gradient('gold', 'orange', start='left-top')
    head = Group(
        # head spikes
        RegularPolygon(x - 20, y - 15, 18, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=-45),
        RegularPolygon(x, y - 25, 18, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1),
        RegularPolygon(x + 20, y - 15, 18, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=45),

        # head and eyes
        Circle(x, y, 30, fill=pokeyColor, border='black', borderWidth=1),
        Oval(x - 10, y - 5, 15, 18),
        Oval(x + 10, y - 5, 15, 18),

        # mouth
        Oval(x, y + 15, 30, 15),
        Oval(x, y + 10, 30, 10, fill=pokeyColor)
        )

    # eyes
    eye1 = Circle(x - 7, y - 7, 3, fill='white')
    eye2 = Circle(x + 7, y - 2, 3, fill='white')
    pokeyEyes.add(eye1, eye2)

    head.add(pokeyEyes)
    pokeys.add(head)

def drawPokeyBodyPiece(x, y):
    pokeyColor = gradient('gold', 'orange', start='left-top')
    bodyPiece = Group(
        # whiskers
        Line(x - 25, y + 25, x + 25, y - 25),
        Line(x - 25, y - 25, x + 25, y + 25),

        # spikes and body
        RegularPolygon(x - 30, y - 5, 12, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=35),
        RegularPolygon(x + 30, y + 5, 15, 3, fill=pokeyColor,
                       border='gainsboro', borderWidth=1, rotateAngle=-25),

        # body
        Circle(x, y, 30, fill=pokeyColor, border='black', borderWidth=1)
        )

    pokeys.add(bodyPiece)

def onStep():
    # Every 5 steps, switches the direction of the eyes and body pieces.
    if (app.steps == 5):
        pokeys.bodyPieceDx *= -1
        pokeyEyes.dy *= -1
        app.steps = 0

    # Sway each body piece side to side, alternating the direction of the
    # movement.
    dx = pokeys.bodyPieceDx
    for pokeyPiece in pokeys.children:
        pokeyPiece.centerX += dx
        dx *= -1

    # Move the eyes up and down, alternating the direction each eye moves.
    dy = pokeyEyes.dy
    for pokeyEye in pokeyEyes.children:
        pokeyEye.centerY += dy
        dy *= -1
    app.steps += 1
",regular,3
2178,Snowy night,7.3.4,"app.background = gradient('navy', 'midnightBlue', start='top')

# the two snow piles
snowPile1 = Circle(450, 500, 250, fill='ghostWhite')
snowPile2 = Circle(-100, 1000, 700, fill='snow')

lamp = Group(
    Line(275, 130, 275, 350, lineWidth=10),
    Oval(275, 85, 40, 50),
    Polygon(255, 130, 295, 130, 305, 125, 245, 125),
    Polygon(260, 125, 290, 125, 295, 90, 255, 90,
            fill=gradient('white', 'yellow', 'gold')),
    Polygon(240, 90, 310, 90, 305, 85, 245, 85)
    )

lampCover = Group(
    Rect(265, 350, 20, 300, fill='ghostWhite'),
    Polygon(270, 350, 280, 350, 270, 355),
    Oval(275, 352, 15, 4, fill='darkGrey', rotateAngle=-30)
    )

snowFlakes = Group()

def onMousePress(mouseX, mouseY):
    snowFlakes.add(
        Star(mouseX, mouseY, 8, 8, fill='white')
        )

def onStep():
    # Move each snowflake down by 5 pixels.
    ### Place Your Code Here ###

    # If it reaches either snow pile, increase that pile's radius by 5 pixels,
    # and remove the snowflake. Also, if it hits the right snow pile, move the
    # lampCover up by 2 pixels.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('navy', 'midnightBlue', start='top')

# the two snow piles
snowPile1 = Circle(450, 500, 250, fill='ghostWhite')
snowPile2 = Circle(-100, 1000, 700, fill='snow')

lamp = Group(
    Line(275, 130, 275, 350, lineWidth=10),
    Oval(275, 85, 40, 50),
    Polygon(255, 130, 295, 130, 305, 125, 245, 125),
    Polygon(260, 125, 290, 125, 295, 90, 255, 90,
            fill=gradient('white', 'yellow', 'gold')),
    Polygon(240, 90, 310, 90, 305, 85, 245, 85)
    )

lampCover = Group(
    Rect(265, 350, 20, 300, fill='ghostWhite'),
    Polygon(270, 350, 280, 350, 270, 355),
    Oval(275, 352, 15, 4, fill='darkGrey', rotateAngle=-30)
    )

snowFlakes = Group()

def onMousePress(mouseX, mouseY):
    snowFlakes.add(
        Star(mouseX, mouseY, 8, 8, fill='white')
        )

def onStep():
    # Move each snowflake down by 5 pixels.
    for flake in snowFlakes.children:
        flake.centerY += 5

        # If it reaches either snow pile, increase the pile radius by 5 pixels,
        # and remove the snowflake. If it hit the right snow pile, move the
        # lampCover up by 2 pixels.
        if (snowPile1.hitsShape(flake) == True):
            snowPile1.radius += 5
            snowFlakes.remove(flake)
            lampCover.centerY -= 2
        elif (snowPile2.hitsShape(flake) == True):
            snowPile2.radius += 5
            snowFlakes.remove(flake)
",regular,2
2183,Mansion,7.4,"app.background = 'lightSkyBlue'

# trees
Circle(10, 227, 10, fill='forestGreen')
Circle(23, 221, 8, fill='forestGreen')
Circle(34, 234, 12, fill='forestGreen')
Circle(45, 233, 7, fill='forestGreen')
Circle(11, 252, 30, fill='forestGreen')
Circle(41, 260, 25, fill='forestGreen')
Circle(351, 227, 10, fill='forestGreen')
Circle(370, 221, 8, fill='forestGreen')
Circle(400, 234, 12, fill='forestGreen')
Circle(380, 225, 7, fill='forestGreen')
Circle(370, 249, 30, fill='forestGreen')
Circle(390, 260, 25, fill='forestGreen')

# mansion
Rect(50, 200, 300, 105, fill='white', border='lightGrey', borderWidth=3)
Rect(100, 150, 200, 155,  fill='white', border='lightGrey', borderWidth=3)
Polygon(50, 205, 105, 205, 75, 180, fill='lightGrey')
Polygon(295, 203, 350, 203, 325, 180, fill='lightGrey')
Polygon(100, 155, 200, 90, 300, 155, fill='lightGrey')
Polygon(200, 60, 225, 60, 220, 70, 230, 80, 200, 75, fill='brown')
Line(200, 90, 200, 60, fill='grey')

def drawSquareWindow(cx, cy):
    window = Group(
        Rect(185, 180, 30, 40, fill='lightCyan', border='lightGrey'),
        Line(200, 190, 200, 210, fill='lightGrey', lineWidth=30, dashes=(2, 14)),
        Line(200, 180, 200, 220, fill='lightGrey')
        )
    window.centerX = cx
    window.centerY = cy

drawSquareWindow(135, 200)
drawSquareWindow(265, 200)
drawSquareWindow(75, 250)
drawSquareWindow(135, 250)
drawSquareWindow(265, 250)
drawSquareWindow(325, 250)

# circle windows
Arc(200, 225, 40, 40, 270, 180, fill='lightCyan', border='lightGrey')
Line(200, 220, 200, 205, fill='lightGrey')
Line(200, 220, 185, 210, fill='lightGrey')
Line(200, 220, 215, 210, fill='lightGrey')
Arc(135, 182, 30, 30, 270, 180, fill='lightCyan', border='lightGrey')
Line(135, 170, 135, 200, fill='lightGrey')
Line(135, 182, 125, 170, fill='lightGrey', lineWidth=1.5)
Line(135, 182, 145, 170, fill='lightGrey', lineWidth=1.5)
Arc(265, 182, 30, 30, 270, 180, fill='lightCyan', border='lightGrey')
Line(265, 170, 265, 200, fill='lightGrey')
Line(265, 182, 255, 170, fill='lightGrey', lineWidth=1.5)
Line(265, 182, 275, 170, fill='lightGrey', lineWidth=1.5)
Oval(200, 180, 40, 30, fill='lightCyan', border='lightGrey')

# entryway
Rect(180, 220, 40, 50, fill='darkGrey', border='grey')
Line(200, 260, 200, 220, fill='grey')
Polygon(150, 305, 180, 260, 220, 260, 250, 305, fill='lightGrey')

# bushes
Circle(5, 290, 20, fill='lightGreen')
Circle(25, 275, 10, fill='lightGreen')
Circle(40, 290, 20, fill='lightGreen')
Circle(60, 295, 15, fill='lightGreen')
Circle(85, 290, 15, fill='lightGreen')
Circle(105, 280, 5, fill='lightGreen')
Circle(115, 275, 5, fill='lightGreen')
Circle(130, 280, 10, fill='lightGreen')
Circle(120, 295, 25, fill='lightGreen')
Circle(145, 295, 5, fill='lightGreen')
Circle(260, 295, 10, fill='lightGreen')
Circle(280, 290, 20, fill='lightGreen')
Circle(295, 275, 10, fill='lightGreen')
Circle(310, 290, 20, fill='lightGreen')
Circle(330, 290, 15, fill='lightGreen')
Circle(350, 285, 15, fill='lightGreen')
Circle(365, 280, 5, fill='lightGreen')
Circle(375, 280, 5, fill='lightGreen')
Circle(385, 280, 10, fill='lightGreen')
Circle(360, 300, 25, fill='lightGreen')
Circle(390, 295, 20, fill='lightGreen')

# lawn
Rect(0, 300, 400, 100, fill='oliveDrab')

def drawFence():
    isHighBar = True

    # Draw all 45 fence posts. Use the isHighBar variable to alternate between
    # tall and short posts. Each post is composed of two lines, one of which uses
    # an arrow.
    ### Place Your Code Here ###

drawFence()

Line(0, 285, 400, 285)
Line(0, 350, 400, 350)
Rect(0, 370, 400, 30, fill='lightGrey')
Line(0, 370, 400, 370, fill='slateGray', lineWidth=5)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightSkyBlue'

# trees
Circle(10, 227, 10, fill='forestGreen')
Circle(23, 221, 8, fill='forestGreen')
Circle(34, 234, 12, fill='forestGreen')
Circle(45, 233, 7, fill='forestGreen')
Circle(11, 252, 30, fill='forestGreen')
Circle(41, 260, 25, fill='forestGreen')
Circle(351, 227, 10, fill='forestGreen')
Circle(370, 221, 8, fill='forestGreen')
Circle(400, 234, 12, fill='forestGreen')
Circle(380, 225, 7, fill='forestGreen')
Circle(370, 249, 30, fill='forestGreen')
Circle(390, 260, 25, fill='forestGreen')

# mansion
Rect(50, 200, 300, 105, fill='white', border='lightGrey', borderWidth=3)
Rect(100, 150, 200, 155,  fill='white', border='lightGrey', borderWidth=3)
Polygon(50, 205, 105, 205, 75, 180, fill='lightGrey')
Polygon(295, 203, 350, 203, 325, 180, fill='lightGrey')
Polygon(100, 155, 200, 90, 300, 155, fill='lightGrey')
Polygon(200, 60, 225, 60, 220, 70, 230, 80, 200, 75, fill='brown')
Line(200, 90, 200, 60, fill='grey')

def drawSquareWindow(cx, cy):
    window = Group(
        Rect(185, 180, 30, 40, fill='lightCyan', border='lightGrey'),
        Line(200, 190, 200, 210, fill='lightGrey', lineWidth=30, dashes=(2, 14)),
        Line(200, 180, 200, 220, fill='lightGrey')
        )
    window.centerX = cx
    window.centerY = cy

drawSquareWindow(135, 200)
drawSquareWindow(265, 200)
drawSquareWindow(75, 250)
drawSquareWindow(135, 250)
drawSquareWindow(265, 250)
drawSquareWindow(325, 250)

# circle windows
Arc(200, 225, 40, 40, 270, 180, fill='lightCyan', border='lightGrey')
Line(200, 220, 200, 205, fill='lightGrey')
Line(200, 220, 185, 210, fill='lightGrey')
Line(200, 220, 215, 210, fill='lightGrey')
Arc(135, 182, 30, 30, 270, 180, fill='lightCyan', border='lightGrey')
Line(135, 170, 135, 200, fill='lightGrey')
Line(135, 182, 125, 170, fill='lightGrey', lineWidth=1.5)
Line(135, 182, 145, 170, fill='lightGrey', lineWidth=1.5)
Arc(265, 182, 30, 30, 270, 180, fill='lightCyan', border='lightGrey')
Line(265, 170, 265, 200, fill='lightGrey')
Line(265, 182, 255, 170, fill='lightGrey', lineWidth=1.5)
Line(265, 182, 275, 170, fill='lightGrey', lineWidth=1.5)
Oval(200, 180, 40, 30, fill='lightCyan', border='lightGrey')

# entryway
Rect(180, 220, 40, 50, fill='darkGrey', border='grey')
Line(200, 260, 200, 220, fill='grey')
Polygon(150, 305, 180, 260, 220, 260, 250, 305, fill='lightGrey')

# bushes
Circle(5, 290, 20, fill='lightGreen')
Circle(25, 275, 10, fill='lightGreen')
Circle(40, 290, 20, fill='lightGreen')
Circle(60, 295, 15, fill='lightGreen')
Circle(85, 290, 15, fill='lightGreen')
Circle(105, 280, 5, fill='lightGreen')
Circle(115, 275, 5, fill='lightGreen')
Circle(130, 280, 10, fill='lightGreen')
Circle(120, 295, 25, fill='lightGreen')
Circle(145, 295, 5, fill='lightGreen')
Circle(260, 295, 10, fill='lightGreen')
Circle(280, 290, 20, fill='lightGreen')
Circle(295, 275, 10, fill='lightGreen')
Circle(310, 290, 20, fill='lightGreen')
Circle(330, 290, 15, fill='lightGreen')
Circle(350, 285, 15, fill='lightGreen')
Circle(365, 280, 5, fill='lightGreen')
Circle(375, 280, 5, fill='lightGreen')
Circle(385, 280, 10, fill='lightGreen')
Circle(360, 300, 25, fill='lightGreen')
Circle(390, 295, 20, fill='lightGreen')

# lawn
Rect(0, 300, 400, 100, fill='oliveDrab')

def drawFence():
    isHighBar = True

    # Draw all 45 fence posts. Use the isHighBar variable to alternate between
    # tall and short posts. Each post is composed of two lines, one of which uses
    # an arrow.
    for i in range(45):
        cx = 10 * i

        if (isHighBar == True):
            topPoint = 250
            isHighBar = False
        else:
            topPoint = 260
            isHighBar = True

        # fence post
        Line(cx, topPoint, cx, topPoint + 15, fill='goldenrod', lineWidth=1.5,
             arrowStart=True)
        Line(cx, 400, cx, topPoint + 15, lineWidth=1.5)

drawFence()

Line(0, 285, 400, 285)
Line(0, 350, 400, 350)
Rect(0, 370, 400, 30, fill='lightGrey')
Line(0, 370, 400, 370, fill='slateGray', lineWidth=5)
",regular,1
2185,Twin popsicles,7.4,"app.background = 'skyBlue'
app.stepsPerSecond = 10

app.popsicleWidth = 40

# ice cream truck
Rect(0, 275, 400, 155, fill=gradient('dimGray', 'lightSlateGray', start='left'))
Polygon(0, 275, 0, 160, 15, 140, 385, 140, 400, 160, 400, 275,
        fill=gradient('darkGrey', 'silver', start='left'))
Oval(60, 187, 20, 10, fill='dimGray')
Line(60, 0, 60, 190, fill=gradient('grey', 'silver', start='left'), lineWidth=15)

# wheel
Circle(440, 440, 200, fill=None, border='black', borderWidth=20)
Star(440, 440, 200, 19, roundness=10)

# sign
Rect(25, 290, 150, 130, fill='white', opacity=60)
Label('$2', 100, 305, fill='dimGrey', size=15)
Line(100, 330, 100, 400, fill='tan', lineWidth=10)
Arc(100, 330, 20, 20, 270, 180, fill='orange')
Rect(90, 330, 20, 60, fill='orange')

sticks = Group()
popsicles = Group()
drops = Group()

def makeSinglePopsicle(cx, color):
    sticks.add(
        Oval(cx, 245, 20, 7, fill='dimGray'),
        Rect(cx, 190, 15, 110, align='center',
             fill=gradient('tan', 'navajoWhite', start='left'))
        )

    popsicle = Group(
        Arc(cx, 95, app.popsicleWidth, 25, 270, 180, fill=color),
        Rect(cx, 150, app.popsicleWidth, 110, fill=color, align='center')
        )
    popsicles.add(popsicle)

def makePopsicle(n, color):
    # Draw n popsicles in a row.
    ### (HINT: We will move the popsicle groups to the correct centerX so you
    #          just need to draw them anywhere. Starting on the left side of
    #          the canvas will be easiest.)
    ### Fix Your Code Here ###
    makeSinglePopsicle(200, color)

    # Moves the popsicles to the center of the canvas.
    sticks.centerX = 200
    popsicles.centerX = 200

def makeDrop(x, y, color):
    drops.add(Circle(x, y, 4, fill=color))

def meltPopsicle():
    # Melts the popsicle and creates drops.
    if (popsicles.height < 2):
        popsicles.clear()
    else:
        popsicles.height -= 2
        popsicles.centerY += 1

    for popsicle in popsicles.children:
        makeDrop(popsicle.centerX, popsicle.bottom, popsicle.fill)

def onStep():
    # Move all of the drops down and remove them once they've reached the bottom
    # of the canvas.
    ### (HINT: We've defined a function above to help melt the popsicles.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'skyBlue'
app.stepsPerSecond = 10

app.popsicleWidth = 40

# ice cream truck
Rect(0, 275, 400, 155, fill=gradient('dimGray', 'lightSlateGray', start='left'))
Polygon(0, 275, 0, 160, 15, 140, 385, 140, 400, 160, 400, 275,
        fill=gradient('darkGrey', 'silver', start='left'))
Oval(60, 187, 20, 10, fill='dimGray')
Line(60, 0, 60, 190, fill=gradient('grey', 'silver', start='left'), lineWidth=15)

# wheel
Circle(440, 440, 200, fill=None, border='black', borderWidth=20)
Star(440, 440, 200, 19, roundness=10)

# sign
Rect(25, 290, 150, 130, fill='white', opacity=60)
Label('$2', 100, 305, fill='dimGrey', size=15)
Line(100, 330, 100, 400, fill='tan', lineWidth=10)
Arc(100, 330, 20, 20, 270, 180, fill='orange')
Rect(90, 330, 20, 60, fill='orange')

sticks = Group()
popsicles = Group()
drops = Group()

def makeSinglePopsicle(cx, color):
    sticks.add(
        Oval(cx, 245, 20, 7, fill='dimGray'),
        Rect(cx, 190, 15, 110, align='center',
             fill=gradient('tan', 'navajoWhite', start='left'))
        )

    popsicle = Group(
        Arc(cx, 95, app.popsicleWidth, 25, 270, 180, fill=color),
        Rect(cx, 150, app.popsicleWidth, 110, fill=color, align='center')
        )
    popsicles.add(popsicle)

def makePopsicle(n, color):
    # Draw n popsicles in a row.
    for i in range(n):
        makeSinglePopsicle(i * app.popsicleWidth, color)

    # Moves the popsicles to the center of the canvas.
    sticks.centerX = 200
    popsicles.centerX = 200

def makeDrop(x, y, color):
    drops.add(Circle(x, y, 4, fill=color))

def meltPopsicle():
    # Melts the popsicle and creates drops.
    if (popsicles.height < 2):
        popsicles.clear()
    else:
        popsicles.height -= 2
        popsicles.centerY += 1

    for popsicle in popsicles.children:
        makeDrop(popsicle.centerX, popsicle.bottom, popsicle.fill)

def onStep():
    # Move all of the drops down and remove them once they've reached the bottom
    # of the canvas.
    for drop in drops.children:
        drop.centerY += 4
        if (drop.centerY > 400):
            drops.remove(drop)

    meltPopsicle()
",regular,1
2186,Invaders lite,7.4,"app.background = 'black'
app.stepsPerSecond = 15

Label('Invaders Lite', 200, 20, fill='white', size=20, bold=True)
Label('left and right move the ship', 200, 40, fill='white')
Label('all other keys launch the laser', 200, 55, fill='white')

score = Label(0, 325, 40, fill='white', size=40, bold=True)
player = Polygon(200, 355, 199, 360, 195, 365, 195, 365, 187, 370, 180, 380,
                 193, 373, 197, 373, 200, 380, 203, 373, 207, 373,
                 220, 380, 213, 370, 205, 365, 205, 365, 201, 360,
                 fill=gradient('lavender', 'thistle', 'fuchsia', start='top'))
player.dx = 10

laser = Circle(player.centerX, player.top, 5, fill='lime', visible=False,
               align='bottom')
laser.dy = -15

invaders = Group()
invaders.dx = 8
invaders.dy = 8
invaders.number = 0

def addInvadersRow(centerY, color):
    # Creates a row of invaders.
    for i in range(5):
        centerX = 100 + 50 * i
        invader = Group(
            RegularPolygon(centerX, centerY - 2, 8, 3, fill=color),
            Rect(centerX - 3, centerY - 10, 6, 5),
            Line(centerX - 3, centerY - 1, centerX + 3, centerY - 1,
                 dashes=(2, 2)),
            Line(centerX - 7, centerY + 3, centerX + 7, centerY + 3, fill=color,
                 dashes=(2, 1))
            )

        invaders.add(invader)
        invaders.number += 1

def addInvaders():
    # Creates all of the invaders for that wave.
    addInvadersRow(100, 'red')
    addInvadersRow(130, 'cyan')
    addInvadersRow(160, 'yellow')

addInvaders()

def gameOver():
    Label('Game Over', 200, 200, fill='white', size=50, bold=True)
    app.stop()

def speedUpInvaders():
    # Every time a wave is cleared, speeds the next wave up.
    if (invaders.dx < 0):
        invaders.dx -= 2
    else:
        invaders.dx += 2
    invaders.dy += 1

def removeHitInvaders():
    # For each invader, if the projectile hits that invader, remove
    # it from the group of invaders and add one to the score.
    ### Place Your Code Here ###

    # If there are no more invaders, get new ones using addInvaders, and
    # speed them up using speedUpInvaders.
    ### Place Your Code Here ###
    pass

def moveDotUp():
    # Moves the laser up by laser.dy, and hides it if it is too high.
    # Otherwise removes any invaders that got hit.
    laser.centerY += laser.dy
    if (laser.centerY <= 75):
        laser.visible = False
    else:
        removeHitInvaders()

def moveInvaders():
    # Moves all the invaders one step left or right.
    invaders.centerX += invaders.dx

    # If it hits the edge, reverse direction and move down a bit.
    if ((invaders.left <= 0) or (invaders.right >= 400)):
        invaders.dx = -invaders.dx
        invaders.centerY += invaders.dy

def testInvaders(x, y):
    ### This function is for testing purposes only. DO NOT edit this function.
    # Removes all invaders, adds a new one, and places the player right under it.
    invaders.clear()
    invaders.add(
        Circle(x, y, 10, fill='orange')
        )
    invaders.number = 1
    player.centerX = x

def onKeyPress(key):
    # Fires a laser.
    if ((key != 'left') and (key != 'right')):
        laser.centerX = player.centerX
        laser.bottom = player.top
        laser.visible = True

def onKeyHold(keys):
    # When the left arrow is pressed, move the player by its dx and bound it
    # by the left edge of the canvas.
    ### Place Your Code Here ###

    # When the right arrow is pressed, move the player by its dx and bound it
    # by the right edge of the canvas.
    ### Place Your Code Here ###
    pass

def onStep():
    # First moves the invaders.
    moveInvaders()

    # Next, checks if we lost the game.
    if (invaders.bottom > player.top):
        gameOver()

    # Then, moves the projectile if it's visible.
    if (laser.visible == True):
        moveDotUp()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 15

Label('Invaders Lite', 200, 20, fill='white', size=20, bold=True)
Label('left and right move the ship', 200, 40, fill='white')
Label('all other keys launch the laser', 200, 55, fill='white')

score = Label(0, 325, 40, fill='white', size=40, bold=True)
player = Polygon(200, 355, 199, 360, 195, 365, 195, 365, 187, 370, 180, 380,
                 193, 373, 197, 373, 200, 380, 203, 373, 207, 373,
                 220, 380, 213, 370, 205, 365, 205, 365, 201, 360,
                 fill=gradient('lavender', 'thistle', 'fuchsia', start='top'))
player.dx = 10

laser = Circle(player.centerX, player.top, 5, fill='lime', visible=False,
               align='bottom')
laser.dy = -15

invaders = Group()
invaders.dx = 8
invaders.dy = 8
invaders.number = 0

def addInvadersRow(centerY, color):
    # Creates a row of invaders.
    for i in range(5):
        centerX = 100 + 50 * i
        invader = Group(
            RegularPolygon(centerX, centerY - 2, 8, 3, fill=color),
            Rect(centerX - 3, centerY - 10, 6, 5),
            Line(centerX - 3, centerY - 1, centerX + 3, centerY - 1,
                 dashes=(2, 2)),
            Line(centerX - 7, centerY + 3, centerX + 7, centerY + 3, fill=color,
                 dashes=(2, 1))
            )

        invaders.add(invader)
        invaders.number += 1

def addInvaders():
    # Creates all of the invaders for that wave.
    addInvadersRow(100, 'red')
    addInvadersRow(130, 'cyan')
    addInvadersRow(160, 'yellow')

addInvaders()

def gameOver():
    Label('Game Over', 200, 200, fill='white', size=50, bold=True)
    app.stop()

def speedUpInvaders():
    # Every time a wave is cleared, speeds the next wave up.
    if (invaders.dx < 0):
        invaders.dx -= 2
    else:
        invaders.dx += 2
    invaders.dy += 1

def removeHitInvaders():
    # For each invader, if the projectile hits that invader, remove
    # it from the group of invaders and add one to the score.
    for invader in invaders.children:
        if (laser.hitsShape(invader) == True):
            invaders.remove(invader)
            invaders.number -= 1
            score.value += 1

    # If there are no more invaders, get new ones using addInvaders, and
    # speed them up using speedUpInvaders.
    if (invaders.number == 0):
        addInvaders()
        speedUpInvaders()

def moveDotUp():
    # Moves the laser up by laser.dy, and hides it if it is too high.
    # Otherwise removes any invaders that got hit.
    laser.centerY += laser.dy
    if (laser.centerY <= 75):
        laser.visible = False
    else:
        removeHitInvaders()

def moveInvaders():
    # Moves all the invaders one step left or right.
    invaders.centerX += invaders.dx

    # If it hits the edge, reverse direction and move down a bit.
    if ((invaders.left <= 0) or (invaders.right >= 400)):
        invaders.dx = -invaders.dx
        invaders.centerY += invaders.dy

def testInvaders(x, y):
    ### This function is for testing purposes only. DO NOT edit this function.
    # Removes all invaders, adds a new one, and places the player right under it.
    invaders.clear()
    invaders.add(
        Circle(x, y, 10, fill='orange')
        )
    invaders.number = 1
    player.centerX = x

def onKeyPress(key):
    # Fires a laser.
    if ((key != 'left') and (key != 'right')):
        laser.centerX = player.centerX
        laser.bottom = player.top
        laser.visible = True

def onKeyHold(keys):
    # When the left arrow is pressed, move the player by its dx and bound it
    # by the left edge of the canvas.
    if ('left' in keys):
        player.centerX -= player.dx
        if (player.left < 0):
            player.left = 0

    # When the right arrow is pressed, move the player by its dx and bound it
    # by the right edge of the canvas.
    if ('right' in keys):
        player.centerX += player.dx
        if (player.right > 400):
            player.right = 400

def onStep():
    # First moves the invaders.
    moveInvaders()

    # Next, checks if we lost the game.
    if (invaders.bottom > player.top):
        gameOver()

    # Then, moves the projectile if it's visible.
    if (laser.visible == True):
        moveDotUp()
",regular,2
2187,Conveyor belt,7.4,"app.background = gradient('steelBlue', 'lightSlateGray', start='top')
app.stepsPerSecond = 15

def createWheels(sideWheels, start):
    for i in range(6):
        sideWheels.add(
            Star(start + i * 20, 265, 10, 7, roundness=20),
            Circle(start + i * 20, 265, 6, fill='grey', border='black')
            )

# conveyor belts
Line(10, 290, 390, 290, lineWidth=30, dashes=(2, 40))
Rect(-10, 255, 420, 20, fill='grey', border='black')
rightWheels = Group()
leftWheels = Group()
createWheels(rightWheels, 292)
createWheels(leftWheels, 8)

leftDots = Group()
rightDots = Group()

# machine
Polygon(150, 135, 250, 135, 235, 100, 235, 0, 165, 0, 165, 100,
        fill=gradient('lightGrey', 'grey', start='left-top'))
Line(165, 100, 235, 100, fill='grey')
Rect(116, 135, 168, 200, fill=gradient('lightGrey', 'grey', start='left-top'))
Rect(135, 265, 65, 60, fill=gradient('lightGrey', 'dimGrey', start='left-top'))
Oval(240, 260, 60, 30, fill=gradient('lightGrey', 'dimGrey', start='left-top'))
Line(220, 300, 260, 300, fill=gradient('silver', 'dimGrey', start='left-top'),
     lineWidth=70, dashes=(10, 5))
Line(114, 200, 114, 280, fill='dimGrey', lineWidth=4)
Line(286, 200, 286, 280, fill='dimGrey', lineWidth=4)
Line(115, 330, 285, 330, fill='dimGrey', lineWidth=10)
Rect(135, 150, 130, 60, border='dimGrey')

arrow = Line(160, 180, 240, 180, fill='crimson')

def onKeyPress(key):
    if (key == 'left'):
        arrow.arrowStart = True
    if (key == 'right'):
        arrow.arrowEnd = True

def onKeyRelease(key):
    if (key == 'left'):
        arrow.arrowStart = False
    if (key == 'right'):
        arrow.arrowEnd = False

def onStep():
    # Rotates the wheels of the belts.
    for wheel in leftWheels.children:
        wheel.rotateAngle -= 5
    for wheel in rightWheels.children:
        wheel.rotateAngle += 5

    # Add dots based on which direction the arrow points.
    ### (HINT: Use the values for arrow.arrowStart and arrow.arrowEnd.)
    ### Place Your Code Here ###

    # Move the dots in their respective directions by 10 pixels and remove
    # them once they are off-screen.
    ### Place Your Code Here ###

    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('steelBlue', 'lightSlateGray', start='top')
app.stepsPerSecond = 15

def createWheels(sideWheels, start):
    for i in range(6):
        sideWheels.add(
            Star(start + i * 20, 265, 10, 7, roundness=20),
            Circle(start + i * 20, 265, 6, fill='grey', border='black')
            )

# conveyor belts
Line(10, 290, 390, 290, lineWidth=30, dashes=(2, 40))
Rect(-10, 255, 420, 20, fill='grey', border='black')
rightWheels = Group()
leftWheels = Group()
createWheels(rightWheels, 292)
createWheels(leftWheels, 8)

leftDots = Group()
rightDots = Group()

# machine
Polygon(150, 135, 250, 135, 235, 100, 235, 0, 165, 0, 165, 100,
        fill=gradient('lightGrey', 'grey', start='left-top'))
Line(165, 100, 235, 100, fill='grey')
Rect(116, 135, 168, 200, fill=gradient('lightGrey', 'grey', start='left-top'))
Rect(135, 265, 65, 60, fill=gradient('lightGrey', 'dimGrey', start='left-top'))
Oval(240, 260, 60, 30, fill=gradient('lightGrey', 'dimGrey', start='left-top'))
Line(220, 300, 260, 300, fill=gradient('silver', 'dimGrey', start='left-top'),
     lineWidth=70, dashes=(10, 5))
Line(114, 200, 114, 280, fill='dimGrey', lineWidth=4)
Line(286, 200, 286, 280, fill='dimGrey', lineWidth=4)
Line(115, 330, 285, 330, fill='dimGrey', lineWidth=10)
Rect(135, 150, 130, 60, border='dimGrey')

arrow = Line(160, 180, 240, 180, fill='crimson')

def onKeyPress(key):
    if (key == 'left'):
        arrow.arrowStart = True
    if (key == 'right'):
        arrow.arrowEnd = True

def onKeyRelease(key):
    if (key == 'left'):
        arrow.arrowStart = False
    if (key == 'right'):
        arrow.arrowEnd = False

def onStep():
    # Rotates the wheels of the belts.
    for wheel in leftWheels.children:
        wheel.rotateAngle -= 5
    for wheel in rightWheels.children:
        wheel.rotateAngle += 5

    # Add dots based on which direction the arrow points.
    if (arrow.arrowStart == True):
        leftDots.add(
            Circle(120, 250, 5, fill='springGreen')
            )
    if (arrow.arrowEnd == True):
        rightDots.add(
            Circle(280, 250, 5, fill='deepSkyBlue')
            )

    # Move the dots in their respective directions and remove them
    # once they are off-screen.
    for dot in rightDots.children:
        dot.centerX += 10
        if (dot.left > 400):
            rightDots.remove(dot)

    for dot in leftDots.children:
        dot.centerX -= 10
        if (dot.right < 0):
            leftDots.remove(dot)
",regular,2
2184,Christmas tree,7.4,"app.background = 'rosyBrown'

# background
Line(0, 150, 400, 150, fill='paleVioletRed', lineWidth=300, dashes=(0.5, 20))
Rect(0, 300, 400, 100, fill='peru')
Line(0, 300, 400, 300)
Rect(100, 50, 200, 200, fill=gradient('steelBlue', 'indigo', start='top-left'),
     border='black')
Line(100, 150, 300, 150)

# presents
Rect(120, 360, 50, 30, fill='lightPink')
Line(145, 360, 145, 390, fill='orange', lineWidth=10)
Rect(230, 340, 40, 50, fill='teal')
Line(230, 365, 270, 365, fill='orange', lineWidth=10)

# tree
Rect(200, 320, 50, 70, fill='saddleBrown', align='top')
Polygon(200, 40, 80, 370, 180, 340, 200, 370, 220, 340, 320, 370, fill='oliveDrab')
Polygon(200, 40, 90, 300, 180, 270, 200, 300, 220, 270, 310, 300, fill='darkGreen')
Polygon(200, 40, 100, 240, 180, 210, 200, 240, 220, 210, 300, 240, fill='green')
Polygon(200, 40, 120, 180, 180, 150, 200, 180, 220, 150, 280, 180,
        fill='forestGreen')

# wires
Line(235, 102, 120, 180)
Line(143, 140, 281, 202)
Line(271, 182, 113, 251)
Line(112, 216, 310, 300)
Line(294, 262, 93, 339)

# bulbs group
bulbs = Group()

def drawBulb(x, topY, angle, color):
    light = Group(
        Star(200, 200, 30, 150, fill=color, roundness=20, opacity=0),
        Circle(200, 200, 11, fill=color, border='black', opacity=0)
        )
    bulb = Group(
        Rect(200, 187, 10, 15, align='top'),
        Circle(200, 200, 11, fill='lightGrey', border='black'),
        light,
        Oval(197, 196, 3, 6, fill=None, border='black', borderWidth=0.7),
        Oval(200, 196, 3, 6, fill=None, border='black', borderWidth=0.7),
        Oval(203, 196, 3, 6, fill=None, border='black', borderWidth=0.7)
        )

    # Stores the light of the bulb as a custom property.
    bulb.light = light

    bulb.top = topY
    bulb.centerX = x
    bulb.rotateAngle = angle
    bulbs.add(bulb)

# draw the bulbs on the tree
drawBulb(230, 90, -30, 'gold')
drawBulb(200, 110, -30, 'hotPink')
drawBulb(170, 130, -30, 'mediumTurquoise')
drawBulb(140, 150, -30, 'mediumPurple')
drawBulb(147, 127, 25, 'gold')
drawBulb(187, 145, 25, 'hotPink')
drawBulb(227, 162, 25, 'mediumTurquoise')
drawBulb(267, 180, 25, 'mediumPurple')
drawBulb(240, 180, -25, 'gold')
drawBulb(200, 198, -25, 'hotPink')
drawBulb(160, 216, -25, 'mediumTurquoise')
drawBulb(120, 232, -25, 'mediumPurple')
drawBulb(130, 208, 25, 'gold')
drawBulb(180, 230, 25, 'hotPink')
drawBulb(230, 250, 25, 'mediumTurquoise')
drawBulb(280, 270, 25, 'mediumPurple')
drawBulb(285, 250, -25, 'gold')
drawBulb(240, 270, -25, 'hotPink')
drawBulb(195, 285, -25, 'mediumTurquoise')
drawBulb(150, 300, -25, 'mediumPurple')
drawBulb(105, 318, -25, 'gold')

def onMousePress(mouseX, mouseY):
    # When a bulb clicked, toggle it on and off by changing the light's opacity.
    ### (HINT: Loop through all of the bulbs and check if any of them are
    #          clicked on.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'rosyBrown'

# background
Line(0, 150, 400, 150, fill='paleVioletRed', lineWidth=300, dashes=(0.5, 20))
Rect(0, 300, 400, 100, fill='peru')
Line(0, 300, 400, 300)
Rect(100, 50, 200, 200, fill=gradient('steelBlue', 'indigo', start='top-left'),
     border='black')
Line(100, 150, 300, 150)

# presents
Rect(120, 360, 50, 30, fill='lightPink')
Line(145, 360, 145, 390, fill='orange', lineWidth=10)
Rect(230, 340, 40, 50, fill='teal')
Line(230, 365, 270, 365, fill='orange', lineWidth=10)

# tree
Rect(200, 320, 50, 70, fill='saddleBrown', align='top')
Polygon(200, 40, 80, 370, 180, 340, 200, 370, 220, 340, 320, 370, fill='oliveDrab')
Polygon(200, 40, 90, 300, 180, 270, 200, 300, 220, 270, 310, 300, fill='darkGreen')
Polygon(200, 40, 100, 240, 180, 210, 200, 240, 220, 210, 300, 240, fill='green')
Polygon(200, 40, 120, 180, 180, 150, 200, 180, 220, 150, 280, 180,
        fill='forestGreen')

# wires
Line(235, 102, 120, 180)
Line(143, 140, 281, 202)
Line(271, 182, 113, 251)
Line(112, 216, 310, 300)
Line(294, 262, 93, 339)

# bulbs group
bulbs = Group()

def drawBulb(x, topY, angle, color):
    light = Group(
        Star(200, 200, 30, 150, fill=color, roundness=20, opacity=0),
        Circle(200, 200, 11, fill=color, border='black', opacity=0)
        )
    bulb = Group(
        Rect(200, 187, 10, 15, align='top'),
        Circle(200, 200, 11, fill='lightGrey', border='black'),
        light,
        Oval(197, 196, 3, 6, fill=None, border='black', borderWidth=0.7),
        Oval(200, 196, 3, 6, fill=None, border='black', borderWidth=0.7),
        Oval(203, 196, 3, 6, fill=None, border='black', borderWidth=0.7)
        )

    # Stores the light of the bulb as a custom property.
    bulb.light = light

    bulb.top = topY
    bulb.centerX = x
    bulb.rotateAngle = angle
    bulbs.add(bulb)

# draw the bulbs on the tree
drawBulb(230, 90, -30, 'gold')
drawBulb(200, 110, -30, 'hotPink')
drawBulb(170, 130, -30, 'mediumTurquoise')
drawBulb(140, 150, -30, 'mediumPurple')
drawBulb(147, 127, 25, 'gold')
drawBulb(187, 145, 25, 'hotPink')
drawBulb(227, 162, 25, 'mediumTurquoise')
drawBulb(267, 180, 25, 'mediumPurple')
drawBulb(240, 180, -25, 'gold')
drawBulb(200, 198, -25, 'hotPink')
drawBulb(160, 216, -25, 'mediumTurquoise')
drawBulb(120, 232, -25, 'mediumPurple')
drawBulb(130, 208, 25, 'gold')
drawBulb(180, 230, 25, 'hotPink')
drawBulb(230, 250, 25, 'mediumTurquoise')
drawBulb(280, 270, 25, 'mediumPurple')
drawBulb(285, 250, -25, 'gold')
drawBulb(240, 270, -25, 'hotPink')
drawBulb(195, 285, -25, 'mediumTurquoise')
drawBulb(150, 300, -25, 'mediumPurple')
drawBulb(105, 318, -25, 'gold')

def onMousePress(mouseX, mouseY):
    # When a bulb clicked, toggle it on and off by changing the light's opacity.
    for bulb in bulbs:
        if (bulb.hits(mouseX, mouseY) == True):
            if (bulb.light.opacity == 100):
                bulb.light.opacity = 0
            else:
                bulb.light.opacity = 100
",regular,1
2189,Bubbles,7.4,"app.background = gradient('lightCyan', 'lightSkyBlue', start='bottom')

# grass
Oval(370, 440, 800, 200, fill='mediumSeaGreen')
Oval(130, 450, 800, 200, fill='forestGreen')

def drawDaisy(x, y):
    daisy = Group()

    # Draw the petals of the daisy using 6 Ovals. Each oval should have a
    # width of 9 and a height of 30. Use a loop to figure out the rotateAngle.
    ### Place Your Code Here ###

    # This draws the center piece and adjusts the height so that it looks like
    # the flower is flat on the ground.
    daisy.add(Circle(x, y, 7.5, fill='gold'))
    daisy.height = 20

# Adds daisies to the field.
drawDaisy(2, 365)
drawDaisy(30, 380)
drawDaisy(80, 365)
drawDaisy(114, 369)
drawDaisy(150, 389)
drawDaisy(94, 373)
drawDaisy(164, 376)
drawDaisy(205, 380)
drawDaisy(228, 358)
drawDaisy(330, 383)
drawDaisy(318, 399)
drawDaisy(365, 384)
drawDaisy(399, 399)
drawDaisy(67, 399)
drawDaisy(48, 403)
drawDaisy(269, 363)

bubbleWand = Group(
    Line(100, 300, 125, 325, fill='grey', lineWidth=3),
    Oval(90, 290, 28, 13, fill=None, border='grey', borderWidth=3, rotateAngle=45),
    Oval(90, 290, 33, 16, fill=None, border='grey', borderWidth=4, rotateAngle=45,
         dashes=(3, 2))
    )

bubbles = Group()

def createBubble(x, y):
    bubble = Group(
        Circle(x, y, 20, fill=gradient('white', 'lightBlue', start='top-right'),
               border='white', opacity=50),
        Oval(x + 10, y - 10, 10, 5, fill='white', rotateAngle=45),
        Circle(x + 14, y - 2, 2, fill='white')
        )
    bubbles.add(bubble)

def onMousePress(mouseX, mouseY):
    createBubble(mouseX, mouseY)

def onMouseMove(mouseX, mouseY):
    bubbleWand.centerX = mouseX
    bubbleWand.centerY = mouseY

def onStep():
    # Increase the size of the bubbles and move them up by 0.5 pixels. If a
    # bubble gets too big (a width of at least 100 pixels), remove it.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightCyan', 'lightSkyBlue', start='bottom')

# grass
Oval(370, 440, 800, 200, fill='mediumSeaGreen')
Oval(130, 450, 800, 200, fill='forestGreen')

def drawDaisy(x, y):
    daisy = Group()

    # Draw the petals of the daisy using 6 Ovals. Each oval should have a
    # width of 9 and a height of 30. Use a loop to figure out the rotateAngle.
    for i in range(6):
        angle = i * 30
        daisy.add(
            Oval(x, y, 9, 30, fill='white', rotateAngle=angle)
            )

    # This draws the center piece and adjusts the height so that it looks like
    # the flower is flat on the ground.
    daisy.add(Circle(x, y, 7.5, fill='gold'))
    daisy.height = 20

# Adds daisies to the field.
drawDaisy(2, 365)
drawDaisy(30, 380)
drawDaisy(80, 365)
drawDaisy(114, 369)
drawDaisy(150, 389)
drawDaisy(94, 373)
drawDaisy(164, 376)
drawDaisy(205, 380)
drawDaisy(228, 358)
drawDaisy(330, 383)
drawDaisy(318, 399)
drawDaisy(365, 384)
drawDaisy(399, 399)
drawDaisy(67, 399)
drawDaisy(48, 403)
drawDaisy(269, 363)

bubbleWand = Group(
    Line(100, 300, 125, 325, fill='grey', lineWidth=3),
    Oval(90, 290, 28, 13, fill=None, border='grey', borderWidth=3, rotateAngle=45),
    Oval(90, 290, 33, 16, fill=None, border='grey', borderWidth=4, rotateAngle=45,
         dashes=(3, 2))
    )

bubbles = Group()

def createBubble(x, y):
    bubble = Group(
        Circle(x, y, 20, fill=gradient('white', 'lightBlue', start='top-right'),
               border='white', opacity=50),
        Oval(x + 10, y - 10, 10, 5, fill='white', rotateAngle=45),
        Circle(x + 14, y - 2, 2, fill='white')
        )
    bubbles.add(bubble)

def onMousePress(mouseX, mouseY):
    createBubble(mouseX, mouseY)

def onMouseMove(mouseX, mouseY):
    bubbleWand.centerX = mouseX
    bubbleWand.centerY = mouseY

def onStep():
    # Increase the size of the bubbles and move them up by 0.5 pixels. If a
    # bubble gets too big (a width of at least 100 pixels), remove it.
    for bubble in bubbles.children:
        bubble.width += 0.5
        bubble.height += 0.5
        bubble.centerY -= 0.5

        # Pop the bubbles when they become too big.
        if (bubble.width >= 100):
            bubbles.remove(bubble)
",regular,2
2190,Lava lamp,7.4,"app.background = gradient('yellow', 'crimson', start='top')
app.stepsPerSecond = 20

# window
Line(200, 0, 200, 400, lineWidth=4)
Line(0, 200, 400, 200, lineWidth=4)
Rect(0, 0, 400, 400, fill=None, border='black', borderWidth=10)

# table
Rect(100, 375, 200, 10)
Rect(100, 385, 10, 15)
Rect(290, 385, 10, 15)

# Initialize empty blob group.
blobs = Group()

def createBlobs():
    newBlobRadius = 5
    newBlobX = 160
    newBlobSpeed = 6

    # Creates 6 blobs that increase in size and decrease in speed.
    for i in range(6):
        blob = Circle(newBlobX, 200, newBlobRadius, fill='red', opacity=90)
        blob.dy = newBlobSpeed
        blobs.add(blob)

        newBlobRadius += 5
        newBlobX += 10
        newBlobSpeed -= 1

# Populates the blob group.
createBlobs()

# lamp
Oval(200, 200, 130, 300, fill=gradient('yellow', 'red'), opacity=65)
Oval(200, 200, 130, 300, fill=None, border='black')
Polygon(150, 100, 175, 50, 225, 50, 250, 100,
        fill=gradient('orange', 'fireBrick', start='left'), border='black')
Polygon(150, 300, 175, 350, 225, 350, 250, 300,
        fill=gradient('orange', 'fireBrick', start='left'), border='black')
Polygon(175, 350, 160, 375, 240, 375, 225, 350,
        fill=gradient('orange', 'fireBrick', start='left'), border='black')

def onStep():
    # Move each blob based off of the speed defined in createBlobs(),
    # and bounce it when it reaches the bounds of the lamp.
    ### (HINT: Move each blob separately since they have different speed.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('yellow', 'crimson', start='top')
app.stepsPerSecond = 20

# window
Line(200, 0, 200, 400, lineWidth=4)
Line(0, 200, 400, 200, lineWidth=4)
Rect(0, 0, 400, 400, fill=None, border='black', borderWidth=10)

# table
Rect(100, 375, 200, 10)
Rect(100, 385, 10, 15)
Rect(290, 385, 10, 15)

# Initialize empty blob group.
blobs = Group()

def createBlobs():
    newBlobRadius = 5
    newBlobX = 160
    newBlobSpeed = 6

    # Creates 6 blobs that increase in size and decrease in speed.
    for i in range(6):
        blob = Circle(newBlobX, 200, newBlobRadius, fill='red', opacity=90)
        blob.dy = newBlobSpeed
        blobs.add(blob)

        newBlobRadius += 5
        newBlobX += 10
        newBlobSpeed -= 1

# Populates the blob group.
createBlobs()

# lamp
Oval(200, 200, 130, 300, fill=gradient('yellow', 'red'), opacity=65)
Oval(200, 200, 130, 300, fill=None, border='black')
Polygon(150, 100, 175, 50, 225, 50, 250, 100,
        fill=gradient('orange', 'fireBrick', start='left'), border='black')
Polygon(150, 300, 175, 350, 225, 350, 250, 300,
        fill=gradient('orange', 'fireBrick', start='left'), border='black')
Polygon(175, 350, 160, 375, 240, 375, 225, 350,
        fill=gradient('orange', 'fireBrick', start='left'), border='black')

def onStep():
    # Move each blob based off of the speed defined in createBlobs(),
    # and bounce it when it reaches the bounds of the lamp.
    for blob in blobs.children:
        blob.centerY += blob.dy
        if ((blob.centerY + blob.radius > 300) or
            (blob.centerY - blob.radius < 100)):
            blob.dy *= -1
",regular,1
2191,Breakout,7.4,"app.stepsPerSecond = 50
app.background = 'black'

blocks = Group()
blocks.blockCount = 0
blocks.rowColor = 'red'

paddle = Rect(160, 380, 80, 20, fill='lemonChiffon', border='black')
paddle.prevX = 160

ball = Circle(200, 370, 10, fill='lemonChiffon')
ball.dx = 3
ball.dy = -6

def setRowColor(row):
    if (row == 0):
        blocks.rowColor = 'steelBlue'
    elif (row == 1):
        blocks.rowColor = 'cornflowerBlue'
    elif (row == 2):
        blocks.rowColor = 'skyBlue'
    elif (row == 3):
        blocks.rowColor = 'lightBlue'
    else:
        blocks.rowColor = 'lightCyan'

def makeRow(row):
    # For the given row, add 5 blocks and increase the blockCount.
    ### Place Your Code Here ###
    pass

def makeBlocks():
    # For each row, set the row color and make the row.
    ### Place Your Code Here ###
    pass

makeBlocks()

def onMouseMove(mouseX, mouseY):
    # Moves the paddle.
    paddle.prevX = paddle.centerX
    paddle.centerX = mouseX

def onStep():
    ball.centerX += ball.dx
    ball.centerY += ball.dy

    # Checks if the ball has gone out of range and bounce it if it hits a wall.
    if ((ball.left <= 0) or (ball.right >= 400)):
        ball.dx = -ball.dx
    if (ball.top <= 0):
        ball.dy = 6
    elif (ball.bottom >= 400):
        Label('You Lose!', 200, 200, fill='white', size=50)
        app.paused = True

    # Checks if the paddle intersected the ball.
    if (paddle.hitsShape(ball) == True):
        ball.dy = -6

        # If player moved the paddle left to right, moves the ball right.
        if (paddle.centerX - paddle.prevX > 0):
            ball.dx = 6

        # If player moved the paddle right to left, moves the ball left.
        elif (paddle.centerX - paddle.prevX < 0):
            ball.dx = -6
        else:
            ball.dx = 0

    # Check if the ball has hit any blocks in the group blocks.
    # If it has, remove that block, reverse the direction of the ball,
    # and decrease the block count.
    ### Place Your Code Here ###

    # Checks if all of the blocks have been removed.
    if (blocks.blockCount == 0):
        Label('You Win!', 200, 200, fill='white', size=50)
        app.paused = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 50
app.background = 'black'

blocks = Group()
blocks.blockCount = 0
blocks.rowColor = 'red'

paddle = Rect(160, 380, 80, 20, fill='lemonChiffon', border='black')
paddle.prevX = 160

ball = Circle(200, 370, 10, fill='lemonChiffon')
ball.dx = 3
ball.dy = -6

def setRowColor(row):
    if (row == 0):
        blocks.rowColor = 'steelBlue'
    elif (row == 1):
        blocks.rowColor = 'cornflowerBlue'
    elif (row == 2):
        blocks.rowColor = 'skyBlue'
    elif (row == 3):
        blocks.rowColor = 'lightBlue'
    else:
        blocks.rowColor = 'lightCyan'

def makeRow(row):
    # For the given row, add 5 blocks and increase the blockCount.
    for col in range(5):
        blocks.add(
            Rect(col * 80, row * 30, 80, 30, fill=blocks.rowColor,
                 border='black', borderWidth=3)
            )
        blocks.blockCount += 1

def makeBlocks():
    # For each row, set the row color and make the row.
    for row in range(5):
        setRowColor(row)
        makeRow(row)

makeBlocks()

def onMouseMove(mouseX, mouseY):
    # Moves the paddle.
    paddle.prevX = paddle.centerX
    paddle.centerX = mouseX

def onStep():
    ball.centerX += ball.dx
    ball.centerY += ball.dy

    # Checks if the ball has gone out of range and bounce it if it hits a wall.
    if ((ball.left <= 0) or (ball.right >= 400)):
        ball.dx = -ball.dx
    if (ball.top <= 0):
        ball.dy = 6
    elif (ball.bottom >= 400):
        Label('You Lose!', 200, 200, fill='white', size=50)
        app.paused = True

    # Checks if the paddle intersected the ball.
    if (paddle.hitsShape(ball) == True):
        ball.dy = -6

        # If player moved the paddle left to right, moves the ball right.
        if (paddle.centerX - paddle.prevX > 0):
            ball.dx = 6

        # If player moved the paddle right to left, moves the ball left.
        elif (paddle.centerX - paddle.prevX < 0):
            ball.dx = -6
        else:
            ball.dx = 0

    # Check if the ball has hit any blocks in the group blocks.
    # If it has, remove that block, reverse the direction of the ball,
    # and decrease the block count.
    for block in blocks.children:
        if (block.hitsShape(ball) == True):
            blocks.remove(block)
            ball.dy *= -1
            blocks.blockCount -= 1

    # Checks if all of the blocks have been removed.
    if (blocks.blockCount == 0):
        Label('You Win!', 200, 200, fill='white', size=50)
        app.paused = True
",regular,3
2188,Spinning arcs,7.4,"app.background = rgb(0, 0, 60)

arcs = Group()

for i in range(10):
    # Each green strip is an arc with the center covered by another arc.
    # The strips are drawn from big to small so the covering arcs only cover
    # the arcs that are bigger than them.
    arc1 = Arc(200, 200, 401 - (40 * i), 401 - (40 * i), 0, 10,
               fill=rgb(0, 25 * (i + 1), 20 * (i + 1)))
    arc2 = Arc(200, 200, 370 - (40 * i), 370 - (40 * i), 0, 10,
               fill=rgb(0, 0, 60))

    # dA is the change in the start angle, dS is the change in the sweep angle.
    arc1.dA = i + 1
    arc1.dS = 2 * (i + 1)
    arc2.dA = i + 1
    arc2.dS = 2 * (i + 1)

    arcs.add(arc1, arc2)

def moveArc(arc):
    # If the sweepAngle will become too small or is bigger than or equal to 340,
    # change the direction that the sweep angle changes.
    ### Place Your Code Here ###

    # Update the start and sweep angles of the arc.
    ### Place Your Code Here ###

    # When the start angle gets to 360, reset it to 0.
    ### Place Your Code Here ###
    pass

def onStep():
    for arc in arcs.children:
        moveArc(arc)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(0, 0, 60)

arcs = Group()

for i in range(10):
    # Each green strip is an arc with the center covered by another arc.
    # The strips are drawn from big to small so the covering arcs only cover
    # the arcs that are bigger than them.
    arc1 = Arc(200, 200, 401 - (40 * i), 401 - (40 * i), 0, 10,
               fill=rgb(0, 25 * (i + 1), 20 * (i + 1)))
    arc2 = Arc(200, 200, 370 - (40 * i), 370 - (40 * i), 0, 10,
               fill=rgb(0, 0, 60))

    # dA is the change in the start angle, dS is the change in the sweep angle.
    arc1.dA = i + 1
    arc1.dS = 2 * (i + 1)
    arc2.dA = i + 1
    arc2.dS = 2 * (i + 1)

    arcs.add(arc1, arc2)

def moveArc(arc):
    # If the sweepAngle will become too small or is bigger than or equal to 340,
    # change the direction that the sweep angle changes.
    if ((arc.sweepAngle + arc.dS <= 0) or (arc.sweepAngle >= 340)):
        arc.dS *= -1

    # Update the start and sweep angles of the arc.
    arc.startAngle += arc.dA
    arc.sweepAngle += arc.dS

    # When the start angle gets to 360, reset it to 0.
    if (arc.startAngle >= 360):
        arc.startAngle = 0

def onStep():
    for arc in arcs.children:
        moveArc(arc)
",regular,3
2193,Layered cake,7.5,"app.background = gradient('plum', 'thistle', start='left')

Label('Layers:', 380, 20, size=20, bold=True, align='right')
layersCountLabel = Label(5, 345, 50, size=30, bold=True)

# table
Polygon(0, 300, 30, 245, 400, 245, 400, 400, 0, 400, fill='saddleBrown')

layers = Group()
layers.colorNum = 0

def drawCake(layersCount):
    for i in range(layersCount):
        # Define the size and location of this layer.
        # The largest width is 300 and each layer is 30 less.
        # The total height of the cake is 300 and each layer has the same height.
        # The top is 380 subtracted by the height times (*) the layer index + 1.
        # centerY is sum of top and half of height.
        ### Fix Your Code Here ###
        # width =
        # height =
        # top =
        # centerY =

        # Set the color of the layer based on the layers.colorNum property.
        ### (HINT: The layers.colorNum is a number between 0 and 2. Use this to
        #          cycle through the three possible colors for the layer!)
        ### Fix Your Code Here ###
        # layerColor =
        # topColor =

        # Draw and add this layer to the layers group.
        ### Place Your Code Here ###
        pass

    # Draw a candle on top of the cake and add it to the layers group.
    ### Place Your Code Here ###

def onKeyPress(key):
    # Change the number of layers when the 'up' or 'down' keys are pressed.
    # A cake has at most 10 layers, otherwise the width gets too small.
    ### Place Your Code Here ###

    # Always remove the old layers and draw new ones.
    ### Place Your Code Here ###
    pass

# Start with the 5 layers already drawn.
drawCake(layersCountLabel.value)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('plum', 'thistle', start='left')

Label('Layers:', 380, 20, size=20, bold=True, align='right')
layersCountLabel = Label(5, 345, 50, size=30, bold=True)

# table
Polygon(0, 300, 30, 245, 400, 245, 400, 400, 0, 400, fill='saddleBrown')

layers = Group()
layers.colorNum = 0

def drawCake(layersCount):
    for i in range(layersCount):
        # Define the size and location of this layer.
        width = 300 - 30 * i
        height = 300 / layersCount
        top = 380 - height * (i + 1)
        centerY = top + height / 2

        # Set the color of the layer based on the layers.colorNum property.
        if (layers.colorNum == 0):
            layers.colorNum = 1
            layerColor = gradient('lightGreen', 'paleGreen', start='left')
            topColor = gradient('paleGreen', 'honeydew', start='left')
        elif (layers.colorNum == 1):
            layers.colorNum = 2
            layerColor = gradient('lightBlue', 'paleTurquoise', start='left')
            topColor = gradient('powderBlue', 'aliceBlue', start='left')
        elif (layers.colorNum == 2):
            layers.colorNum = 0
            layerColor = gradient('lightPink', 'pink', start='left')
            topColor = gradient('pink', 'lavenderBlush', start='left')

        # Draw and add this layer to the layers group.
        layers.add(
            Oval(200, centerY + height / 2, width, height / 2, fill=layerColor,
                 border='black'),
            Rect(200, centerY, width, height, fill=layerColor, align='center'),
            Oval(200, centerY - height / 2, width, height / 2, fill=topColor,
                 border='black')
            )

    # Draw a candle on top of the cake and add it to the layers group.
    layers.add(
        Line(200, top, 200, top - 25, fill='red', lineWidth=4),
        Line(200, top - 25, 200, top - 27),
        Oval(200, top - 27, 5, 10, fill=gradient('yellow', 'red', start='bottom'),
             align='bottom')
        )

def onKeyPress(key):
    # Change the number of layers when the 'up' or 'down' keys are pressed.
    # A cake has at most 10 layers, otherwise the width gets too small.
    if (key == 'up'):
        if (layersCountLabel.value < 10):
            layersCountLabel.value += 1
    elif (key == 'down'):
        if (layersCountLabel.value > 1):
            layersCountLabel.value -= 1

    # Always remove the old layers and draw new ones.
    layers.clear()
    drawCake(layersCountLabel.value)

# Start with the 5 layers already drawn.
drawCake(layersCountLabel.value)
",regular,4
2192,Gary the snail,7.5,"# In this exercise, you will draw the flowers in the sky and then add a spiral
# to Gary's shell in order to complete the scene.

app.background = gradient('turquoise', 'blue', start='top')

def createSkyFlower(x, y, color, startAngle):
    ### Shapes can be drawn around a circle by placing their centers at the
    ### endpoint of a line which rotates after placing each shape.

    # This line's x1, y1 can be used to place the petals.
    petalPosition = Line(x, y - 35, x, y + 35)
    petalPosition.rotateAngle = startAngle

    # Create 5 petals placed at 72 degree intervals around a central point.
    ### Place Your Code Here ###

    # Removes the line.
    petalPosition.visible = False

createSkyFlower(350, 50, 'paleGreen', 5)
createSkyFlower(210, 115, 'mediumAquamarine', 15)
createSkyFlower(100, 200, 'mediumSeaGreen', -10)
createSkyFlower(50, 50, 'paleGreen', -10)

# Spongebob's house
Star(330, 170, 40, 9, fill=gradient(rgb(188, 226, 66), rgb(23, 133, 23)),
     border='seaGreen', roundness=50)
Oval(370, 280, 80, 120, fill=gradient('orange', 'orangeRed', start='left'),
     border='brown', align='right-bottom')
Line(360, 180, 290, 220, fill='brown')
Line(370, 220, 300, 260, fill='brown')
Line(300, 180, 370, 220, fill='brown')
Line(290, 220, 360, 260, fill='brown')

# Spongebob's door
Oval(345, 270, 30, 50, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
     border='steelBlue', align='right-bottom')
Oval(343, 266, 25, 45, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
     border='steelBlue', align='right-bottom')

# Spongebob's windows and chimney
Circle(310, 210, 8, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
       border='steelBlue')
Circle(310, 210, 6, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
       border='steelBlue')
Circle(358, 235, 6, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
       border='steelBlue')
Polygon(360, 200, 370, 195, 370, 180, 380, 180, 375, 200, fill='deepSkyBlue',
        border='steelBlue')

# sand
Rect(0, 250, 400, 150, fill=gradient(rgb(200, 251, 220), 'cornSilk', start='top'))

# Gary (the snail)
Oval(60, 295, 100, 20, fill='paleTurquoise', opacity=60, align='top')
slime = Rect(60, 295, 5, 20, fill='paleTurquoise', opacity=60, align='top')
shellSpiral = Polygon(45, 290, 45, 285, fill=None, border='red')
gary = Group(
    Oval(60, 295, 100, 20, fill='skyBlue', align='top'),

    # eye stalks and eyes
    Line(95, 305, 95, 265, fill='skyBlue', lineWidth=5),
    Circle(95, 265, 7, fill=rgb(200, 255, 170), border='black', borderWidth=1),
    Circle(97, 265, 3, border='coral'),
    Line(90, 305, 85, 265, fill='skyBlue', lineWidth=5),
    Circle(85, 265, 7, fill=rgb(200, 255, 170), border='black', borderWidth=1),
    Circle(87, 265, 3, border='coral'),

    # shell
    Oval(78, 312, 55, 65, fill=gradient(rgb(225, 170, 160), 'pink', start='left'),
         border='darkRed', borderWidth=1, rotateAngle=-10, align='right-bottom'),
    Oval(82, 305, 60, 10, border='darkRed', borderWidth=1, align='right-bottom',
         fill=gradient(rgb(255, 170, 160), 'pink', start='left-top')),
    Line(25, 296, 75, 295, fill=gradient(rgb(225, 170, 160), 'pink', start='left'),
         lineWidth=3),
    shellSpiral,
    Line(45, 305, 45, 290, fill=rgb(240, 185, 170), lineWidth=4),

    # spots
    Oval(50, 260, 8, 5, fill='steelBlue'),
    Oval(38, 265, 6, 4, fill='steelBlue', rotateAngle=-30),
    Oval(30, 275, 4, 3, fill='steelBlue', rotateAngle=-60),
    Oval(62, 265, 6, 4, fill='steelBlue', rotateAngle=30),
    Oval(70, 275, 4, 3, fill='steelBlue', rotateAngle=60),

    Polygon(18, 303, 25, 310, 40, 315, 65, 315, 90, 303, fill='skyBlue'),
    Polygon(35, 315, 65, 315, 50, 320, fill='honeydew'),
    Line(27, 303, 73, 303, fill='lightSlateGrey', lineWidth=1),
    Polygon(10, 305, 40, 310, 80, 310, 110, 305, 110, 310, 80, 315, 40, 315,
            10, 310, fill='lightGreen')
    )

def drawSpiral():
    ### A spiral can be created by using a similar trick to what we did for the
    ### sky flowers, just increasing the length of the rotated line every time
    ### we increase its angle. Do that here to create a spiral on the shell!

    # Use this line to create the spiral on the shell.
    spiralLine = Line(45, 285, 45, 295)

    # The spiral will be a polygon of 12 points created in the manner
    # described above.
    # There is no length property for lines but if a line is vertical
    # we can make it longer by simply moving both of the endpoints!

    # First, get the next angle that the line should rotate to.
    ### Place Your Code Here ###

    # For the first 6 points, increase the length of the line by 8.
    ### (HINT: In order to rotate around the center, you need to change
    #          both the y1 and the y2 properties.)
    ### Place Your Code Here ###

    # Set the new angle and add the new point to the spiral.
    ### Place Your Code Here ###

    # Removes the line.
    spiralLine.visible = False

drawSpiral()

def onStep():
    gary.centerX += 1
    slime.width += 1
    if (gary.left >= 400):
        gary.right = 0
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# In this exercise, you will draw the flowers in the sky and then add a spiral
# to Gary's shell in order to complete the scene.

app.background = gradient('turquoise', 'blue', start='top')

def createSkyFlower(x, y, color, startAngle):
    ### Shapes can be drawn around a circle by placing their centers at the
    ### endpoint of a line which rotates after placing each shape.

    # This line's x1, y1 can be used to place the petals.
    petalPosition = Line(x, y - 35, x, y + 35)
    petalPosition.rotateAngle = startAngle

    # Create 5 petals placed at 72 degree intervals around a central point.
    for i in range(5):
        ovalAngle = petalPosition.rotateAngle
        Oval(petalPosition.x1, petalPosition.y1, 30, 50, fill=None, border=color,
             rotateAngle=ovalAngle, opacity=40)

        petalPosition.rotateAngle += 72

    # Removes the line.
    petalPosition.visible = False

createSkyFlower(350, 50, 'paleGreen', 5)
createSkyFlower(210, 115, 'mediumAquamarine', 15)
createSkyFlower(100, 200, 'mediumSeaGreen', -10)
createSkyFlower(50, 50, 'paleGreen', -10)

# Spongebob's house
Star(330, 170, 40, 9, fill=gradient(rgb(188, 226, 66), rgb(23, 133, 23)),
     border='seaGreen', roundness=50)
Oval(370, 280, 80, 120, fill=gradient('orange', 'orangeRed', start='left'),
     border='brown', align='right-bottom')
Line(360, 180, 290, 220, fill='brown')
Line(370, 220, 300, 260, fill='brown')
Line(300, 180, 370, 220, fill='brown')
Line(290, 220, 360, 260, fill='brown')

# Spongebob's door
Oval(345, 270, 30, 50, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
     border='steelBlue', align='right-bottom')
Oval(343, 266, 25, 45, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
     border='steelBlue', align='right-bottom')

# Spongebob's windows and chimney
Circle(310, 210, 8, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
       border='steelBlue')
Circle(310, 210, 6, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
       border='steelBlue')
Circle(358, 235, 6, fill=gradient('lightSkyBlue', 'skyBlue', start='left'),
       border='steelBlue')
Polygon(360, 200, 370, 195, 370, 180, 380, 180, 375, 200, fill='deepSkyBlue',
        border='steelBlue')

# sand
Rect(0, 250, 400, 150, fill=gradient(rgb(200, 251, 220), 'cornSilk', start='top'))

# Gary (the snail)
Oval(60, 295, 100, 20, fill='paleTurquoise', opacity=60, align='top')
slime = Rect(60, 295, 5, 20, fill='paleTurquoise', opacity=60, align='top')
shellSpiral = Polygon(45, 290, 45, 285, fill=None, border='red')
gary = Group(
    Oval(60, 295, 100, 20, fill='skyBlue', align='top'),

    # eye stalks and eyes
    Line(95, 305, 95, 265, fill='skyBlue', lineWidth=5),
    Circle(95, 265, 7, fill=rgb(200, 255, 170), border='black', borderWidth=1),
    Circle(97, 265, 3, border='coral'),
    Line(90, 305, 85, 265, fill='skyBlue', lineWidth=5),
    Circle(85, 265, 7, fill=rgb(200, 255, 170), border='black', borderWidth=1),
    Circle(87, 265, 3, border='coral'),

    # shell
    Oval(78, 312, 55, 65, fill=gradient(rgb(225, 170, 160), 'pink', start='left'),
         border='darkRed', borderWidth=1, rotateAngle=-10, align='right-bottom'),
    Oval(82, 305, 60, 10, border='darkRed', borderWidth=1, align='right-bottom',
         fill=gradient(rgb(255, 170, 160), 'pink', start='left-top')),
    Line(25, 296, 75, 295, fill=gradient(rgb(225, 170, 160), 'pink', start='left'),
         lineWidth=3),
    shellSpiral,
    Line(45, 305, 45, 290, fill=rgb(240, 185, 170), lineWidth=4),

    # spots
    Oval(50, 260, 8, 5, fill='steelBlue'),
    Oval(38, 265, 6, 4, fill='steelBlue', rotateAngle=-30),
    Oval(30, 275, 4, 3, fill='steelBlue', rotateAngle=-60),
    Oval(62, 265, 6, 4, fill='steelBlue', rotateAngle=30),
    Oval(70, 275, 4, 3, fill='steelBlue', rotateAngle=60),

    Polygon(18, 303, 25, 310, 40, 315, 65, 315, 90, 303, fill='skyBlue'),
    Polygon(35, 315, 65, 315, 50, 320, fill='honeydew'),
    Line(27, 303, 73, 303, fill='lightSlateGrey', lineWidth=1),
    Polygon(10, 305, 40, 310, 80, 310, 110, 305, 110, 310, 80, 315, 40, 315,
            10, 310, fill='lightGreen')
    )

def drawSpiral():
    ### A spiral can be created by using a similar trick to what we did for the
    ### sky flowers, just increasing the length of the rotated line every time
    ### we increase its angle. Do that here to create a spiral on the shell!

    # Use this line to create the spiral on the shell.
    spiralLine = Line(45, 285, 45, 295)

    # The spiral will be a polygon of 12 points created in the manner
    # described above.
    for i in range(12):
        # There is no length property for lines but if a line is vertical
        # we can make it longer by simply moving both of the endpoints!

        # First, get the next angle that the line should rotate to.
        nextAngle = spiralLine.rotateAngle + 30

        # For the first 6 points of the spiral, increase the length of
        # the line by 8.
        if (i < 6):
            spiralLine.rotateAngle = 0
            spiralLine.y1 += 4
            spiralLine.y2 -= 4

        # Set the new angle and add the new point to the spiral.
        spiralLine.rotateAngle = nextAngle
        shellSpiral.addPoint(spiralLine.x1, spiralLine.y1)

    # Removes the line.
    spiralLine.visible = False

drawSpiral()

def onStep():
    gary.centerX += 1
    slime.width += 1
    if (gary.left >= 400):
        gary.right = 0
",regular,4
2196,Creative task 2,7.6,# Fill me in!,,creative,30
2197,Creative task 3,7.6,# Fill me in!,,creative,30
2194,American flag,7.6,"app.background = 'lightGrey'

def drawAmericanFlag():
    Rect(50, 100, 300, 200, fill='white')

    # Draw seven red stripes onto the white background.
    stripeHeight = 16
    for i in range(7):
        Rect(50, 100 +  2 * stripeHeight * i, 300, stripeHeight,
             fill=rgb(180, 35, 50))

    # Draws the blue rectangle.
    Rect(50, 100, 135, 112, fill=rgb(60, 60, 110))

    # Draws the longer rows of stars.
    for i in range(5):
        cy = 115 + 20 * i
        Star(65, cy, 4, 5, fill='white')
        Star(85, cy, 4, 5, fill='white')
        Star(105, cy, 4, 5, fill='white')
        Star(125, cy, 4, 5, fill='white')
        Star(145, cy, 4, 5, fill='white')
        Star(165, cy, 4, 5, fill='white')

    # Draws the shorter rows of stars.
    for i in range(4):
        cy = 125 + 20 * i
        Star(75, cy, 4, 5, fill='white')
        Star(95, cy, 4, 5, fill='white')
        Star(115, cy, 4, 5, fill='white')
        Star(135, cy, 4, 5, fill='white')
        Star(155, cy, 4, 5, fill='white')

drawAmericanFlag()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightGrey'

def drawAmericanFlag():
    Rect(50, 100, 300, 200, fill='white')

    # Draw seven red stripes onto the white background.
    stripeHeight = 16
    for i in range(7):
        Rect(50, 100 +  2 * stripeHeight * i, 300, stripeHeight,
             fill=rgb(180, 35, 50))

    # Draws the blue rectangle.
    Rect(50, 100, 135, 112, fill=rgb(60, 60, 110))

    # Draws the longer rows of stars.
    for i in range(5):
        cy = 115 + 20 * i
        Star(65, cy, 4, 5, fill='white')
        Star(85, cy, 4, 5, fill='white')
        Star(105, cy, 4, 5, fill='white')
        Star(125, cy, 4, 5, fill='white')
        Star(145, cy, 4, 5, fill='white')
        Star(165, cy, 4, 5, fill='white')

    # Draws the shorter rows of stars.
    for i in range(4):
        cy = 125 + 20 * i
        Star(75, cy, 4, 5, fill='white')
        Star(95, cy, 4, 5, fill='white')
        Star(115, cy, 4, 5, fill='white')
        Star(135, cy, 4, 5, fill='white')
        Star(155, cy, 4, 5, fill='white')

drawAmericanFlag()
",sample,1
2199,Creative task 5,7.6,# Fill me in!,,creative,30
2200,Collaborative task,7.6,# Fill me in!,,creative,30
2195,Creative task 1,7.6,# Fill me in!,,creative,30
2198,Creative task 4,7.6,# Fill me in!,,creative,30
2204,Tortoise and the hare,8.1.2,"app.stepsPerSecond = 10

def makeBackground():
    Rect(0, 0, 400, 200, fill=gradient('lemonChiffon', 'lightSkyBlue'))
    Arc(200, 105, 117, 125, 270, 180, fill=None, border='gold', borderWidth=8,
        opacity=40)
    Arc(200, 100, 90, 90, 270, 180, fill='gold')
    Rect(0, 100, 400, 300,
         fill=gradient('seaGreen', 'mediumSeaGreen', start='bottom'))

    # finish line
    for i in range (3):
        for j in range(20):
            if ((i + j) % 2 == 0):
                color = 'black'
            else:
                color = 'white'
            Rect(340 + i * 15, 100 + j * 15, 15, 15, fill=color)

makeBackground()

# timer label
Label('Time ', 45, 355, fill='white', size=16)
timer = Label(0, 43, 375, fill='white', size=16)

# Draws the tortoise.
tortoise = Group(
    Polygon(220, 200, 230, 180, 250, 180, 255, 200, fill='darkSeaGreen'),
    Circle(243, 190, 3),
    Rect(175, 210, 15, 8, fill='darkSeaGreen'),
    Rect(210, 210, 15, 8, fill='darkSeaGreen'),
    Polygon(160, 195, 175, 190, 175, 200, fill='darkSeaGreen'),
    Arc(200, 200, 60, 65, 270, 180, fill='saddleBrown'),
    Rect(170, 200, 60, 10, fill='saddleBrown'),
    Circle(170, 205, 5, fill='saddleBrown'),
    Circle(230, 205, 5, fill='saddleBrown')
    )
tortoise.centerX = 50
tortoise.centerY = 150

# Draws the hare.
hare = Group(
    Oval(335, 200, 20, 10, fill='navajoWhite', rotateAngle=70),
    Oval(335, 150, 10, 30, fill='antiqueWhite', rotateAngle=10),
    Oval(325, 150, 10, 30, fill='antiqueWhite', rotateAngle=350),
    Arc(300, 200, 65, 80, 270, 180, fill='antiqueWhite'),
    Circle(330, 170, 15, fill='navajoWhite'),
    Circle (335, 166, 2),
    Circle(345, 166, 1),
    RegularPolygon(342, 172, 2, 3, rotateAngle=60),
    Circle(270, 190, 8, fill='antiqueWhite'),
    Circle(285, 190, 15, fill='navajoWhite'),
    Oval(295, 205, 22, 12, fill='navajoWhite'),
    Oval(320, 200, 20, 10, fill='navajoWhite', rotateAngle=70)
    )
hare.centerX = 50
hare.centerY = 250

def endRace(text):
    Rect(0, 285, 400, 50, fill='salmon')
    Label(text, 200, 310, fill='white', size=30, bold=True)
    app.stop()

def onStep():
    # Increase the timer's value.
    ### Place Your Code Here ###

    # Move the hare by 50 pixels, every 10 steps.
    ### (HINT: Use the mod operator!)
    ### Place Your Code Here ###

    # Move the tortoise by 10 pixels, every 2 steps.
    ### Place Your Code Here ###

    # When the tortoise wins, end the program and display the winner.
    if (tortoise.right >= 380):
        endRace('Tortoise wins!')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 10

def makeBackground():
    Rect(0, 0, 400, 200, fill=gradient('lemonChiffon', 'lightSkyBlue'))
    Arc(200, 105, 117, 125, 270, 180, fill=None, border='gold', borderWidth=8,
        opacity=40)
    Arc(200, 100, 90, 90, 270, 180, fill='gold')
    Rect(0, 100, 400, 300,
         fill=gradient('seaGreen', 'mediumSeaGreen', start='bottom'))

    # finish line
    for i in range (3):
        for j in range(20):
            if ((i + j) % 2 == 0):
                color = 'black'
            else:
                color = 'white'
            Rect(340 + i * 15, 100 + j * 15, 15, 15, fill=color)

makeBackground()

# timer label
Label('Time ', 45, 355, fill='white', size=16)
timer = Label(0, 43, 375, fill='white', size=16)

# Draws the tortoise.
tortoise = Group(
    Polygon(220, 200, 230, 180, 250, 180, 255, 200, fill='darkSeaGreen'),
    Circle(243, 190, 3),
    Rect(175, 210, 15, 8, fill='darkSeaGreen'),
    Rect(210, 210, 15, 8, fill='darkSeaGreen'),
    Polygon(160, 195, 175, 190, 175, 200, fill='darkSeaGreen'),
    Arc(200, 200, 60, 65, 270, 180, fill='saddleBrown'),
    Rect(170, 200, 60, 10, fill='saddleBrown'),
    Circle(170, 205, 5, fill='saddleBrown'),
    Circle(230, 205, 5, fill='saddleBrown')
    )
tortoise.centerX = 50
tortoise.centerY = 150

# Draws the hare.
hare = Group(
    Oval(335, 200, 20, 10, fill='navajoWhite', rotateAngle=70),
    Oval(335, 150, 10, 30, fill='antiqueWhite', rotateAngle=10),
    Oval(325, 150, 10, 30, fill='antiqueWhite', rotateAngle=350),
    Arc(300, 200, 65, 80, 270, 180, fill='antiqueWhite'),
    Circle(330, 170, 15, fill='navajoWhite'),
    Circle (335, 166, 2),
    Circle(345, 166, 1),
    RegularPolygon(342, 172, 2, 3, rotateAngle=60),
    Circle(270, 190, 8, fill='antiqueWhite'),
    Circle(285, 190, 15, fill='navajoWhite'),
    Oval(295, 205, 22, 12, fill='navajoWhite'),
    Oval(320, 200, 20, 10, fill='navajoWhite', rotateAngle=70)
    )
hare.centerX = 50
hare.centerY = 250

def endRace(text):
    Rect(0, 285, 400, 50, fill='salmon')
    Label(text, 200, 310, fill='white', size=30, bold=True)
    app.stop()

def onStep():
    # Increase the timer's value.
    timer.value += 1

    # Move the hare by 50 pixels, every 10 steps.
    if (timer.value % 10 == 0):
        hare.centerX += 50

    # Move the tortoise by 10 pixels, every 2 steps.
    if (timer.value % 2 == 0):
        tortoise.centerX += 10

    # When the tortoise wins, end the program and display the winner.
    if (tortoise.right >= 380):
        endRace('Tortoise wins!')
",regular,1
2206,Expelliarmus,8.1.2,"app.background = 'midnightBlue'
app.counter = 0

def makePillar(cx, coneHeight, coneFill, pillarFill):
    Rect(cx, 175, 45, 200, fill=pillarFill, align='top')
    Oval(cx, 175, 45, 30)
    Polygon(cx - 20, 175, cx + 20, 175, cx, coneHeight, fill=coneFill)

def drawHogwarts():
    for i in range(2):
        cx = 85 - 20 * i
        makePillar(cx, 20 - 10 * i,
                   gradient('black', 'darkSlateGray', start='bottom'),
                   gradient(rgb(40, 50, 50), rgb(20, 70, 70), start='top'))

    for i in range(3):
        cx = 165 + 90 * i
        makePillar(cx, 100, gradient('black', 'darkSlateGray', start='bottom'),
                   gradient(rgb(30, 30, 30), rgb(10, 60, 60), start='top'))

    Rect(140, 220, 205, 120, fill=rgb(40, 65, 65))
    Polygon(345, 220, 390, 240, 390, 340, 345, 340,
            fill=gradient(rgb(40, 65, 65), rgb(10, 60, 60), start='left'))
    for i in range(3):
        cx = 125 + 90 * i
        makePillar(cx, 80, gradient('black', 'grey', start='bottom'),
                   'darkSlateGrey')

drawHogwarts()

Rect(0, 340, 400, 70)

smile = Group(
    Circle(80, 220, 5),
    Circle(80, 219, 5, fill='navajoWhite')
    )
speaking = Circle(80, 223, 5)
harry = Group(
    # face
    Oval(80, 210, 55, 40, fill='navajoWhite'),
    Rect(52, 190, 55, 25, fill='navajoWhite'),
    Circle(65, 210, 13, fill=None, border='black'),
    Circle(95, 210, 13, fill=None, border='black'),
    Line(75, 210, 85, 210),
    Circle(65, 210, 6),
    Circle(95, 210, 6),
    smile,
    speaking,

    # scar and hair
    Line(65, 185, 70, 190, fill='tomato'),
    Line(70, 190, 65, 195, fill='tomato'),
    Line(65, 195, 70, 200, fill='tomato'),
    Arc(80, 190, 55, 40, 270, 180, fill='maroon'),
    Polygon(52, 190, 55, 205, 65, 185, 80, 200, 80, 190, 85, 205, 95, 190,
            105, 200, 108, 185, 80, 180, fill='maroon'),

    # legs
    Rect(60, 310, 11, 30, fill=rgb(87, 64, 58)),
    Oval(70, 340, 20, 10),
    Rect(85, 310, 11, 30, fill=rgb(87, 64, 58)),
    Oval(95, 340, 20, 10),

    # arms
    Oval(40, 265, 10, 15, fill='navajoWhite', rotateAngle=20),
    Polygon(65, 230, 35, 260, 50, 275, 70, 255),
    Line(125, 265, 180, 250, fill=gradient('darkRed', 'sienna'), lineWidth=4),
    Oval(125, 265, 15, 10, fill='navajoWhite', rotateAngle=30),
    Polygon(90, 235, 125, 255, 120, 275, 90, 250),
    Polygon(65, 230, 90, 230, 105, 310, 45, 310)
    )
speaking.visible = False

magicBursts = Group()

def onMousePress(mouseX, mouseY):
    burst = Group()

    # Draw the magic bursts using a for loop.
    for i in range(5):
        # Alternate the color that is used for the star. The first color used
        # should be red.
        ### Place Your Code Here ###

        burst.add(
            Star(mouseX, mouseY, 25 - i * 5, 200, fill=fillColor, roundness=35)
            )

    magicBursts.add(burst)
    smile.visible = False
    speaking.visible= True

def onMouseRelease(mouseX, mouseY):
    smile.visible = True
    speaking.visible = False

def onStep():
    app.counter += 1

    for magicBurst in magicBursts:
        magicBurst.width += 10
        magicBurst.height += 10

        # Every 10 steps, divide the opacity of every magic burst by 2.
        ### Fix Your Code Here ###
        if (magicBurst.opacity >= 2):
            magicBurst.opacity = 100
        else:
            magicBursts.remove(magicBurst)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'midnightBlue'
app.counter = 0

def makePillar(cx, coneHeight, coneFill, pillarFill):
    Rect(cx, 175, 45, 200, fill=pillarFill, align='top')
    Oval(cx, 175, 45, 30)
    Polygon(cx - 20, 175, cx + 20, 175, cx, coneHeight, fill=coneFill)

def drawHogwarts():
    for i in range(2):
        cx = 85 - 20 * i
        makePillar(cx, 20 - 10 * i,
                   gradient('black', 'darkSlateGray', start='bottom'),
                   gradient(rgb(40, 50, 50), rgb(20, 70, 70), start='top'))

    for i in range(3):
        cx = 165 + 90 * i
        makePillar(cx, 100, gradient('black', 'darkSlateGray', start='bottom'),
                   gradient(rgb(30, 30, 30), rgb(10, 60, 60), start='top'))

    Rect(140, 220, 205, 120, fill=rgb(40, 65, 65))
    Polygon(345, 220, 390, 240, 390, 340, 345, 340,
            fill=gradient(rgb(40, 65, 65), rgb(10, 60, 60), start='left'))
    for i in range(3):
        cx = 125 + 90 * i
        makePillar(cx, 80, gradient('black', 'grey', start='bottom'),
                   'darkSlateGrey')

drawHogwarts()

Rect(0, 340, 400, 70)

smile = Group(
    Circle(80, 220, 5),
    Circle(80, 219, 5, fill='navajoWhite')
    )
speaking = Circle(80, 223, 5)
harry = Group(
    # face
    Oval(80, 210, 55, 40, fill='navajoWhite'),
    Rect(52, 190, 55, 25, fill='navajoWhite'),
    Circle(65, 210, 13, fill=None, border='black'),
    Circle(95, 210, 13, fill=None, border='black'),
    Line(75, 210, 85, 210),
    Circle(65, 210, 6),
    Circle(95, 210, 6),
    smile,
    speaking,

    # scar and hair
    Line(65, 185, 70, 190, fill='tomato'),
    Line(70, 190, 65, 195, fill='tomato'),
    Line(65, 195, 70, 200, fill='tomato'),
    Arc(80, 190, 55, 40, 270, 180, fill='maroon'),
    Polygon(52, 190, 55, 205, 65, 185, 80, 200, 80, 190, 85, 205, 95, 190,
            105, 200, 108, 185, 80, 180, fill='maroon'),

    # legs
    Rect(60, 310, 11, 30, fill=rgb(87, 64, 58)),
    Oval(70, 340, 20, 10),
    Rect(85, 310, 11, 30, fill=rgb(87, 64, 58)),
    Oval(95, 340, 20, 10),

    # arms
    Oval(40, 265, 10, 15, fill='navajoWhite', rotateAngle=20),
    Polygon(65, 230, 35, 260, 50, 275, 70, 255),
    Line(125, 265, 180, 250, fill=gradient('darkRed', 'sienna'), lineWidth=4),
    Oval(125, 265, 15, 10, fill='navajoWhite', rotateAngle=30),
    Polygon(90, 235, 125, 255, 120, 275, 90, 250),
    Polygon(65, 230, 90, 230, 105, 310, 45, 310)
    )
speaking.visible = False

magicBursts = Group()

def onMousePress(mouseX, mouseY):
    burst = Group()

    # Draw the magic bursts using a for loop.
    for i in range(5):
        # Alternate the color that is used for the star. The first color used
        # should be red.
        if (i % 2 == 0):
            fillColor = 'red'
        else:
            fillColor = 'yellow'

        burst.add(
            Star(mouseX, mouseY, 25 - i * 5, 200, fill=fillColor, roundness=35)
            )

    magicBursts.add(burst)
    smile.visible = False
    speaking.visible= True

def onMouseRelease(mouseX, mouseY):
    smile.visible = True
    speaking.visible = False

def onStep():
    app.counter += 1

    for magicBurst in magicBursts:
        magicBurst.width += 10
        magicBurst.height += 10

        # Every 10 steps, divide the opacity of every magic burst by 2.
        if (app.counter % 10 == 0):
            if (magicBurst.opacity >= 2):
                magicBurst.opacity = magicBurst.opacity / 2
            else:
                magicBursts.remove(magicBurst)
",regular,1
2203,Walk on the beach,8.1.2,"app.background = gradient('cornSilk', 'tan', start='top')

Polygon(30, 400, 275, 365, 400, 400, fill='cornSilk')
Polygon(170, 400, 275, 385, 330, 400, fill='royalBlue')

footsteps = Group()

def drawFootstep(x, y):
    newFootstep = Group(
        Arc(x, y - 5, 22, 40, 220, 280, fill='burlyWood'),
        Polygon(x, y - 5, x - 7, y + 10, x + 7, y + 10, fill='burlyWood'),
        Rect(x, y + 15, 16, 5, fill='burlyWood', align='top'),
        Arc(x, y + 20, 16, 16, 90, 180, fill='burlyWood')
        )

    footsteps.add(newFootstep)

def onMousePress(mouseX, mouseY):
    for footstep in footsteps.children:
        # If the footstep's opacity is greater than 0, integer divide it in half.
        # Otherwise, remove it from the group.
        ### Place Your Code Here ###
        pass

    drawFootstep(mouseX, mouseY)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('cornSilk', 'tan', start='top')

Polygon(30, 400, 275, 365, 400, 400, fill='cornSilk')
Polygon(170, 400, 275, 385, 330, 400, fill='royalBlue')

footsteps = Group()

def drawFootstep(x, y):
    newFootstep = Group(
        Arc(x, y - 5, 22, 40, 220, 280, fill='burlyWood'),
        Polygon(x, y - 5, x - 7, y + 10, x + 7, y + 10, fill='burlyWood'),
        Rect(x, y + 15, 16, 5, fill='burlyWood', align='top'),
        Arc(x, y + 20, 16, 16, 90, 180, fill='burlyWood')
        )

    footsteps.add(newFootstep)

def onMousePress(mouseX, mouseY):
    for footstep in footsteps.children:
        # If the footstep's opacity is greater than 0, integer divide it in half.
        # Otherwise, remove it from the group.
        if (footstep.opacity > 0):
            footstep.opacity = footstep.opacity // 2
        else:
            footsteps.remove(footstep)

    drawFootstep(mouseX, mouseY)
",regular,1
2205,Dory and Marlin,8.1.2,"app.background = gradient('cyan', 'midnightBlue', start='top')

# Marlin (left fish)
RegularPolygon(150, 200, 15, 3, rotateAngle=30,
               fill=gradient('orange', 'darkOrange', start='top'))
Oval(128, 187, 30, 15, rotateAngle=12,
     fill=gradient('orange', 'darkOrange', start='top'))
Oval(118, 200, 56, 30, fill='white')
Oval(115, 200, 50, 30, fill=gradient('orange', 'darkOrange', start='top'))
Oval(110, 200, 40, 30, fill='white')
Oval(105, 200, 30, 30, fill=gradient('orange', 'darkOrange', start='top'))
Circle(100, 197, 5, fill='white')
Circle(99, 196, 3, border='violet', borderWidth=1)
Arc(118, 202, 40, 40, 95, 80, fill='darkOrange', border='black')
Arc(118, 202, 38, 38, 95, 80, fill='darkOrange')
Line(90, 205, 98, 208, lineWidth=0.5)

# Dory (right fish)
Polygon(260, 200, 215, 190, 219, 215, fill='yellow')
Polygon(275, 175, 293, 180, 305, 203, 295, 215, 285, 220, fill='dodgerBlue')
Oval(275, 197, 50, 45, fill='dodgerBlue')
Oval(270, 200, 55, 45, fill='dodgerBlue')
Oval(265, 200, 60, 40, fill='dodgerBlue')
Oval(262, 192, 45, 20, fill='midnightBlue', rotateAngle=350)
Oval(265, 192, 15, 7, fill='dodgerBlue')
Polygon(280, 205, 260, 200, 260, 216, fill='yellow')
Circle(293, 190, 5, fill='white')
Circle(294, 189, 3, border='violet', borderWidth=1)
Arc(297, 197, 20, 20, 150, 75, fill=None, border='darkBlue', borderWidth=0.5)
Arc(297, 196, 19, 19, 145, 85, fill='dodgerBlue')

leftBubble = Circle(125, 200, 75, fill=gradient('lightBlue', 'cornflowerBlue'))
rightBubble = Circle(275, 200, 75, fill=gradient('lightBlue', 'cornflowerBlue'))

def onMouseMove(mouseX, mouseY):
    if (mouseX > 0):
        # The opacity of the right bubble should be mouseX divided by 4.
        ### Place Your Code Here ###

        # Set the left bubble's opacity using the right bubble's opacity.
        ### Place Your Code Here ###

        # The width and height of the right bubble should be mouseX divided by 2.
        ### Place Your Code Here ###

        # Set the width and height of the left bubble using the right
        # bubble's width and height.
        ### Place Your Code Here ###

        # Re-center the bubbles.
        leftBubble.centerY = 200
        leftBubble.right = 200
        rightBubble.centerY = 200
        rightBubble.left = 200
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('cyan', 'midnightBlue', start='top')

# Marlin (left fish)
RegularPolygon(150, 200, 15, 3, rotateAngle=30,
               fill=gradient('orange', 'darkOrange', start='top'))
Oval(128, 187, 30, 15, rotateAngle=12,
     fill=gradient('orange', 'darkOrange', start='top'))
Oval(118, 200, 56, 30, fill='white')
Oval(115, 200, 50, 30, fill=gradient('orange', 'darkOrange', start='top'))
Oval(110, 200, 40, 30, fill='white')
Oval(105, 200, 30, 30, fill=gradient('orange', 'darkOrange', start='top'))
Circle(100, 197, 5, fill='white')
Circle(99, 196, 3, border='violet', borderWidth=1)
Arc(118, 202, 40, 40, 95, 80, fill='darkOrange', border='black')
Arc(118, 202, 38, 38, 95, 80, fill='darkOrange')
Line(90, 205, 98, 208, lineWidth=0.5)

# Dory (right fish)
Polygon(260, 200, 215, 190, 219, 215, fill='yellow')
Polygon(275, 175, 293, 180, 305, 203, 295, 215, 285, 220, fill='dodgerBlue')
Oval(275, 197, 50, 45, fill='dodgerBlue')
Oval(270, 200, 55, 45, fill='dodgerBlue')
Oval(265, 200, 60, 40, fill='dodgerBlue')
Oval(262, 192, 45, 20, fill='midnightBlue', rotateAngle=350)
Oval(265, 192, 15, 7, fill='dodgerBlue')
Polygon(280, 205, 260, 200, 260, 216, fill='yellow')
Circle(293, 190, 5, fill='white')
Circle(294, 189, 3, border='violet', borderWidth=1)
Arc(297, 197, 20, 20, 150, 75, fill=None, border='darkBlue', borderWidth=0.5)
Arc(297, 196, 19, 19, 145, 85, fill='dodgerBlue')

leftBubble = Circle(125, 200, 75, fill=gradient('lightBlue', 'cornflowerBlue'))
rightBubble = Circle(275, 200, 75, fill=gradient('lightBlue', 'cornflowerBlue'))

def onMouseMove(mouseX, mouseY):
    if (mouseX > 0):
        # The opacity of the right bubble should be mouseX divided by 4.
        rightBubble.opacity = mouseX / 4

        # Set the left bubble's opacity using the right bubble's opacity.
        leftBubble.opacity = 100 - rightBubble.opacity

        # The width and height of the right bubble should be mouseX divided by 2.
        rightBubble.width = mouseX / 2
        rightBubble.height = mouseX / 2

        # Set the width and height of the left bubble using the right
        # bubble's width and height.
        leftBubble.width = 200 - rightBubble.width
        leftBubble.height = 200 - rightBubble.height

        # Re-center the bubbles.
        leftBubble.centerY = 200
        leftBubble.right = 200
        rightBubble.centerY = 200
        rightBubble.left = 200
",regular,1
2211,Compass,8.1.4,"app.background = rgb(60, 60, 60)

# ring
Circle(200, 200, 110, fill=None, border='ghostWhite', borderWidth=3, dashes=(40, 1))
Circle(200, 200, 145, fill=None, border='ghostWhite', borderWidth=3, dashes=(80, 1))

# compass labels
Label('N', 200, 75, fill='ghostWhite', size=30)
Label('S', 200, 325, fill='ghostWhite', size=30)
Label('W', 75, 200, fill='ghostWhite', size=30)
Label('E', 325, 200, fill='ghostWhite', size=30)

# fancy star background
Star(200, 200, 100, 12, fill='ghostWhite', roundness=20)
Star(200, 200, 100, 12, fill=app.background, roundness=10)
Star(200, 200, 100, 12, fill='ghostWhite', roundness=5)

# Create the needle as a line with the arrowEnd equal to True.
### Fix Your Code Here ###
# needle =

def onMouseMove(mouseX, mouseY):
    # Get the angle between the point (200, 200) and the current mouse position.
    ### Fix Your Code Here ###
    # angle =

    # Use getPointInDir function to get the newX2, and newY2 values for the needle.
    ### (HINT: You should use the angle you calculated above, and the distance
    #          should be 80.)
    ### Fix Your Code Here ###
    # newX2, newY2 =

    # Set the needle's x2 and y2 to the values calculated above.
    needle.x2 = newX2
    needle.y2 = newY2
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(60, 60, 60)

# ring
Circle(200, 200, 110, fill=None, border='ghostWhite', borderWidth=3, dashes=(40, 1))
Circle(200, 200, 145, fill=None, border='ghostWhite', borderWidth=3, dashes=(80, 1))

# compass labels
Label('N', 200, 75, fill='ghostWhite', size=30)
Label('S', 200, 325, fill='ghostWhite', size=30)
Label('W', 75, 200, fill='ghostWhite', size=30)
Label('E', 325, 200, fill='ghostWhite', size=30)

# fancy star background
Star(200, 200, 100, 12, fill='ghostWhite', roundness=20)
Star(200, 200, 100, 12, fill=app.background, roundness=10)
Star(200, 200, 100, 12, fill='ghostWhite', roundness=5)

# Create the needle as a line with the arrowEnd equal to True.
needle = Line(200, 200, 200, 120, fill='crimson', lineWidth=8, arrowEnd=True)

def onMouseMove(mouseX, mouseY):
    # Get the angle between the point (200, 200) and the current mouse position.
    angle = angleTo(200, 200, mouseX, mouseY)

    # Use getPointInDir function to get the newX2, and newY2 values for the needle.
    newX2, newY2 = getPointInDir(200, 200, angle, 80)

    # Set the needle's x2 and y2 to the values calculated above.
    needle.x2 = newX2
    needle.y2 = newY2
",regular,1
2210,Flower planting,8.1.4,"app.background = gradient('paleTurquoise', 'lightCyan', 'aliceBlue', start='top')
app.flowerCount = 0

earth = Circle(200, 200, 70, fill=gradient('mediumAquamarine', 'mediumSeaGreen'))

text = Label('Plant some flowers!', 200, 360, fill='seaGreen', size=18, bold=True)

def drawFlower(flowerX, flowerY):
    text.value = 'Flower Planted!'
    Line(200, 200, flowerX, flowerY, fill='seaGreen', lineWidth=5)
    app.flowerCount += 1

    # If app.flowerCount is even, draw a orange star.
    # Otherwise draw a lightPink one.
    ### (HINT: Use mod to check if a number is even.)
    ### Place Your Code Here ###

    Circle(flowerX, flowerY, 8, fill='gold')

def onMousePress(mouseX, mouseY):
    # If the distance between the mouse position and the center of the canvas
    # is less than 120 but larger than 70, draw the flower! Otherwise, change
    # the text value.
    ### Place Your Code Here ###

    earth.toFront()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('paleTurquoise', 'lightCyan', 'aliceBlue', start='top')
app.flowerCount = 0

earth = Circle(200, 200, 70, fill=gradient('mediumAquamarine', 'mediumSeaGreen'))

text = Label('Plant some flowers!', 200, 360, fill='seaGreen', size=18, bold=True)

def drawFlower(flowerX, flowerY):
    text.value = 'Flower Planted!'
    Line(200, 200, flowerX, flowerY, fill='seaGreen', lineWidth=5)
    app.flowerCount += 1

    # If app.flowerCount is even, draw a orange star.
    # Otherwise draw a lightPink one.
    if (app.flowerCount % 2 == 0):
        Star(flowerX, flowerY, 20, 7, fill='orange', roundness=75)
    else:
        Star(flowerX, flowerY, 20, 7, fill='lightPink', roundness=75)

    Circle(flowerX, flowerY, 8, fill='gold')

def onMousePress(mouseX, mouseY):
    # If the distance between the mouse position and the center of the canvas
    # is less than 120 but larger than 70, draw the flower! Otherwise, change
    # the text value.
    dist = distance(mouseX, mouseY, 200, 200)
    if ((dist < 120) and (dist > 70)):
        drawFlower(mouseX, mouseY)
    elif (dist >= 120):
        text.value = 'Flowers cannot grow that tall!'
    else:
        text.value = 'Flowers cannot be planted inside the earth!'

    earth.toFront()
",regular,2
2209,Circle writing,8.1.4,"app.nextAngle = 0
app.radius = 140
app.circleFull = False

# circles
Circle(200, 200, 180, fill=None, border='seaGreen', borderWidth=12)
Circle(200, 200, 160, fill='seaGreen')
Circle(200, 200, 90, fill='white')

# center image
Circle(235, 215, 10, fill=None, border='seaGreen', borderWidth=5)
Arc(200, 200, 70, 70, 90, 180, fill='seaGreen')
Line(170, 235, 230, 235, fill='seaGreen', lineWidth=5)
Oval(196, 180, 15, 20, fill='seaGreen', rotateAngle=320)
Oval(204, 180, 15, 20, fill='seaGreen', rotateAngle=40)

def onKeyPress(key):
    # If the circles are not full, draw the text in a ring around the canvas.
    # Use the getPointInDir function with app radius and nextAngle to get
    # the nextX, and nextY for the label.
    if (app.circleFull == False):
        app.nextAngle += 10

        ### Fix Your Code Here ###
        nextX, nextY = getPointInDir(200, 50, 100, 10)

        # Draws the label in the correct position.
        Label(key, nextX, nextY, fill='white', size=20, bold=True,
              rotateAngle=app.nextAngle)

    # Gets the location of our next ring of words unless the rings are full.
    if (app.nextAngle == 360):
        if (app.radius > 115):
            app.nextAngle = 0
            app.radius -= 25
        else:
            app.circleFull = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.nextAngle = 0
app.radius = 140
app.circleFull = False

# circles
Circle(200, 200, 180, fill=None, border='seaGreen', borderWidth=12)
Circle(200, 200, 160, fill='seaGreen')
Circle(200, 200, 90, fill='white')

# center image
Circle(235, 215, 10, fill=None, border='seaGreen', borderWidth=5)
Arc(200, 200, 70, 70, 90, 180, fill='seaGreen')
Line(170, 235, 230, 235, fill='seaGreen', lineWidth=5)
Oval(196, 180, 15, 20, fill='seaGreen', rotateAngle=320)
Oval(204, 180, 15, 20, fill='seaGreen', rotateAngle=40)

def onKeyPress(key):
    # If the circles are not full, draw the text in a ring around the canvas.
    # Use the getPointInDir function with app radius and nextAngle to get
    # the nextX, and nextY for the label.
    if (app.circleFull == False):
        app.nextAngle += 10

        nextX, nextY = getPointInDir(200, 200, app.nextAngle, app.radius)

        # Draws the label in the correct position.
        Label(key, nextX, nextY, fill='white', size=20, bold=True,
              rotateAngle=app.nextAngle)

    # Gets the location of our next ring of words unless the rings are full.
    if (app.nextAngle == 360):
        if (app.radius > 115):
            app.nextAngle = 0
            app.radius -= 25
        else:
            app.circleFull = True
",regular,2
2207,Fancy watch,8.1.4,"app.background = 'dodgerBlue'

# watch band
Rect(200, 200, 145, 420, border='black', align='center')
Oval(200, 40, 180, 40, fill='gold', border='black')
Oval(200, 360, 180, 40, fill='gold', border='black')
Circle(200, 200, 165, fill=gradient('white', 'lightGrey', start='left'),
       border='black', borderWidth=8)
Arc(200, 200, 225, 225, 45, 270,
    fill=gradient('lightGrey', 'white', start='left'))
Arc(200, 200, 225, 225, 315, 90,
    fill=gradient('gainsboro', 'silver', start='right-top'))

def makeWatch(centerX, centerY, tickSmallRadius, tickLargeRadius, outerRadius):
    # Draw a line for each second hand tick on the watch.
    # There should be 60 ticks in total, all equally spaced apart.
    ### Place Your Code Here ###

    # Every fifth tick should be longer.
    ### Place Your Code Here ###

    # Then get the appropriate points and draw the tick.
    ### (HINT: Use getPointInDir to get the start and end points of each tick.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'dodgerBlue'

# watch band
Rect(200, 200, 145, 420, border='black', align='center')
Oval(200, 40, 180, 40, fill='gold', border='black')
Oval(200, 360, 180, 40, fill='gold', border='black')
Circle(200, 200, 165, fill=gradient('white', 'lightGrey', start='left'),
       border='black', borderWidth=8)
Arc(200, 200, 225, 225, 45, 270,
    fill=gradient('lightGrey', 'white', start='left'))
Arc(200, 200, 225, 225, 315, 90,
    fill=gradient('gainsboro', 'silver', start='right-top'))

def makeWatch(centerX, centerY, tickSmallRadius, tickLargeRadius, outerRadius):
    # Draw a line for each second hand tick on the watch.
    # There should be 60 ticks in total, all equally spaced apart.
    for i in range(60):
        angle = i * 6

        # Every fifth tick should be longer.
        if (i % 5 == 0):
            innerRadius = tickSmallRadius
        else:
            innerRadius = tickLargeRadius

        # Then get the appropriate points and draw the tick.
        innerX, innerY = getPointInDir(centerX, centerY, angle, innerRadius)
        outerX, outerY = getPointInDir(centerX, centerY, angle, outerRadius)
        Line(innerX, innerY, outerX, outerY)
",regular,3
2208,Make cones,8.1.4,"app.background = 'black'

lines = Group()
Circle(200, 200, 125, fill=None, border='lime')

def makeCone(numberOfLines):
    stepAngle = 360 / numberOfLines
    for i in range(numberOfLines):
        # Define the angle variable so it equals 'i' times the stepAngle.
        ### Fix Your Code Here ###
        angle = randrange(0, 360)

        # Define the getPointInDir function 'centered' so it uses a radius of 125.
        ### Fix Your Code Here ###
        x1, y1 = getPointInDir(200, 200, angle, 25)

        # Adds a new line to the group lines using the variables defined.
        lines.add(
            Line(x1, y1, 200, 200, fill='lime')
            )

def onMouseMove(mouseX, mouseY):
    # Loop through each line in the group lines and set their x2, y2 to the
    # mouseX, mouseY.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

lines = Group()
Circle(200, 200, 125, fill=None, border='lime')

def makeCone(numberOfLines):
    stepAngle = 360 / numberOfLines
    for i in range(numberOfLines):
        # Define the angle variable so it equals 'i' times the stepAngle.
        angle = i * stepAngle

        # Define the getPointInDir function 'centered' so it uses a radius of 125.
        x1, y1 = getPointInDir(200, 200, angle, 125)

        # Adds a new line to the group lines using the variables defined.
        lines.add(
            Line(x1, y1, 200, 200, fill='lime')
            )

def onMouseMove(mouseX, mouseY):
    # Loop through each line in the group lines and set their x2, y2 to the
    # mouseX, mouseY.
    for line in lines.children:
        line.x2 = mouseX
        line.y2 = mouseY
",regular,1
2216,Snowy snowman,8.2.2,"app.background = gradient('skyBlue', 'lightBlue', 'skyBlue', start='top')

# fallen snow
Oval(60, 360, 300, 200, fill=gradient('white', 'snow', 'white'))
Oval(180, 400, 300, 200, fill=gradient('white', 'snow', 'white'))
Oval(350, 380, 300, 200, fill=gradient('white', 'snow', 'white'))

# snowman arms
Line(100, 220, 120, 210, fill='saddleBrown')
Line(60, 220, 40, 210, fill='saddleBrown')
Line(114, 212, 116, 205, fill='saddleBrown')
Line(47, 212, 50, 205, fill='saddleBrown')

# head and body
Circle(80, 195, 20, fill=gradient('white', 'snow', 'white'))
Circle(80, 220, 25, fill=gradient('white', 'snow', 'white'))
Circle(80, 245, 30, fill=gradient('white', 'snow', 'white'))

# buttons
Circle(80, 220, 5)
Circle(80, 245, 5)

# face
RegularPolygon(80, 200, 5, 3, fill='orange')
Circle(75, 190, 3)
Circle(85, 190, 3)
Rect(80, 185, 20, 30, fill=gradient('black', 'gray', start='top'),
     align='bottom')
Rect(80, 185, 30, 10, align='bottom')
RegularPolygon(94, 173, 6, 3, fill='green')
Circle(89, 177, 3, fill='red')

def onMousePress(mouseX, mouseY):
    # Define the random variables to be used to create a new snowflake.
    ### (HINT: Make sure to define them in the order radius, point,
    #          roundness, and then opacity so that the autograder grades
    #          properly!)
    ### (HINT: The radius is between 6-12, points is between 8-20, roundness is
    #          between 0-80, and opacity is between 60-100 (all inclusive).)
    ### Place Your Code Here ###

    # Use the variables to create a new snowflake.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('skyBlue', 'lightBlue', 'skyBlue', start='top')

# fallen snow
Oval(60, 360, 300, 200, fill=gradient('white', 'snow', 'white'))
Oval(180, 400, 300, 200, fill=gradient('white', 'snow', 'white'))
Oval(350, 380, 300, 200, fill=gradient('white', 'snow', 'white'))

# snowman arms
Line(100, 220, 120, 210, fill='saddleBrown')
Line(60, 220, 40, 210, fill='saddleBrown')
Line(114, 212, 116, 205, fill='saddleBrown')
Line(47, 212, 50, 205, fill='saddleBrown')

# head and body
Circle(80, 195, 20, fill=gradient('white', 'snow', 'white'))
Circle(80, 220, 25, fill=gradient('white', 'snow', 'white'))
Circle(80, 245, 30, fill=gradient('white', 'snow', 'white'))

# buttons
Circle(80, 220, 5)
Circle(80, 245, 5)

# face
RegularPolygon(80, 200, 5, 3, fill='orange')
Circle(75, 190, 3)
Circle(85, 190, 3)
Rect(80, 185, 20, 30, fill=gradient('black', 'gray', start='top'),
     align='bottom')
Rect(80, 185, 30, 10, align='bottom')
RegularPolygon(94, 173, 6, 3, fill='green')
Circle(89, 177, 3, fill='red')

def onMousePress(mouseX, mouseY):
    # Define the random variables to be used to create a new snowflake.
    radius = randrange(6, 13)
    points = randrange(8, 21)
    roundness = randrange(0, 81)
    opacity = randrange(60, 101)

    # Use the variables to create a new snowflake.
    Star(mouseX, mouseY, radius, points, fill=gradient('white', 'snow', 'white'),
         roundness=roundness, opacity=opacity)
",regular,1
2213,Ripples,8.2.2,"app.background = 'lightCyan'
app.stepsPerSecond = 20
app.steps = 0

ripples = Group()

def onStep():
    # Create a ripple with random x and y center, and add it to ripples group.
    ### Place Your Code Here ###

    # Goes through each ripple and makes the border decrease and the ripple expand.
    for ripple in ripples.children:
        ripple.borderWidth -= 2
        ripple.radius += 5

        # If the ripple fades out, remove it.
        if (ripple.borderWidth <= 0):
            ripples.remove(ripple)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightCyan'
app.stepsPerSecond = 20
app.steps = 0

ripples = Group()

def onStep():
    # Create a ripple with random x and y center, and add it to ripples group.
    randX = randrange(0, 400)
    randY = randrange(0, 400)
    ripples.add(
        Circle(randX, randY, 5, fill=None, border='lightBlue', borderWidth=20)
        )

    # Goes through each ripple and makes the border decrease and the ripple expand.
    for ripple in ripples.children:
        ripple.borderWidth -= 2
        ripple.radius += 5

        # If the ripple fades out, remove it.
        if (ripple.borderWidth <= 0):
            ripples.remove(ripple)
",regular,1
2212,Strange machine,8.2.2,"app.stepsPerSecond = 5
app.nextRadius = 0

Rect(0, 0, 400, 400)

def onStep():
    if (app.nextRadius < 200):
        # Increases the radius by 5.
        app.nextRadius += 5

        # Define these variables to generate new random values for the next
        # circle. Borders are less than 50 and dash values are less than 100.
        ### (HINT: redGreen is used in an rgb so it can't be bigger than 255!)
        ### Fix Your Code Here ###
        redGreen = 0
        newBorderWidth = 2
        dashWidth = 2
        dashSpace = 2

        # Draws the next circle with the values generated above.
        Circle(200, 200, app.nextRadius, fill=None,
               border=rgb(redGreen, 255 - redGreen, 255),
               borderWidth=newBorderWidth, dashes=(dashWidth, dashSpace))
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 5
app.nextRadius = 0

Rect(0, 0, 400, 400)

def onStep():
    if (app.nextRadius < 200):
        # Increases the radius by 5.
        app.nextRadius += 5

        # Define these variables to generate new random values for the next
        # circle. Borders are less than 50 and dash values are less than 100.
        redGreen = randrange(0, 256)
        newBorderWidth = randrange(0, 50)
        dashWidth = randrange(0, 100)
        dashSpace = randrange(0, 100)

        # Draws the next circle with the values generated above.
        Circle(200, 200, app.nextRadius, fill=None,
               border=rgb(redGreen, 255 - redGreen, 255),
               borderWidth=newBorderWidth, dashes=(dashWidth, dashSpace))
",regular,1
2215,Sunny meadow,8.2.2,"app.background = gradient('lightSkyBlue', 'skyBlue')

# sun and grass
Star(0, 0, 70, 60, fill='yellow', roundness=40)
Circle(0, 0, 55, fill=gradient('yellow', 'khaki'))
Rect(0, 150, 400, 250, fill=gradient('yellowGreen', 'forestGreen', start='top'))

Label('Flower count:', 340, 20, align='right')
flowerCount = Label(0, 350, 20, align='left')

def drawFlower(x, y, size, color):
    # stem and petals
    Line(x, y, x, y + 2 * size, fill='mediumSeaGreen')
    Star(x, y, size, 12, fill=color)

    # Changes the fill of the center part of the flower depending on the petals.
    if (color == 'yellow'):
        innerFill = 'peru'
    elif (color == 'lightCyan'):
        innerFill = 'skyBlue'
    elif (color == 'white'):
        innerFill = 'pink'
    Circle(x, y, size // 2, fill=innerFill)

def onStep():
    # As long as there aren't too many flowers, make another.
    if (flowerCount.value < 175):
        # Get the random position of the flower. It can't be higher than the
        # grass and the lowest point it can be is a y value of 390.
        ### Fix Your Code Here ###
        flowerX = 200
        flowerY = 350

        # Makes the flower size bigger the lower it is on the canvas.
        size = 2 * flowerY // 100

        # Randomly define pickColor to a value between 0 and 100 (excluding
        # 100). If it is less than 60, set the color to yellow, if it is
        # between 60 and 80 set it to lightCyan, and white otherwise.
        ### Fix Your Code Here ###
        # pickColor =
        color = 'yellow'

        drawFlower(flowerX, flowerY, size, color)
        flowerCount.value += 1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightSkyBlue', 'skyBlue')

# sun and grass
Star(0, 0, 70, 60, fill='yellow', roundness=40)
Circle(0, 0, 55, fill=gradient('yellow', 'khaki'))
Rect(0, 150, 400, 250, fill=gradient('yellowGreen', 'forestGreen', start='top'))

Label('Flower count:', 340, 20, align='right')
flowerCount = Label(0, 350, 20, align='left')

def drawFlower(x, y, size, color):
    # stem and petals
    Line(x, y, x, y + 2 * size, fill='mediumSeaGreen')
    Star(x, y, size, 12, fill=color)

    # Changes the fill of the center part of the flower depending on the petals.
    if (color == 'yellow'):
        innerFill = 'peru'
    elif (color == 'lightCyan'):
        innerFill = 'skyBlue'
    elif (color == 'white'):
        innerFill = 'pink'
    Circle(x, y, size // 2, fill=innerFill)

def onStep():
    # As long as there aren't too many flowers, make another.
    if (flowerCount.value < 175):
        # Get the random position of the flower. It can't be higher than the
        # grass and the lowest point it can be is a y value of 390.
        flowerX = randrange(0, 400)
        flowerY = randrange(150, 391)

        # Makes the flower size bigger the lower it is on the canvas.
        size = 2 * flowerY // 100

        # Randomly define pickColor to a value between 0 and 100 (excluding
        # 100). If it is less than 60, set the color to yellow, if it is
        # between 60 and 80 set it to lightCyan, and white otherwise.
        pickColor = randrange(0, 100)
        if (pickColor < 60):
            color = 'yellow'
        elif (pickColor < 80):
            color = 'lightCyan'
        else:
            color = 'white'

        drawFlower(flowerX, flowerY, size, color)
        flowerCount.value += 1
",regular,2
2214,Barriers,8.2.2,"app.background = gradient('mediumSlateBlue', 'darkBlue', start='bottom')
app.stepsPerSecond = 30

Label('Barriers!', 330, 20, fill='white', size=30, bold=True)
Label('Score: ', 340, 45, fill='white', size=18, bold=True)
scoreLabel = Label(0, 380, 45, fill='white', size=18, bold=True)
Label('Move the mouse to avoid barriers', 20, 20, fill='white', align='left')

gameOverText = Group(
    Rect(200, 200, 300, 125, fill='aliceBlue', opacity=75, align='center'),
    Label('Game Over', 200, 175, fill='orangeRed', size=48, bold=True),
    Label('Press any key to restart', 200, 225, fill='orangeRed', size=20)
    )
gameOverText.visible = False

barrier = Group(
    Rect(-400, 0, 425, 25, fill=gradient('orange', 'red', start='top')),
    Rect(100, 0, 400, 25, fill=gradient('orange', 'red', start='top'))
    )
barrier.dy = 6
barrier.maxDy = 12

player = RegularPolygon(200, 300, 25, 3, fill='white', border='mediumSlateBlue')

def nextBarrier():
    # Move the barrier to the top and position the gap randomly with an x
    # coordinate somewhere between 50 and 350 (inclusive).
    ### Place Your Code Here ###

    # Then increase the number of points of the player.
    ### Place Your Code Here ###
    pass

def newGame():
    gameOverText.visible = False
    scoreLabel.value = 0
    nextBarrier()
    barrier.dy = 6
    player.points = 3

    app.paused = False

def moveBarrier():
    # Moves the barrier down with wraparound.
    barrier.top += barrier.dy
    if (barrier.top >= 400):
        scoreLabel.value += 1

        # If we wraparound, increases speed until we reach max speed.
        if (barrier.dy < barrier.maxDy):
            barrier.dy += 1
        nextBarrier()

def onMouseMove(mouseX, mouseY):
    # When the game is not over, sets the player's center to the current mouse
    # position.
    if (gameOverText.visible == False):
        player.centerX = mouseX
        player.centerY = mouseY

def onKeyPress(key):
    # When the game is over, starts the game again.
    if (gameOverText.visible == True):
        newGame()

def onStep():
    # If the game is not over, move the barrier.
    ### (HINT: The gameOverText is only visible when the game is over.)
    ### Place Your Code Here ###

    # End the game if the player hits the barrier.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('mediumSlateBlue', 'darkBlue', start='bottom')
app.stepsPerSecond = 30

Label('Barriers!', 330, 20, fill='white', size=30, bold=True)
Label('Score: ', 340, 45, fill='white', size=18, bold=True)
scoreLabel = Label(0, 380, 45, fill='white', size=18, bold=True)
Label('Move the mouse to avoid barriers', 20, 20, fill='white', align='left')

gameOverText = Group(
    Rect(200, 200, 300, 125, fill='aliceBlue', opacity=75, align='center'),
    Label('Game Over', 200, 175, fill='orangeRed', size=48, bold=True),
    Label('Press any key to restart', 200, 225, fill='orangeRed', size=20)
    )
gameOverText.visible = False

barrier = Group(
    Rect(-400, 0, 425, 25, fill=gradient('orange', 'red', start='top')),
    Rect(100, 0, 400, 25, fill=gradient('orange', 'red', start='top'))
    )
barrier.dy = 6
barrier.maxDy = 12

player = RegularPolygon(200, 300, 25, 3, fill='white', border='mediumSlateBlue')

def nextBarrier():
    # Move the barrier to the top and position the gap randomly with an x
    # coordinate somewhere between 50 and 350 (inclusive).
    barrier.bottom = 0
    barrier.centerX = randrange(50, 351)

    # Then increase the number of points of the player.
    player.points += 1

def newGame():
    gameOverText.visible = False
    scoreLabel.value = 0
    nextBarrier()
    barrier.dy = 6
    player.points = 3

    app.paused = False

def moveBarrier():
    # Moves the barrier down with wraparound.
    barrier.top += barrier.dy
    if (barrier.top >= 400):
        scoreLabel.value += 1

        # If we wraparound, increases speed until we reach max speed.
        if (barrier.dy < barrier.maxDy):
            barrier.dy += 1
        nextBarrier()

def onMouseMove(mouseX, mouseY):
    # When the game is not over, sets the player's center to the current mouse
    # position.
    if (gameOverText.visible == False):
        player.centerX = mouseX
        player.centerY = mouseY

def onKeyPress(key):
    # When the game is over, starts the game again.
    if (gameOverText.visible == True):
        newGame()

def onStep():
    # If the game is not over, move the barrier.
    if (gameOverText.visible == False):
        moveBarrier()

        # End the game if the player hits the barrier.
        if (player.hitsShape(barrier) == True):
            gameOverText.visible = True
            app.paused = True
",regular,2
2217,Tumbleweed,8.2.2,"app.background = gradient('skyBlue', 'orange', start='top')
app.stepsPerSecond = 40

# background
Rect(0, 175, 400, 225,
     fill=gradient(rgb(235, 185, 40), rgb(255, 240, 0), start='top'))
Polygon(0, 175, 150, 175, 50, 100, fill=rgb(235, 185, 0))
Polygon(210, 175, 400, 175, 300, 100, fill=rgb(215, 155, 60))
Polygon(50, 175, 190, 175, 130, 120, fill=rgb(255, 235, 60))

# road
Polygon(0, 350, 0, 400, 400, 400, 400, 350, 210, 175, 190, 175, fill='grey')
Line(200, 175, 200, 400, fill=gradient('grey', 'silver', start='top'),
     lineWidth=10, dashes=True)

sandStorm = Group()
for i in range(10):
    sandStorm.add(
        Circle(randrange(-300, 450), randrange(25, 300), 1, fill='khaki')
        )

tumble = Group(Circle(200, 250, 20, fill='tan'))
tumble.dy = -5

def createTumbleweed():
    # A tumbleweed is drawn by creating a bunch of oval borders with varying
    # properties.
    for i in range(45):
        # Get a random position within 5 pixels of the point (200, 250) in
        # either direction.
        ### Place Your Code Here ###
        cx = 0
        cy = 0

        # Pick a random red and use that to find the green and blue.
        ### (HINT: The red should be between 180 and 215, inclusive.)
        ### (HINT: There's a simple relationship between the red and the blue
        #          and green. Use the Inspector to help figure out what it is!)
        ### Place Your Code Here ###
        red = 255
        color = 'black'

        # Gets a random height and uses that to get a width that makes the oval
        # more stretched out.
        width = randrange(10, 85)
        if (width <= 30):
            height = randrange(60, 85)
        else:
            height = randrange(10, 60)

        angle = randrange(0, 360)
        tumble.add(
            Oval(cx, cy, width, height, fill=None, border=color, dashes=(8, 3),
                 rotateAngle=angle)
            )

createTumbleweed()

def onStep():
    # Moves the tumbleweed.
    tumble.centerX += 8
    tumble.centerY += tumble.dy
    tumble.rotateAngle += 8
    tumble.dy += 0.4

    # Wraps the tumbleweed around.
    if (tumble.centerY >= 250):
        tumble.dy = -5
    if (tumble.left >= 400):
        tumble.right = 0

    # Moves the sand.
    for sand in sandStorm.children:
        sand.centerX += 40

        # When the sand moves off the screen, set its right to a random value
        # between -40 and 0, and set the centerY to a random position between
        # 0 and 300 (including the low values, not including the high values).
        ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('skyBlue', 'orange', start='top')
app.stepsPerSecond = 40

# background
Rect(0, 175, 400, 225,
     fill=gradient(rgb(235, 185, 40), rgb(255, 240, 0), start='top'))
Polygon(0, 175, 150, 175, 50, 100, fill=rgb(235, 185, 0))
Polygon(210, 175, 400, 175, 300, 100, fill=rgb(215, 155, 60))
Polygon(50, 175, 190, 175, 130, 120, fill=rgb(255, 235, 60))

# road
Polygon(0, 350, 0, 400, 400, 400, 400, 350, 210, 175, 190, 175, fill='grey')
Line(200, 175, 200, 400, fill=gradient('grey', 'silver', start='top'),
     lineWidth=10, dashes=True)

sandStorm = Group()
for i in range(10):
    sandStorm.add(
        Circle(randrange(-300, 450), randrange(25, 300), 1, fill='khaki')
        )

tumble = Group(Circle(200, 250, 20, fill='tan'))
tumble.dy = -5

def createTumbleweed():
    # A tumbleweed is drawn by creating a bunch of oval borders with varying
    # properties.
    for i in range(45):
        # Get a random position within 5 pixels of the point (200, 250) in
        # either direction.
        cx = 200 + randrange(-5, 6)
        cy = 250 + randrange(-5, 6)

        # Pick a random red and use that to find the green and blue.
        red = randrange(180, 216)
        color = rgb(red, red - 35, red - 70)

        # Gets a random height and uses that to get a width that makes the oval
        # more stretched out.
        width = randrange(10, 85)
        if (width <= 30):
            height = randrange(60, 85)
        else:
            height = randrange(10, 60)

        angle = randrange(0, 360)
        tumble.add(
            Oval(cx, cy, width, height, fill=None, border=color, dashes=(8, 3),
                 rotateAngle=angle)
            )

createTumbleweed()

def onStep():
    # Moves the tumbleweed.
    tumble.centerX += 8
    tumble.centerY += tumble.dy
    tumble.rotateAngle += 8
    tumble.dy += 0.4

    # Wraps the tumbleweed around.
    if (tumble.centerY >= 250):
        tumble.dy = -5
    if (tumble.left >= 400):
        tumble.right = 0

    # Moves the sand.
    for sand in sandStorm.children:
        sand.centerX += 40

        # When the sand moves off the screen, set its right to a random value
        # between -40 and 0, and set the centerY to a random position between
        # 0 and 300 (including the low values, not including the high values).
        if (sand.left >= 400):
            sand.right = randrange(-40, 0)
            sand.centerY = randrange(0, 300)
",regular,3
2218,Shirt design,8.3.2,"app.background = 'pink'

# shirt
Polygon(5, 175, 85, 60, 315, 60, 395, 175, 330, 235, 290, 190, 300, 355,
        100, 355, 110, 190, 70, 237, fill='lavenderBlush')
Arc(200, 60, 95, 70, 90, 180, opacity=10)

# Add a step value of 5 to the loop, and fix the end-value so that the
# last value that the radius gets set to is 95.
### Fix Your Code Here ###
for radius in range(10, 20):
    # Draw a crimson star whenever the radius is a multiple of 10 and
    # a white star otherwise.
    ### (HINT: A number is a multiple of 10 if the units digit is 0!)
    ### (HINT: The radius for both stars should be the same as the radius
    #          of the star below.)
    ### Fix Your Code Here ###
    Star(200, 210, 100 - radius, 6, fill='white')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'pink'

# shirt
Polygon(5, 175, 85, 60, 315, 60, 395, 175, 330, 235, 290, 190, 300, 355,
        100, 355, 110, 190, 70, 237, fill='lavenderBlush')
Arc(200, 60, 95, 70, 90, 180, opacity=10)

# Add a step value of 5 to the loop, and fix the end-value so that the
# last value that the radius gets set to is 95.
for radius in range(10, 100, 5):
    # Draw a crimson star whenever the radius is a multiple of 10 and
    # a white star otherwise.
    if (radius % 10 == 0):
        Star(200, 210, 100 - radius, 6, fill='crimson')
    else:
        Star(200, 210, 100 - radius, 6, fill='white')
",regular,2
2220,Caterpillar,8.3.2,"app.background = gradient('deepSkyBlue', 'lightSkyBlue', start='top')
app.stepsPerSecond = 5

evenPieces = Group()
evenPieces.dy = 1
oddPieces = Group()
oddPieces.dy = 0

worm = Group(evenPieces, oddPieces)

# leaves and twig
Oval(155, 315, 200, 110, rotateAngle=30,
     fill=gradient('mediumSeaGreen', 'darkGreen', start='bottom'))
Oval(420, 200, 175, 90, rotateAngle=-30,
     fill=gradient('mediumSeaGreen', 'darkGreen', start='top'))
Line(0, 250, 400, 250, lineWidth=35,
     fill=gradient('mediumSeaGreen', 'darkGreen', start='top'))

# Fix the for loop so that it draws the head (last circle) and
# colors the caterpillar properly.
### Fix Your Code Here ###
for centerX in range(60, 330, 30):
    # Get a variable that we can use to check whether the next piece should
    # be in the odd group or the even group.
    oddOrEven = (centerX - 60) // 30

    # Add another conditional to create the alternating color pattern.
    ### Fix Your Code Here ###
    if (centerX == 330):
        head = Group(
            Circle(centerX, 200, 20, fill='crimson'),
            Circle(centerX, 200, 3),
            Circle(centerX + 20, 200, 3),
            Line(centerX + 2, 185, centerX + 2, 165),
            Line(centerX + 12, 185, centerX + 12, 165)
            )
        evenPieces.add(head)
    else:
        piece = Group(
            Label('L', centerX, 225, fill='lightGreen', size=18, bold=True),
            Circle(centerX, 200, 20, fill='lightGreen')
            )
        oddPieces.add(piece)

def onStep():
    for shape in evenPieces:
        shape.centerY += evenPieces.dy
    for shape in oddPieces:
        shape.centerY += oddPieces.dy

    # Moves the worm, with wraparound.
    worm.centerX += 2
    if (worm.left >= 400):
        worm.right = 0

    # Adjusts the direction the body parts move.
    evenPieces.dy *= -1
    if (oddPieces.dy == 0):
        oddPieces.dy = 1
    else:
        oddPieces.dy *= -1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('deepSkyBlue', 'lightSkyBlue', start='top')
app.stepsPerSecond = 5

evenPieces = Group()
evenPieces.dy = 1
oddPieces = Group()
oddPieces.dy = 0

worm = Group(evenPieces, oddPieces)

# leaves and twig
Oval(155, 315, 200, 110, rotateAngle=30,
     fill=gradient('mediumSeaGreen', 'darkGreen', start='bottom'))
Oval(420, 200, 175, 90, rotateAngle=-30,
     fill=gradient('mediumSeaGreen', 'darkGreen', start='top'))
Line(0, 250, 400, 250, lineWidth=35,
     fill=gradient('mediumSeaGreen', 'darkGreen', start='top'))

# Fix the for loop so that it draws the head (last circle) and
# colors the caterpillar properly.
for centerX in range(60, 331, 30):
    # This variable is used to check whether the next piece of the caterpillar
    # should be in the odd group or the even group.
    oddOrEven = (centerX - 60) // 30

    # Add a conditional to create the alternating color pattern.
    if (centerX == 330):
        head = Group(
            Circle(centerX, 200, 20, fill='crimson'),
            Circle(centerX, 200, 3),
            Circle(centerX + 20, 200, 3),
            Line(centerX + 2, 185, centerX + 2, 165),
            Line(centerX + 12, 185, centerX + 12, 165)
            )
        evenPieces.add(head)

    elif (oddOrEven % 2 == 0):
        piece = Group(
            Label('L', centerX, 225, fill='seaGreen', size=18, bold=True),
            Circle(centerX, 200, 20, fill='seaGreen')
            )
        evenPieces.add(piece)

    else:
        piece = Group(
            Label('L', centerX, 225, fill='lightGreen', size=18, bold=True),
            Circle(centerX, 200, 20, fill='lightGreen')
            )
        oddPieces.add(piece)

def onStep():
    for shape in evenPieces:
        shape.centerY += evenPieces.dy
    for shape in oddPieces:
        shape.centerY += oddPieces.dy

    # Moves the worm, with wraparound.
    worm.centerX += 2
    if (worm.left >= 400):
        worm.right = 0

    # Adjusts the direction the body parts move.
    evenPieces.dy *= -1
    if (oddPieces.dy == 0):
        oddPieces.dy = 1
    else:
        oddPieces.dy *= -1
",regular,2
2219,Rainbow ripples,8.3.2,"app.background = 'black'
app.rippleSpace = 40

ripples = Group()

def drawRipples():
    ripples.clear()

    # Draw ripples from the middle of the canvas to the edges.
    # The distance between ripples is determined by app.rippleSpace.
    ### (HINT: The radius of the smallest circle should determine where
    #          you start the for loop. 200 should be the end-value
    #          in the for loop.)
    ### (HINT: Add each circle you draw to the ripples group.)
    ### Place Your Code Here ###

drawRipples()

def onKeyHold(keys):
    if ('up' in keys):
        app.rippleSpace += 2
    elif (('down' in keys) and (app.rippleSpace > 2)):
        app.rippleSpace -= 2
    drawRipples()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.rippleSpace = 40

ripples = Group()

def drawRipples():
    ripples.clear()

    # Draw ripples from the middle of the canvas to the edges.
    # The distance between ripples is determined by app.rippleSpace.
    for radius in range(20, 200, app.rippleSpace):
        ripples.add(
            Circle(200, 200, radius, fill=None,
                   border=gradient('red', 'orange', 'yellow', 'lawnGreen',
                                   start='top'))
            )
drawRipples()

def onKeyHold(keys):
    if ('up' in keys):
        app.rippleSpace += 2
    elif (('down' in keys) and (app.rippleSpace > 2)):
        app.rippleSpace -= 2
    drawRipples()
",regular,1
2224,Sweeping arcs,8.3.4,"app.background = 'black'

arcs = Group()

# Draw a 5x5 grid of equally-spaced arcs on the screen, and add the arcs to
# the arcs group.
### (HINT: Use a nested for loop to create the grid.)
### (HINT: The initial sweep angle for each arc should be 180.)
### Place Your Code Here ###

def onMouseMove(mouseX, mouseY):
    # Change the sweep angle of each arc based on mouseX as long as mouseX is
    # larger than 1.
    ### (HINT: Scale the value of mouseX to go up to 360, instead of 400.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

arcs = Group()

# Draw a 5x5 grid of equally-spaced arcs on the screen, and add the arcs to
# the arcs group.
for x in range(40, 400, 80):
    for y in range(40, 400, 80):
        arcs.add(
            Arc(x, y, 40, 40, 0, 180, fill=None, border='lime')
            )

def onMouseMove(mouseX, mouseY):
    # Change the sweep angle of each arc based on mouseX as long as mouseX is
    # larger than 1.
    for arc in arcs:
        if (mouseX > 1):
            newSweepAngle = (mouseX / 400) * 360
            arc.sweepAngle = newSweepAngle
",regular,1
2221,Magnifying glass,8.3.4,"dotGrid = Group()

# Create an evenly spaced 9x9 grid of dots.
### (HINT: Use nested for loops to create the grid.)
### Place Your Code Here ###

# magnifying glass
magnifyingGlass = Group(
    Circle(200, 200, 50, fill=gradient('white', 'steelBlue', start='left'),
           opacity=25),
    Circle(200, 200, 50, fill=None, border='silver'),
    Line(200, 250, 200, 300, lineWidth=10)
    )
magnifyingGlass.glassX = 200
magnifyingGlass.glassY = 200

def onMouseMove(mouseX, mouseY):
    magnifyingGlass.centerX = mouseX
    magnifyingGlass.centerY = mouseY
    magnifyingGlass.glassX = magnifyingGlass.centerX
    magnifyingGlass.glassY = magnifyingGlass.centerY - 25

    # Resize any dots who's centers are inside the glass.
    ### (HINT: Use a function learned in this Unit!)
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

dotGrid = Group()

# Create an evenly spaced 9x9 grid of dots.
for cx in range(40, 400, 40):
    for cy in range(40, 400, 40):
        dotGrid.add(
            Circle(cx, cy, 5)
            )

# magnifying glass
magnifyingGlass = Group(
    Circle(200, 200, 50, fill=gradient('white', 'steelBlue', start='left'),
           opacity=25),
    Circle(200, 200, 50, fill=None, border='silver'),
    Line(200, 250, 200, 300, lineWidth=10)
    )
magnifyingGlass.glassX = 200
magnifyingGlass.glassY = 200

def onMouseMove(mouseX, mouseY):
    magnifyingGlass.centerX = mouseX
    magnifyingGlass.centerY = mouseY
    magnifyingGlass.glassX = magnifyingGlass.centerX
    magnifyingGlass.glassY = magnifyingGlass.centerY - 25

    # Resize any dots who's centers are inside the glass.
    for dot in dotGrid:
        if (distance(magnifyingGlass.glassX, magnifyingGlass.glassY,
                     dot.centerX, dot.centerY) < 50):
            dot.radius = 15
        else:
            dot.radius = 5
",regular,2
2225,Parallel Lines,8.3.4,"def drawRect(row, col):
    # Picks the color based on the col.
    if (col % 2 == 0):
        color = 'white'
    else:
        color = 'black'

    # Set startX to create the optical illusion. Even rows start
    # at -10 while odd rows start at -20.
    ### Fix Your Code Here ###
    startX = 0

    Rect(startX + 40 * col, 40 * row, 40, 40, fill=color, border='gray',
         borderWidth=1)

def drawIllusion():
    # Draw rectangles over the entire canvas.
    ### (HINT: Add a nested for loop for col.)
    ### Fix Your Code Here ###
    for row in range(10):
        col = 0
        drawRect(row, col)

drawIllusion()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

def drawRect(row, col):
    # Picks the color based on the col.
    if (col % 2 == 0):
        color = 'white'
    else:
        color = 'black'

    # Set startX to create the optical illusion. Even rows start
    # at -10 while odd rows start at -20.
    if (row % 2 == 0):
        startX = -10
    else:
        startX = -20

    Rect(startX + 40 * col, 40 * row, 40, 40, fill=color, border='gray',
         borderWidth=1)

def drawIllusion():
    # Draw rectangles over the entire canvas.
    for row in range(10):
        for col in range(10):
            drawRect(row, col)
drawIllusion()
",regular,1
2226,Bookshelf,8.3.4,"app.background = 'sienna'

Line(200, -8, 200, 400, fill='saddleBrown', lineWidth=400, dashes=(8, 42))

def chooseColor(bookHeight):
    if (bookHeight == 35):
        return 'crimson'
    elif (bookHeight == 36):
        return 'steelBlue'
    elif (bookHeight == 37):
        return 'orange'
    elif (bookHeight == 38):
        return 'lightSalmon'
    elif (bookHeight == 39):
        return 'lightSeaGreen'
    else:
        return 'darkKhaki'

def chooseSpineDecoration(book):
    # Draws one of three types of decorations for the spine of a book.
    spineDec = randrange(0, 3)
    cx = book.centerX
    if (spineDec == 0):
        dec = Group(
            Rect(cx, book.bottom - 3, book.width - 2, 2, align='bottom'),
            Rect(cx, book.bottom - 7, book.width - 2, 1, align='bottom')
            )
    elif (spineDec == 1):
        dec = Group(
            Rect(cx, book.top + 5, 10, 1, align='center'),
            Label('Illegible Title', cx, book.centerY + 3, size=4, rotateAngle=90)
            )
    else:
        dec = Group(
            Polygon(cx - 8, book.top + 5, cx, book.top + 3, cx + 8, book.top + 5),
            Rect(cx, book.top + 8, 2, book.height - 12, align='top')
            )
    book.add(dec)

def addBook(y, bookRow):
    # y represents bottom coordinate of the book. The bookRow is a group.
    height = randrange(35, 41)
    width = randrange(17, 24)
    bookRow.right += width
    color = chooseColor(height)
    book = Group(
        Rect(0, y, width, height, fill=color, border='darkSlateGrey',
             borderWidth=1, align='left-bottom')
        )
    chooseSpineDecoration(book)
    bookRow.add(book)

def addBookend(x, y, bookRow):
    # (x, y) represent left-bottom coordinates of the bookend.
    # The bookRow is a group.
    bookRow.add(
        Polygon(x, y, x, y - 20, x + 10, y - 20, x + 10, y - 5, x + 15, y - 5,
                x + 15, y, fill='grey', border='darkSlateGrey', borderWidth=1)
        )

shelves = Group()

def populateBookshelf(booksPerShelf):
    # Use a nested for loop to populate each of the 8 shelves with books. Add
    # each row to shelves (you will need it in onMousePress).
    ### (HINT: Every shelf should have its own group to store books in.)
    ### Place Your Code Here ###
    pass

def onMousePress(mouseX, mouseY):
    # Check if one of the rows of books in shelves is pressed. If so, add
    # a book to the left of the group.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'sienna'

Line(200, -8, 200, 400, fill='saddleBrown', lineWidth=400, dashes=(8, 42))

def chooseColor(bookHeight):
    if (bookHeight == 35):
        return 'crimson'
    elif (bookHeight == 36):
        return 'steelBlue'
    elif (bookHeight == 37):
        return 'orange'
    elif (bookHeight == 38):
        return 'lightSalmon'
    elif (bookHeight == 39):
        return 'lightSeaGreen'
    else:
        return 'darkKhaki'

def chooseSpineDecoration(book):
    # Draws one of three types of decorations for the spine of a book.
    spineDec = randrange(0, 3)
    cx = book.centerX
    if (spineDec == 0):
        dec = Group(
            Rect(cx, book.bottom - 3, book.width - 2, 2, align='bottom'),
            Rect(cx, book.bottom - 7, book.width - 2, 1, align='bottom')
            )
    elif (spineDec == 1):
        dec = Group(
            Rect(cx, book.top + 5, 10, 1, align='center'),
            Label('Illegible Title', cx, book.centerY + 3, size=4, rotateAngle=90)
            )
    else:
        dec = Group(
            Polygon(cx - 8, book.top + 5, cx, book.top + 3, cx + 8, book.top + 5),
            Rect(cx, book.top + 8, 2, book.height - 12, align='top')
            )
    book.add(dec)

def addBook(y, bookRow):
    # y represents bottom coordinate of the book. The bookRow is a group.
    height = randrange(35, 41)
    width = randrange(17, 24)
    bookRow.right += width
    color = chooseColor(height)
    book = Group(
        Rect(0, y, width, height, fill=color, border='darkSlateGrey',
             borderWidth=1, align='left-bottom')
        )
    chooseSpineDecoration(book)
    bookRow.add(book)

def addBookend(x, y, bookRow):
    # (x, y) represent left-bottom coordinates of the bookend.
    # The bookRow is a group.
    bookRow.add(
        Polygon(x, y, x, y - 20, x + 10, y - 20, x + 10, y - 5, x + 15, y - 5,
                x + 15, y, fill='grey', border='darkSlateGrey', borderWidth=1)
        )

shelves = Group()

def populateBookshelf(booksPerShelf):
    # Use a nested for loop to populate each of the 8 shelves with books. Add
    # each row to shelves (you will need it in onMousePress).
    for i in range(8):
        y = 42 + i * 50
        bookRow = Group()
        for bookIndex in range(booksPerShelf):
            addBook(y, bookRow)

        addBookend(bookRow.right, y, bookRow)
        shelves.add(bookRow)

def onMousePress(mouseX, mouseY):
    # Check if one of the rows of books in shelves is pressed. If so, add
    # a book to the left of the group.
    for bookRow in shelves.children:
        if (bookRow.hits(mouseX, mouseY) == True):
            addBook(bookRow.bottom, bookRow)
",regular,2
2222,Constellations,8.3.4,"app.background = 'black'
stars = Group()
connections = Group()

def drawConstellation():
    # Creates the stars.
    for i in range(15):
        x = randrange(0, 400)
        y = randrange(0, 400)
        stars.add(
            Star(x, y, 3, 4, fill='white')
            )

    # Look at all pairs of stars that we can draw lines between.
    for star1 in stars:
        for star2 in stars:
            # When star1 and star2 are not the same star and star1 is more right
            # than star2, add connections between stars that are between 50 and
            # 150 pixels apart.
            ### (HINT: Use the distance function to determine how far apart
            #          the stars are!)
            ### Place Your Code Here ###
            pass

    stars.toFront()

def onKeyPress(key):
    if (key == 'r'):
        stars.clear()
        connections.clear()
        drawConstellation()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
stars = Group()
connections = Group()

def drawConstellation():
    # Creates the stars.
    for i in range(15):
        x = randrange(0, 400)
        y = randrange(0, 400)
        stars.add(
            Star(x, y, 3, 4, fill='white')
            )

    # Look at all pairs of stars that we can draw lines between.
    for star1 in stars:
        for star2 in stars:
            # When star1 and star2 are not the same star and star1 is more right
            # than star2, add connections between stars that are between 50 and
            # 150 pixels apart.
            if ((star1 != star2) and (star1.centerX > star2.centerX)):
                d = distance(star1.centerX, star1.centerY,
                             star2.centerX, star2.centerY)

                if ((d > 50) and (d < 150)):
                    connections.add(
                        Line(star1.centerX, star1.centerY, star2.centerX,
                             star2.centerY, fill='grey', lineWidth=1)
                        )

    stars.toFront()

def onKeyPress(key):
    if (key == 'r'):
        stars.clear()
        connections.clear()
        drawConstellation()
",regular,3
2223,Lights,8.3.4,"app.background = 'black'

def drawLights():
    # Create a nested for loop to draw all the circles.
    ### Fix Your Code Here ###
    for xVal in range(1):
        for yVal in range(1):
            # Calculates what the radius and color should be based on the
            # x and y position.
            distanceX = abs(200 - xVal)
            distanceY = abs(200 - yVal)
            radius = 0

            # Gets the radius based on where the circle is on the canvas.
            if (distanceX < distanceY):
                radius = distanceY / 10
            else:
                radius = distanceX / 10
            color = radius * 10 + 55

            # Draw the circle.
            ### Fix Your Code Here ###
            Circle(0, 0, radius, fill=gradient(rgb(0, 0, color), 'black'))

drawLights()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

def drawLights():
    # Create a nested for loop to draw all the circles.
    for xVal in range(20, 400, 30):
        for yVal in range(0, 400, 30):
            # Calculates what the radius and color should be based on the
            # x and y position.
            distanceX = abs(200 - xVal)
            distanceY = abs(200 - yVal)
            radius = 0

            # Gets the radius based on where the circle is on the canvas.
            if (distanceX < distanceY):
                radius = distanceY / 10
            else:
                radius = distanceX / 10
            color = radius * 10 + 55

            # Draw the circle.
            Circle(xVal, yVal, radius, fill=gradient(rgb(0, 0, color), 'black'))

drawLights()
",regular,2
2227,Spotlights,8.4,"app.background = 'black'

Polygon(20, 310, 380, 310, 600, 350, -200, 350, fill='lightGrey')
Rect(-5, 350, 410, 60, fill='slateGrey', border='lightSlateGrey', borderWidth=5)

def drawLightingFrame():
    Rect(-5, 15, 410, 45, fill=None, border='dimGrey', borderWidth=5)

    # Draw the correct number of crossbars in the lighting frame by changing the
    # looping bounds.
    ### Fix Your Code Here ###
    for leftX in range(0, 70, 70):
        Line(leftX, 15, leftX + 35, 60, fill='dimGrey', lineWidth=3)
        Line(leftX + 35, 60, leftX + 70, 15, fill='dimGrey', lineWidth=3)

def drawStick(headX):
    # Randomly make the arms up, down, or level.
    leftHandX = 290 + randrange(-1, 2) * 15
    rightHandX = 290 + randrange(-1, 2) * 15

    # head and body
    Circle(headX, 265, 15)
    Line(headX, 265, headX, 315)

    # arms and legs
    Line(headX, 290, headX - 18, leftHandX)
    Line(headX, 290, headX + 18, rightHandX)
    Line(headX, 315, headX - 10, 340)
    Line(headX, 315, headX + 10, 340)

def drawLightsAndPeople():
    # Fix the loop below to draw only four evenly-spaced lights.
    ### Fix Your Code Here ###
    for cx in range(50, 351, 50):

        # Add a condition so that the light colors alternate.
        ### Fix Your Code Here ###
        color = 'lightBlue'

        # spotlight
        Rect(cx, 75, 40, 60, align='center',
             fill=gradient('black', rgb(60, 60, 60), 'black', start='left'))
        Oval(cx, 105, 40, 20, fill=color, border='black', opacity=90)

        # light beam
        Polygon(cx - 18, 105, cx + 18, 105, cx + 55, 330, cx - 55, 330,
                fill=color, opacity=50)
        Arc(cx, 330, 110, 25, 90, 180, fill=color, opacity=50)

        drawStick(cx)

drawLightingFrame()
drawLightsAndPeople()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

Polygon(20, 310, 380, 310, 600, 350, -200, 350, fill='lightGrey')
Rect(-5, 350, 410, 60, fill='slateGrey', border='lightSlateGrey', borderWidth=5)

def drawLightingFrame():
    Rect(-5, 15, 410, 45, fill=None, border='dimGrey', borderWidth=5)

    # Draw the correct number of crossbars in the lighting frame by changing the
    # looping bounds.
    for leftX in range(0, 400, 70):
        Line(leftX, 15, leftX + 35, 60, fill='dimGrey', lineWidth=3)
        Line(leftX + 35, 60, leftX + 70, 15, fill='dimGrey', lineWidth=3)

def drawStick(headX):
    # Randomly make the arms up, down, or level.
    leftHandX = 290 + randrange(-1, 2) * 15
    rightHandX = 290 + randrange(-1, 2) * 15

    # head and body
    Circle(headX, 265, 15)
    Line(headX, 265, headX, 315)

    # arms and legs
    Line(headX, 290, headX - 18, leftHandX)
    Line(headX, 290, headX + 18, rightHandX)
    Line(headX, 315, headX - 10, 340)
    Line(headX, 315, headX + 10, 340)

def drawLightsAndPeople():
    # Fix the loop below to draw only four evenly-spaced lights.
    for cx in range(50, 351, 100):

        # The light colors should alternate.
        if ((cx == 150) or (cx == 350)):
            color = 'paleGreen'
        else:
            color = 'lightBlue'

        # spotlight
        Rect(cx, 75, 40, 60, align='center',
             fill=gradient('black', rgb(60, 60, 60), 'black', start='left'))
        Oval(cx, 105, 40, 20, fill=color, border='black', opacity=90)

        # light beam
        Polygon(cx - 18, 105, cx + 18, 105, cx + 55, 330, cx - 55, 330,
                fill=color, opacity=50)
        Arc(cx, 330, 110, 25, 90, 180, fill=color, opacity=50)

        drawStick(cx)

drawLightingFrame()
drawLightsAndPeople()
",regular,1
2228,Snowfall,8.4,"app.background = gradient(rgb(220, 245, 255), 'black', start='left-top')
app.stepsPerSecond = 20

fallingSnowflakes = Group()

def createSnowflakes():
    for i in range(85):
        # Create a randomly placed, sized, and opaque snowflake.
        flakeX = randrange(0, 400)
        flakeY = randrange(0, 400)
        size = randrange(2, 4)
        opacity = randrange(0, 80)
        flake = Circle(flakeX, flakeY, size, fill='white', opacity=opacity)

        # Only some of the snowflakes will fall, the rest are stuck to the window.
        if (i < 65):
            fallingSnowflakes.add(flake)

createSnowflakes()

# window and curtains
Line(200, 0, 200, 400, fill='sienna', lineWidth=4)
Line(0, 200, 400, 200, fill='sienna', lineWidth=4)
Rect(0, 0, 400, 400, fill=None, border='sienna', borderWidth=10)
Oval(0, 0, 180, 360, fill='crimson', rotateAngle=15)
Oval(400, 0, 180, 360, fill='crimson', rotateAngle=-15)

def onStep():
    # Move each flake right and down a random distance, with wraparound.
    ### (HINT: The x value of a flake should increase by somewhere between
    #          0 and 99. The y value should change by somewhere between
    #          -2 and 24. All inclusive.)
    ### (HINT: For the wraparound, don't use centerX or centerY. And use >=
    #          and <=, not > and <.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(220, 245, 255), 'black', start='left-top')
app.stepsPerSecond = 20

fallingSnowflakes = Group()

def createSnowflakes():
    for i in range(85):
        # Create a randomly placed, sized, and opaque snowflake.
        flakeX = randrange(0, 400)
        flakeY = randrange(0, 400)
        size = randrange(2, 4)
        opacity = randrange(0, 80)
        flake = Circle(flakeX, flakeY, size, fill='white', opacity=opacity)

        # Only some of the snowflakes will fall, the rest are stuck to the window.
        if (i < 65):
            fallingSnowflakes.add(flake)

createSnowflakes()

# window and curtains
Line(200, 0, 200, 400, fill='sienna', lineWidth=4)
Line(0, 200, 400, 200, fill='sienna', lineWidth=4)
Rect(0, 0, 400, 400, fill=None, border='sienna', borderWidth=10)
Oval(0, 0, 180, 360, fill='crimson', rotateAngle=15)
Oval(400, 0, 180, 360, fill='crimson', rotateAngle=-15)

def onStep():
    # Move each flake right and down a random distance, with wraparound.
    for flake in fallingSnowflakes.children:
        flake.centerX += randrange(0, 100)
        flake.centerY += randrange(-2, 25)

        # Wrap the flake around
        if (flake.left >= 400):
            flake.right = 0
        if (flake.top >= 400):
            flake.bottom = 0
",regular,1
2231,Eyes following dot,8.4,"app.background = 'salmon'

dot = Circle(200, 200, 5, fill=None, border='white')
eyes = Group()

def makeEyes():
    # Fix these nested for loops so that they draw another row and column of
    # eyes in the bottom right corner.
    ### (HINT: You will only need to change one number in the 'range' of
    #          each for loop. Why aren't eyes drawn there now?)
    ### Fix Your Code Here ###
    for centerX in range(0, 400, 100):
        for centerY in range(0, 400, 100):
            Oval(centerX, centerY, 70, 65, fill='white')
            newEye = Group(
                Oval(centerX, centerY, 30, 28, fill='cyan', border='black'),
                Oval(centerX, centerY, 15, 15)
                )

            # Saves centerX, and centerY value so you can use it for resetting
            # the eye in onMouseMove.
            newEye.resetX = centerX
            newEye.resetY = centerY
            eyes.add(newEye)

    eyes.toFront()
    dot.toFront()

makeEyes()

def onMouseMove(mouseX, mouseY):
    # Moves the dot to the mouse location.
    dot.centerX = mouseX
    dot.centerY = mouseY

    # Loops over each eye in the group eyes.
    for eye in eyes.children:
        # Change this code so that the angle it is creating is the angle between
        # the eye's reset custom properties and the current mouse location.
        ### Fix Your Code Here ###
        angle = angleTo(0, 0, 200, 200)

        # Increase the amount the eyes move based on how far from the mouse
        # they are.
        distanceMoved = 20 - (distance(mouseX, mouseY, eye.resetX, eye.resetY) / 20)

        # Change this code so that the getPointInDir function uses the eye's
        # reset custom properties as its x1 and y1, and uses the calculated
        # angle above.
        ### Fix Your Code Here ###
        newCenterX, newCenterY = getPointInDir(200, 200, 50, distanceMoved)
        eye.centerX = newCenterX
        eye.centerY = newCenterY
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'salmon'

dot = Circle(200, 200, 5, fill=None, border='white')
eyes = Group()

def makeEyes():
    # Fix these nested for loops so that they draw another row and column of
    # eyes in the bottom right corner.
    for centerX in range(0, 401, 100):
        for centerY in range(0, 401, 100):
            Oval(centerX, centerY, 70, 65, fill='white')
            newEye = Group(
                Oval(centerX, centerY, 30, 28, fill='cyan', border='black'),
                Oval(centerX, centerY, 15, 15)
                )

            # Saves centerX, and centerY value so you can use it for resetting
            # the eye in onMouseMove.
            newEye.resetX = centerX
            newEye.resetY = centerY
            eyes.add(newEye)

    eyes.toFront()
    dot.toFront()

makeEyes()

def onMouseMove(mouseX, mouseY):
    # Moves the dot to the mouse location.
    dot.centerX = mouseX
    dot.centerY = mouseY

    # Loops over each eye in the group eyes.
    for eye in eyes.children:
        # Change this code so that the angle it is creating is the angle between
        # the eye's reset custom properties and the current mouse location.
        angle = angleTo(eye.resetX, eye.resetY, mouseX, mouseY)

        # Increase the amount the eyes move based on how far from the mouse
        # they are.
        distanceMoved = 20 - (distance(mouseX, mouseY, eye.resetX, eye.resetY) / 20)

        # Change this code so that the getPointInDir function uses the eye's
        # reset custom properties as its x1 and y1, and uses the calculated
        # angle above.
        newCenterX, newCenterY = getPointInDir(eye.resetX, eye.resetY,
                                               angle, distanceMoved)
        eye.centerX = newCenterX
        eye.centerY = newCenterY
",regular,2
2229,Tickle,8.4,"app.background = 'black'

t = Label('tickle', 200, 200, fill='cyan', size=50)
fadedTickles = Group()

def onMouseMove(mouseX, mouseY):
    # If the mouse moves over the tickle label, add a new tickle label to the
    # group. Also change the original label's center to a new random position!
    ### (HINT: The tickle can move up to 10 pixels horizontally and up to 10
    #          pixels vertically (both inclusive).)
    ### Place Your Code Here ###
    pass

def onStep():
    # Loop through each tickle label in the group and reduce opacity by 20.
    # If the opacity of the label is equal to 0, remove it from the group.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

t = Label('tickle', 200, 200, fill='cyan', size=50)
fadedTickles = Group()

def onMouseMove(mouseX, mouseY):
    # If the mouse moves over the tickle label, add a new tickle label to the
    # group. Also change the original label's center to a new random position!
    if (t.contains(mouseX, mouseY) == True):
        fadedTickles.add(
            Label('tickle', t.centerX, t.centerY, fill='cyan', size=50)
            )
        t.centerX += randrange(-10, 11)
        t.centerY += randrange(-10, 11)
def onStep():
    # Loop through each tickle label in the group and reduce opacity by 20.
    # If the opacity of the label is equal to 0, remove it from the group.
    for tickle in fadedTickles:
        tickle.opacity -= 20
        if (tickle.opacity == 0):
            fadedTickles.remove(tickle)
",regular,1
2230,Ferris wheel with cabins,8.4,"# background
app.background = gradient('moccasin', 'papayaWhip', start='top')
Polygon(200, 400, 360, 340, 450, 400,
        fill=gradient('gold', 'goldenrod', start='top'))
Polygon(-100, 400, 40, 300, 300, 400,
        fill=gradient('orange', 'tomato', start='top'))

# rotating piece of ferris wheel
rotatingSpikes = Star(200, 200, 150, 10, fill=gradient('gainsboro', 'gray'),
                      roundness=15)

# rings
rings = Group(
    Circle(200, 200, 75, fill=None, border='blue', borderWidth=8, opacity=70),
    Circle(200, 200, 50, fill=None, border='red', borderWidth=6, opacity=70),
    Circle(200, 200, 150, fill=None, borderWidth=10, opacity=70,
           border=gradient('blue', 'red', 'green', 'yellow', start='top')),
    Circle(200, 200, 146, fill=None, border='white'),
    Circle(200, 200, 154, fill=None, border='white')
    )

cabins = Group()

# legs
Line(120, 400, 200, 200, fill='white', lineWidth=12)
Line(280, 400, 200, 200, fill='white', lineWidth=12)
Circle(200, 200, 6, fill='white')

def makeCabins(numberOfCabins):
    stepAngle = 360 / numberOfCabins
    for i in range(numberOfCabins):
        # Gets a random color for the cabin.
        color = rgb(randrange(0, 256), 0, randrange(150, 256))

        # Get the new centerX and centerY for the cabins by using the
        # getPointInDir function. The angle should be i * stepAngle and the
        # distance should be 155.
        ### Fix Your Code Here ###
        centerX, centerY = 355, 200

        # Makes a new cabin.
        cabin = Group(
            Arc(centerX, centerY, 50, 60, 90, 180, fill=color),
            Arc(centerX, centerY - 20, 50, 30, 270, 180, fill=color),
            Line(centerX - 20, centerY, centerX - 20, centerY - 20),
            Line(centerX + 20, centerY, centerX + 20, centerY - 20)
            )
        cabin.centerX = centerX
        cabin.centerY = centerY

        # Sets a custom property of the cabin to use for rotating later.
        cabin.currentAngle = i * stepAngle

        # Adds the cabin to the cabins Group.
        cabins.add(cabin)

makeCabins(rotatingSpikes.points)

def onStep():
    rotatingSpikes.rotateAngle += 1
    rings.rotateAngle += 1

    # Loop through each cabin.
    for cabin in cabins:
        # Prepare to move the cabin by 1 degree by using a custom property.
        ### Place Your Code Here ###

        # Get the new centerX and centerY of the cabin by using
        # getPointInDir with the currentAngle property used above
        # and 155 for the distance.
        ### Place Your Code Here ###

        # Set the centerX and centerY of the cabin to the new point.
        ### Place Your Code Here ###
        pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
app.background = gradient('moccasin', 'papayaWhip', start='top')
Polygon(200, 400, 360, 340, 450, 400,
        fill=gradient('gold', 'goldenrod', start='top'))
Polygon(-100, 400, 40, 300, 300, 400,
        fill=gradient('orange', 'tomato', start='top'))

# rotating piece of ferris wheel
rotatingSpikes = Star(200, 200, 150, 10, fill=gradient('gainsboro', 'gray'),
                      roundness=15)

# rings
rings = Group(
    Circle(200, 200, 75, fill=None, border='blue', borderWidth=8, opacity=70),
    Circle(200, 200, 50, fill=None, border='red', borderWidth=6, opacity=70),
    Circle(200, 200, 150, fill=None, borderWidth=10, opacity=70,
           border=gradient('blue', 'red', 'green', 'yellow', start='top')),
    Circle(200, 200, 146, fill=None, border='white'),
    Circle(200, 200, 154, fill=None, border='white')
    )

cabins = Group()

# legs
Line(120, 400, 200, 200, fill='white', lineWidth=12)
Line(280, 400, 200, 200, fill='white', lineWidth=12)
Circle(200, 200, 6, fill='white')

def makeCabins(numberOfCabins):
    stepAngle = 360 / numberOfCabins
    for i in range(numberOfCabins):
        # Gets a random color for the cabin.
        color = rgb(randrange(0, 256), 0, randrange(150, 256))

        # Get the new centerX and centerY for the cabins by using the
        # getPointInDir function. The angle should be i * stepAngle and the
        # distance should be 155.
        centerX, centerY = getPointInDir(200, 200, i * stepAngle, 155)

        # Makes a new cabin.
        cabin = Group(
            Arc(centerX, centerY, 50, 60, 90, 180, fill=color),
            Arc(centerX, centerY - 20, 50, 30, 270, 180, fill=color),
            Line(centerX - 20, centerY, centerX - 20, centerY - 20),
            Line(centerX + 20, centerY, centerX + 20, centerY - 20)
            )
        cabin.centerX = centerX
        cabin.centerY = centerY

        # Sets a custom property of the cabin to use for rotating later.
        cabin.currentAngle = i * stepAngle

        # Adds the cabin to the cabins Group.
        cabins.add(cabin)

makeCabins(rotatingSpikes.points)

def onStep():
    rotatingSpikes.rotateAngle += 1
    rings.rotateAngle += 1

    # Loop through each cabin.
    for cabin in cabins:
        # Prepare to move the cabin by 1 degree by using a custom property.
        cabin.currentAngle += 1

        # Get the new centerX and centerY of the cabin by using
        # getPointInDir with the currentAngle property used above
        # and 155 for the distance.
        newCenterX, newCenterY = getPointInDir(200, 200, cabin.currentAngle, 155)

        # Set the centerX and centerY of the cabin to the new point.
        cabin.centerX = newCenterX
        cabin.centerY = newCenterY
",regular,1
2232,Polaroids,8.4,"app.background = 'tan'

covers = Group()

# Use nested loops to draw all of the photos. Name the loop variables
# row and col to replace the definitions below and then define x and
# y to be the top left of each photograph using row and col.
### (HINT: The x and y values are correct for when row = 1, col = 2.)
### Fix Your Code Here ###
row = 1
col = 2
x = 210
y = 135

# Draw the photo backgrounds and thumbtacks.
### Place Your Code Here ###

# Draws the photo of a flower.
Line(x + 40, y + 45, x + 40, y + 80, fill='green', lineWidth=5)
Star(x + 40, y + 45, 20, 10,
     fill=rgb(row * 75, col * 75, (row + col) * 50), roundness=75)
Circle(x + 40, y + 45, 5, fill='gold')

# Add a black cover over the photo.
### (HINT: Use the group called covers.)
### Place Your Code Here ###

covers.toFront()

def onKeyHold(keys):
    # Decreases each cover's opacity until it reaches 0.
    for cover in covers.children:
        if (cover.opacity >= 5):
            cover.opacity -= 5
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'tan'

covers = Group()

# Use nested loops to draw all of the photos. Name the loop variables
# row and col to replace the definitions below and then define x and
# y to be the top left of each photograph using row and col.
for row in range(3):
    for col in range(4):
        x = col * 100 + 10
        y = row * 125 + 10

        # Draw photo backgrounds thumbtacks.
        Rect(x, y, 80, 105, fill='white', border='black')
        Rect(x + 10, y + 10, 60, 70, fill='lightSteelBlue')
        Circle(x + 40, y, 5, fill='fireBrick')

        # Draws the photo of a flower.
        Line(x + 40, y + 45, x + 40, y + 80, fill='green', lineWidth=5)
        Star(x + 40, y + 45, 20, 10,
             fill=rgb(row * 75, col * 75, (row + col) * 50), roundness=75)
        Circle(x + 40, y + 45, 5, fill='gold')

        # Add a black cover over the photo.
        covers.add(
            Rect(x + 10, y + 10, 60, 70)
            )

covers.toFront()

def onKeyHold(keys):
    # Decreases each cover's opacity until it reaches 0.
    for cover in covers.children:
        if (cover.opacity >= 5):
            cover.opacity -= 5
",regular,2
2233,Arm,8.4,"app.background = gradient('black', 'midnightBlue', start='left-top')

# Randomly draws 40 stars.
for i in range(40):
    Circle(randrange(0, 400), randrange(0, 400), 1, fill='white', opacity=50)

# astronaut
astronaut = Group(
    Rect(180, 205, 40, 40, fill='darkGray'),
    Circle(200, 200, 15, fill='white'),
    Rect(185, 215, 30, 40, fill='white'),
    Rect(175, 215, 50, 12, fill='white'),
    Rect(190, 193, 20, 14, fill='steelBlue'),
    Line(200, 240, 200, 255),
    Rect(195, 222, 10, 10, fill='gray'),
    Rect(180, 215, 3, 12, fill='fireBrick'),
    Rect(217, 215, 3, 12, fill='fireBrick')
    )
astronaut.centerX = 90
astronaut.centerY = 70
astronaut.rotateAngle = 20

# satellite
Rect(220, 250, 130, 200, fill=gradient('darkGray', 'dimGray', start='left'),
     rotateAngle=330)
Line(110, 330, 360, 190, fill='dimGray', lineWidth=5)
Oval(234, 262, 130, 50, rotateAngle=330,
     fill=gradient('darkGray', 'dimGray', start='right-bottom'))
Oval(110, 330, 130, 50, fill=gradient('peru', 'chocolate'), rotateAngle=330)
Oval(360, 190, 130, 50, fill=gradient('peru', 'chocolate'), rotateAngle=330)

# arm
firstArm = Line(235, 260, 180, 180, fill='white', lineWidth=30)
secondArm = Line(180, 180, 250, 100, fill='white', lineWidth=30)
firstArmPivot = Circle(180, 180, 15, fill='silver')
secondArmPivot = Circle(250, 100, 15, fill='silver')
Circle(235, 260, 15, fill='gray')

def turnArm(arm, angle, x1, y1):
    # Find the x2, y2 for each arm using the parameters provided.
    ### (HINT: Use the function getPointInDir with a distance of 100.)
    ### Fix Your Code Here ###
    newX2, newY2 = x1, y1 + 100

    # Sets the new values of the arm.
    arm.x2 = newX2
    arm.y2 = newY2

def onMouseMove(mouseX, mouseY):
    # Set scale to be equal to 360 divided by 400.
    ### Fix Your Code Here ###
    scale = 1

    # Set the firstArmAngle to be the mouseX times scale and fix the arguments
    # provided to the turnArm function to properly turn the first arm.
    ### Fix Your Code Here ###
    firstArmAngle = 90
    turnArm(100, 100, 235, 260)

    # Similarly, set secondArmAngle but use mouseY and fix the arguments
    # provided to the turnArm function to properly turn the second arm.
    ### Fix Your Code Here ###
    secondArmAngle = 90
    turnArm(100, 100, 235, 260)

    # Moves the arm pivots to the new value
    firstArmPivot.centerX = firstArm.x2
    firstArmPivot.centerY = firstArm.y2
    secondArmPivot.centerX = secondArm.x2
    secondArmPivot.centerY = secondArm.y2

    secondArm.x1 = firstArm.x2
    secondArm.y1 = firstArm.y2
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('black', 'midnightBlue', start='left-top')

# Randomly draws 40 stars.
for i in range(40):
    Circle(randrange(0, 400), randrange(0, 400), 1, fill='white', opacity=50)

# astronaut
astronaut = Group(
    Rect(180, 205, 40, 40, fill='darkGray'),
    Circle(200, 200, 15, fill='white'),
    Rect(185, 215, 30, 40, fill='white'),
    Rect(175, 215, 50, 12, fill='white'),
    Rect(190, 193, 20, 14, fill='steelBlue'),
    Line(200, 240, 200, 255),
    Rect(195, 222, 10, 10, fill='gray'),
    Rect(180, 215, 3, 12, fill='fireBrick'),
    Rect(217, 215, 3, 12, fill='fireBrick')
    )
astronaut.centerX = 90
astronaut.centerY = 70
astronaut.rotateAngle = 20

# satellite
Rect(220, 250, 130, 200, fill=gradient('darkGray', 'dimGray', start='left'),
     rotateAngle=330)
Line(110, 330, 360, 190, fill='dimGray', lineWidth=5)
Oval(234, 262, 130, 50, rotateAngle=330,
     fill=gradient('darkGray', 'dimGray', start='right-bottom'))
Oval(110, 330, 130, 50, fill=gradient('peru', 'chocolate'), rotateAngle=330)
Oval(360, 190, 130, 50, fill=gradient('peru', 'chocolate'), rotateAngle=330)

# arm
firstArm = Line(235, 260, 180, 180, fill='white', lineWidth=30)
secondArm = Line(180, 180, 250, 100, fill='white', lineWidth=30)
firstArmPivot = Circle(180, 180, 15, fill='silver')
secondArmPivot = Circle(250, 100, 15, fill='silver')
Circle(235, 260, 15, fill='gray')

def turnArm(arm, angle, x1, y1):
    # Find the x2, y2 for each arm using the parameters provided.
    newX2, newY2 = getPointInDir(x1, y1, angle, 100)

    # Sets the new values of the arm.
    arm.x2 = newX2
    arm.y2 = newY2

def onMouseMove(mouseX, mouseY):
    # Set scale to be 360 divided by 400.
    scale = 360 / 400

    # Set the firstArmAngle to be the mouseX times scale and fix the arguments
    # to the turnArm function to properly turn the first arm.
    firstArmAngle = mouseX * scale
    turnArm(firstArm, firstArmAngle, 235, 260)

    # Similarly, set secondArmAngle but use mouseY and fix the arguments
    # to the turnArm function to properly turn the second arm.
    secondArmAngle = mouseY * scale
    turnArm(secondArm, secondArmAngle, firstArm.x2, firstArm.y2)

    # Moves the arm pivots to the new value
    firstArmPivot.centerX = firstArm.x2
    firstArmPivot.centerY = firstArm.y2
    secondArmPivot.centerX = secondArm.x2
    secondArmPivot.centerY = secondArm.y2

    secondArm.x1 = firstArm.x2
    secondArm.y1 = firstArm.y2
",regular,2
2235,Goalie,8.4,"app.background = 'mediumSeaGreen'
app.stepsPerSecond = 100

app.shotWasMade = False

# background
Line(0, 30, 100, 30, fill='white', lineWidth=4, opacity=90)
Line(300, 30, 400, 30, fill='white', lineWidth=4, opacity=90)
Line(0, 320, 400, 320, fill='white', lineWidth=3)
Rect(40, 30, 320, 90, fill=None, border='white')
Circle(200, 200, 12, fill='rosyBrown', opacity=50)
Arc(200, 319, 240, 130, 90, 180, fill=None, border='white', borderWidth=3)

goalie = Group(
    Oval(200, 42, 15, 15, fill='peachPuff'),
    Oval(190, 43, 5, 5, fill='peachPuff'),
    Oval(210, 43, 5, 5, fill='peachPuff')
    )
goalie.caughtBall = False

kicker = Group(
    Oval(190, 320, 15, 15, fill='peachPuff'),
    Oval(180, 320, 5, 5, fill='peachPuff'),
    Oval(200, 320, 5, 5, fill='peachPuff')
    )
kicker.dy = -1

ball = Circle(200, 200, 4, fill='white')
ball.targetX = -1
ball.inGoal = False

def drawNet():
    # Fix the loop to draw the net.
    ### Fix Your Code Here ###
    for x1 in range(1):
        Line(x1, 0, x1 + 10, 32, fill='white', lineWidth=1)
        Line(x1, 0, x1 - 10, 32, fill='white', lineWidth=1)

drawNet()

def reset():
    ball.centerX = 200
    ball.centerY = 200
    ball.targetX = -1

    kicker.centerY = 320
    kicker.dy = -1

    goalie.caughtBall = False
    ball.inGoal = False

def onKeyPress(key):
    if ((ball.inGoal == True) or (goalie.caughtBall == True)):
        reset()

def onMouseMove(mouseX, mouseY):
    if ((mouseX >= 100) and (mouseX <= 300)):
        goalie.centerX = mouseX

    if (goalie.caughtBall == True):
        ball.centerX = goalie.centerX + 10
        ball.centerY = goalie.centerY + 5

def onStep():
    kicker.centerY += kicker.dy

    if (goalie.hitsShape(ball) == True):
        goalie.caughtBall = True
    elif ((ball.targetX != -1) and (ball.centerY >= 5)):
        # Move the ball towards the target by 3 pixels.
        ### (HINT: The target y is the top of the canvas.)
        ### Place Your Code Here ###
        pass

    elif (ball.targetX != -1):
        ball.inGoal = True

    # When the kicker kicks the ball, stop moving the kicker and randomly pick
    # where in the goal the ball will go and set the ball's target.
    ### (HINT: The ball can go anywhere within x=100 and x=300, inclusive.)
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'mediumSeaGreen'
app.stepsPerSecond = 100

app.shotWasMade = False

# background
Line(0, 30, 100, 30, fill='white', lineWidth=4, opacity=90)
Line(300, 30, 400, 30, fill='white', lineWidth=4, opacity=90)
Line(0, 320, 400, 320, fill='white', lineWidth=3)
Rect(40, 30, 320, 90, fill=None, border='white')
Circle(200, 200, 12, fill='rosyBrown', opacity=50)
Arc(200, 319, 240, 130, 90, 180, fill=None, border='white', borderWidth=3)

goalie = Group(
    Oval(200, 42, 15, 15, fill='peachPuff'),
    Oval(190, 43, 5, 5, fill='peachPuff'),
    Oval(210, 43, 5, 5, fill='peachPuff')
    )
goalie.caughtBall = False

kicker = Group(
    Oval(190, 320, 15, 15, fill='peachPuff'),
    Oval(180, 320, 5, 5, fill='peachPuff'),
    Oval(200, 320, 5, 5, fill='peachPuff')
    )
kicker.dy = -1

ball = Circle(200, 200, 4, fill='white')
ball.targetX = -1
ball.inGoal = False

def drawNet():
    # Fix the loop to draw the net.
    for x1 in range(100, 305, 5):
        Line(x1, 0, x1 + 10, 32, fill='white', lineWidth=1)
        Line(x1, 0, x1 - 10, 32, fill='white', lineWidth=1)

drawNet()

def reset():
    ball.centerX = 200
    ball.centerY = 200
    ball.targetX = -1

    kicker.centerY = 320
    kicker.dy = -1

    goalie.caughtBall = False
    ball.inGoal = False

def onKeyPress(key):
    if ((ball.inGoal == True) or (goalie.caughtBall == True)):
        reset()

def onMouseMove(mouseX, mouseY):
    if ((mouseX >= 100) and (mouseX <= 300)):
        goalie.centerX = mouseX

    if (goalie.caughtBall == True):
        ball.centerX = goalie.centerX + 10
        ball.centerY = goalie.centerY + 5

def onStep():
    kicker.centerY += kicker.dy

    if (goalie.hitsShape(ball) == True):
        goalie.caughtBall = True
    elif ((ball.targetX != -1) and (ball.centerY >= 5)):
        # Move the ball towards the target by 3 pixels.
        angle = angleTo(ball.centerX, ball.centerY, ball.targetX, 0)
        x, y = getPointInDir(ball.centerX, ball.centerY, angle, 3)
        ball.centerX = x
        ball.centerY = y

    elif (ball.targetX != -1):
        ball.inGoal = True

    # When the kicker kicks the ball, stop moving the kicker and randomly pick
    # where in the goal the ball will go and set the ball's target.
    if (kicker.hitsShape(ball) == True):
        kicker.dy = 0
        ball.targetX = randrange(100, 301)
",regular,2
2234,Atom,8.4,"app.background = gradient('violet', 'navy', start='top')

allRings = Group()


def makeNRings(n):
    # Creates n rings of circles with the first ring's properties defined here.
    ringRadius = 15
    numCircles = 4
    circleRadius = 20
    clockwise = False

    # Creates each of the rings.
    for ring in range(n):
        angleBetweenCircles = 360 / numCircles
        newRing = Group()
        newRing.clockwise = clockwise

        # Draw the circles in the new ring, and add them to the newRing group.
        ### (HINT: In the first ring, the 0th and 2nd passes through the inner
        #          loop draw crimson circles and the 1st and 3rd passes draw
        #          dodgerBlue circles.)
        ### (HINT: Use getPointInDir to get the coordinates of each circle.
        #          Note that the center of the canvas is the center of the rings.)
        ### (HINT: Don't forget to add the new ring to the allRings group.)
        ### Place Your Code Here ###

        # Update the ring radius, number of circles, circle radius, and
        # clockwise bool.
        ### (HINT: The ring radius increases by 50 each ring.)
        ### Place Your Code Here ###

def onStep():
    # Rotates each ring its correct direction.
    for ring in allRings:
        if (ring.clockwise == True):
            ring.rotateAngle += 1
        else:
            ring.rotateAngle -= 1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('violet', 'navy', start='top')

allRings = Group()


def makeNRings(n):
    # Creates n rings of circles with the first ring's properties defined here.
    ringRadius = 15
    numCircles = 4
    circleRadius = 20
    clockwise = False

    # Creates each of the rings.
    for ring in range(n):
        angleBetweenCircles = 360 / numCircles
        newRing = Group()
        newRing.clockwise = clockwise

        # Draw the circles in the new ring, and add them to the newRing group.
        for c in range(numCircles):
            if ((ring == 0) and (c % 2 == 0)):
                color = 'crimson'
            elif (ring == 0):
                color = 'dodgerblue'
            else:
                color = rgb(255, 220, ring * 60)

            x, y = getPointInDir(200, 200, angleBetweenCircles * c, ringRadius)
            newRing.add(
                Circle(x, y, circleRadius, fill=color)
                )
        allRings.add(newRing)

        # Update the ring radius, number of circles, circle radius, and
        # clockwise bool.
        ringRadius += 50
        numCircles *= 2
        circleRadius /= 2
        clockwise = not clockwise

def onStep():
    # Rotates each ring its correct direction.
    for ring in allRings:
        if (ring.clockwise == True):
            ring.rotateAngle += 1
        else:
            ring.rotateAngle -= 1
",regular,3
2240,Creative task 3,8.5,# Fill me in!,,creative,30
2241,Creative task 4,8.5,# Fill me in!,,creative,30
2242,Creative task 5,8.5,# Fill me in!,,creative,30
2243,Collaborative task,8.5,# Fill me in!,,creative,30
2237,Lightning,8.5,"app.background = gradient('black', 'slateGrey', start='top')

# Sets a number of steps for how long a flash lasts.
app.stepsOfFlash = 6

# Sets how many steps until you see another set of lighning bolts.
app.stepsBetweenFlash = 15

lightning = Group()

clouds = Group(
    Circle(42, 50, 70, fill='grey', border='dimGrey'),
    Circle(162, 50, 120, fill='grey', border='dimGrey'),
    Circle(342, 50, 90, fill='grey', border='dimGrey'),
    Rect(0, 0, 400, 85, fill='grey')
    )

def makeLightningBolt(startX, startY):
    x1 = startX
    y1 = startY

    # Each lightning bolt is formed by 25 pieces: 25 lines that create a random
    # downward zigzag effect.
    for boltPiece in range(25):
        # Define a variable to give each bolt piece a random lineWidth between
        # 1 and 2 (inclusive).
        randomWidth = randrange(1, 3)

        # Define a variable x2 that is within 15 pixels of the x1.
        x2 = x1 + randrange(-15, 16)

        # Draw the lightning bolt segment to go down by a random distance
        # between 5 and 20 (inclusive).
        if (boltPiece == 24):
            y2 = 400
        else:
            y2 = y1 + randrange(5, 21)

        # Add a new line to the lightning Group.
        lightning.add(
            Line(x1, y1, x2, y2, fill='aliceBlue', lineWidth=randomWidth)
            )

        # The next bolt piece should start where this one ends.
        x1 = x2
        y1 = y2

def onStep():
    app.stepsBetweenFlash -= 1

    if (app.stepsBetweenFlash == 0):
        # Each lightning strike is made up of 4 individual lightning bolts.
        # Initializes where the bolts start here so each bolt has the same
        # starting position and stays close to the other bolts.
        startX = randrange(50, 350)
        startY = 100
        for bolt in range(4):
            makeLightningBolt(startX, startY)

        # Changes the clouds fill, and the background.
        clouds.fill = 'gainsboro'
        app.background = gradient('dimGrey', rgb(170, 180, 200), start='top')

        # Resets flash steps to 15, and steps of the flash to 6.
        app.stepsBetweenFlash = 15
        app.stepsOfFlash = 6

    # Decreases the number of steps the flash has been on for until it gets to 0.
    if (app.stepsOfFlash > 0):
        app.stepsOfFlash -= 1

    # When the strike has been on the canvas long enough, removes the lightning,
    # and changes the fills back to their original values.
    if (app.stepsOfFlash == 0):
        lightning.clear()
        clouds.fill = 'grey'
        app.background = gradient('black', 'slateGrey', start='top')
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('black', 'slateGrey', start='top')

# Sets a number of steps for how long a flash lasts.
app.stepsOfFlash = 6

# Sets how many steps until you see another set of lighning bolts.
app.stepsBetweenFlash = 15

lightning = Group()

clouds = Group(
    Circle(42, 50, 70, fill='grey', border='dimGrey'),
    Circle(162, 50, 120, fill='grey', border='dimGrey'),
    Circle(342, 50, 90, fill='grey', border='dimGrey'),
    Rect(0, 0, 400, 85, fill='grey')
    )

def makeLightningBolt(startX, startY):
    x1 = startX
    y1 = startY

    # Each lightning bolt is formed by 25 pieces: 25 lines that create a random
    # downward zigzag effect.
    for boltPiece in range(25):
        # Define a variable to give each bolt piece a random lineWidth between
        # 1 and 2 (inclusive).
        randomWidth = randrange(1, 3)

        # Define a variable x2 that is within 15 pixels of the x1.
        x2 = x1 + randrange(-15, 16)

        # Draw the lightning bolt segment to go down by a random distance
        # between 5 and 20 (inclusive).
        if (boltPiece == 24):
            y2 = 400
        else:
            y2 = y1 + randrange(5, 21)

        # Add a new line to the lightning Group.
        lightning.add(
            Line(x1, y1, x2, y2, fill='aliceBlue', lineWidth=randomWidth)
            )

        # The next bolt piece should start where this one ends.
        x1 = x2
        y1 = y2

def onStep():
    app.stepsBetweenFlash -= 1

    if (app.stepsBetweenFlash == 0):
        # Each lightning strike is made up of 4 individual lightning bolts.
        # Initializes where the bolts start here so each bolt has the same
        # starting position and stays close to the other bolts.
        startX = randrange(50, 350)
        startY = 100
        for bolt in range(4):
            makeLightningBolt(startX, startY)

        # Changes the clouds fill, and the background.
        clouds.fill = 'gainsboro'
        app.background = gradient('dimGrey', rgb(170, 180, 200), start='top')

        # Resets flash steps to 15, and steps of the flash to 6.
        app.stepsBetweenFlash = 15
        app.stepsOfFlash = 6

    # Decreases the number of steps the flash has been on for until it gets to 0.
    if (app.stepsOfFlash > 0):
        app.stepsOfFlash -= 1

    # When the strike has been on the canvas long enough, removes the lightning,
    # and changes the fills back to their original values.
    if (app.stepsOfFlash == 0):
        lightning.clear()
        clouds.fill = 'grey'
        app.background = gradient('black', 'slateGrey', start='top')
",sample,1
2238,Creative task 1,8.5,# Fill me in!,,creative,30
2239,Creative task 2,8.5,# Fill me in!,,creative,30
2236,Animal pond,8.5,"app.background = gradient('wheat', 'wheat', 'tan')

app.steps = 0
app.isFaceUp = False

# lake
Circle(200, 200, 200, fill=gradient('blue', 'blue', rgb(30, 145, 255)), opacity=50)
fishes = Group()
Circle(200, 200, 190, fill=gradient('blue', 'blue', rgb(30, 145, 255)), opacity=50)

# island
Circle(200, 200, 80, fill=gradient('brown', 'wheat'))
Star(200, 200, 100, 10, fill=gradient('yellowGreen', 'green'), roundness=25)

catFaceDown = Group()
catBodies = Group()
catFaceUp = Group()

def drawFish(centerX, centerY, color):
    finColor = gradient(color, color, 'silver', 'silver', start='left-top')
    fish = Group(
        Star(centerX - 12, centerY, 10, 3, fill=finColor, roundness=35,
             rotateAngle=-30),
        RegularPolygon(centerX - 1, centerY - 6, 6, 3, fill=finColor,
                       rotateAngle=10),
        Oval(centerX, centerY, 22, 12,
             fill=gradient('silver', 'white', start='top')),
        Circle(centerX + 6, centerY - 2, 1),
        Line(centerX + 3, centerY - 5, centerX + 1, centerY, lineWidth=0.5),
        Line(centerX, centerY, centerX + 2, centerY + 5, lineWidth=0.5),
        Arc(centerX, centerY + 1, 7, 3, 135, 270, fill=finColor)
        )

    # Gets a random direction to move and rotate the fish to swim in that direction.
    fish.dx = randrange(-4, 5)
    fish.dy = randrange(-4, 5)
    fish.rotateAngle = angleTo(fish.centerX, fish.centerY, fish.centerX + fish.dx,
                               fish.centerY + fish.dy) - 90
    fishes.add(fish)

def drawTwoCats(centerY):
    # Draws a cat on the left at the centerY.
    leftFaceDown = Group(
        Circle(66, centerY, 28, fill='grey'),
        Arc(84, centerY + 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=-135),
        Arc(84, centerY - 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=135)
        )
    leftCatBody = Oval(10, centerY, 100, 70, fill=gradient('darkGrey', 'grey'))
    leftFaceUp = Group(
        Circle(66, centerY, 28, fill=gradient('dimGrey', 'grey', start='right')),
        Arc(50, centerY + 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=135),
        Arc(50, centerY - 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=-135),
        Circle(60, centerY - 10, 3),
        Circle(60, centerY + 10, 3),
        Arc(75, centerY, 15, 12, 45, 90)
        )
    leftFaceUp.visible = False

    # Draws a cat on the right at the centerY.
    rightFaceDown = Group(
        Circle(344, centerY, 28, fill='grey'),
        Arc(328, centerY + 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=-45),
        Arc(328, centerY - 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=45),
        )
    rightCatBody = Oval(390, centerY, 100, 70, fill=gradient('darkGrey', 'grey'))
    rightFaceUp = Group(
        Circle(334, centerY, 28, fill=gradient('dimGrey', 'grey', start='left')),
        Arc(350, centerY + 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=45),
        Arc(350, centerY - 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=-45),
        Circle(340, centerY - 10, 3),
        Circle(340, centerY + 10, 3),
        Arc(325, centerY, 15, 12, 225, 90)
        )
    rightFaceUp.visible = False

    catFaceDown.add(rightFaceDown)
    catFaceDown.add(leftFaceDown)
    catBodies.add(rightCatBody)
    catBodies.add(leftCatBody)
    catFaceUp.add(rightFaceUp)
    catFaceUp.add(leftFaceUp)

def createCats():
    # Draws 4 rows of two cats.
    for centerY in range(80, 380, 80):
        drawTwoCats(centerY)

def createFish():
    # Creates a grid of fish.
    for i in range(110, 300, 60):
        for j in range(105, 300, 25):
            chance = randrange(0, 3)
            if (chance == 0):
                color = 'red'
            elif (chance == 1):
                color = 'green'
            else:
                color = 'blue'

            drawFish(i, j, color)

def moveFishes():
    # Moves the fish around the lake.
    for fish in fishes:
        fish.centerX += fish.dx
        fish.centerY += fish.dy
        # When the fish are near the edge of the lake, places them at a new
        # random point around the edge of the lake.
        if (distance(200, 200, fish.centerX, fish.centerY) > 175):
            x, y = getPointInDir(200, 200, randrange(0, 360), 165)
            fish.centerX = x
            fish.centerY = y
            fish.opacity = 100

        # If the fish is close to the edge of the lake, halve its opacity.
        elif (distance(200, 200, fish.centerX, fish.centerY) > 165):
            fish.opacity //= 2

def moveCatHeads():
    # Shows the correct-facing head.
    if (app.isFaceUp == True):
        catFaceUp.visible = True
        catFaceDown.visible = False
    else:
        catFaceUp.visible = False
        catFaceDown.visible = True

def onStep():
    moveFishes()
    moveCatHeads()

    # Keeps track of when the head should be up or down.
    if (app.steps == 55):
        app.isFaceUp = True
    elif (app.steps >= 80):
        app.isFaceUp = False
        app.steps = 0

    app.steps += 1

createFish()
createCats()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('wheat', 'wheat', 'tan')

app.steps = 0
app.isFaceUp = False

# lake
Circle(200, 200, 200, fill=gradient('blue', 'blue', rgb(30, 145, 255)), opacity=50)
fishes = Group()
Circle(200, 200, 190, fill=gradient('blue', 'blue', rgb(30, 145, 255)), opacity=50)

# island
Circle(200, 200, 80, fill=gradient('brown', 'wheat'))
Star(200, 200, 100, 10, fill=gradient('yellowGreen', 'green'), roundness=25)

catFaceDown = Group()
catBodies = Group()
catFaceUp = Group()

def drawFish(centerX, centerY, color):
    finColor = gradient(color, color, 'silver', 'silver', start='left-top')
    fish = Group(
        Star(centerX - 12, centerY, 10, 3, fill=finColor, roundness=35,
             rotateAngle=-30),
        RegularPolygon(centerX - 1, centerY - 6, 6, 3, fill=finColor,
                       rotateAngle=10),
        Oval(centerX, centerY, 22, 12,
             fill=gradient('silver', 'white', start='top')),
        Circle(centerX + 6, centerY - 2, 1),
        Line(centerX + 3, centerY - 5, centerX + 1, centerY, lineWidth=0.5),
        Line(centerX, centerY, centerX + 2, centerY + 5, lineWidth=0.5),
        Arc(centerX, centerY + 1, 7, 3, 135, 270, fill=finColor)
        )

    # Gets a random direction to move and rotate the fish to swim in that direction.
    fish.dx = randrange(-4, 5)
    fish.dy = randrange(-4, 5)
    fish.rotateAngle = angleTo(fish.centerX, fish.centerY, fish.centerX + fish.dx,
                               fish.centerY + fish.dy) - 90
    fishes.add(fish)

def drawTwoCats(centerY):
    # Draws a cat on the left at the centerY.
    leftFaceDown = Group(
        Circle(66, centerY, 28, fill='grey'),
        Arc(84, centerY + 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=-135),
        Arc(84, centerY - 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=135)
        )
    leftCatBody = Oval(10, centerY, 100, 70, fill=gradient('darkGrey', 'grey'))
    leftFaceUp = Group(
        Circle(66, centerY, 28, fill=gradient('dimGrey', 'grey', start='right')),
        Arc(50, centerY + 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=135),
        Arc(50, centerY - 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=-135),
        Circle(60, centerY - 10, 3),
        Circle(60, centerY + 10, 3),
        Arc(75, centerY, 15, 12, 45, 90)
        )
    leftFaceUp.visible = False

    # Draws a cat on the right at the centerY.
    rightFaceDown = Group(
        Circle(344, centerY, 28, fill='grey'),
        Arc(328, centerY + 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=-45),
        Arc(328, centerY - 15, 25, 15, 180, 180,
            fill=gradient('darkGrey', 'grey'), rotateAngle=45),
        )
    rightCatBody = Oval(390, centerY, 100, 70, fill=gradient('darkGrey', 'grey'))
    rightFaceUp = Group(
        Circle(334, centerY, 28, fill=gradient('dimGrey', 'grey', start='left')),
        Arc(350, centerY + 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=45),
        Arc(350, centerY - 15, 25, 15, 0, 180,
            fill=gradient('darkGrey', 'darkGrey'), rotateAngle=-45),
        Circle(340, centerY - 10, 3),
        Circle(340, centerY + 10, 3),
        Arc(325, centerY, 15, 12, 225, 90)
        )
    rightFaceUp.visible = False

    catFaceDown.add(rightFaceDown)
    catFaceDown.add(leftFaceDown)
    catBodies.add(rightCatBody)
    catBodies.add(leftCatBody)
    catFaceUp.add(rightFaceUp)
    catFaceUp.add(leftFaceUp)

def createCats():
    # Draws 4 rows of two cats.
    for centerY in range(80, 380, 80):
        drawTwoCats(centerY)

def createFish():
    # Creates a grid of fish.
    for i in range(110, 300, 60):
        for j in range(105, 300, 25):
            chance = randrange(0, 3)
            if (chance == 0):
                color = 'red'
            elif (chance == 1):
                color = 'green'
            else:
                color = 'blue'

            drawFish(i, j, color)

def moveFishes():
    # Moves the fish around the lake.
    for fish in fishes:
        fish.centerX += fish.dx
        fish.centerY += fish.dy
        # When the fish are near the edge of the lake, places them at a new
        # random point around the edge of the lake.
        if (distance(200, 200, fish.centerX, fish.centerY) > 175):
            x, y = getPointInDir(200, 200, randrange(0, 360), 165)
            fish.centerX = x
            fish.centerY = y
            fish.opacity = 100

        # If the fish is close to the edge of the lake, halve its opacity.
        elif (distance(200, 200, fish.centerX, fish.centerY) > 165):
            fish.opacity //= 2

def moveCatHeads():
    # Shows the correct-facing head.
    if (app.isFaceUp == True):
        catFaceUp.visible = True
        catFaceDown.visible = False
    else:
        catFaceUp.visible = False
        catFaceDown.visible = True

def onStep():
    moveFishes()
    moveCatHeads()

    # Keeps track of when the head should be up or down.
    if (app.steps == 55):
        app.isFaceUp = True
    elif (app.steps >= 80):
        app.isFaceUp = False
        app.steps = 0

    app.steps += 1

createFish()
createCats()
",sample,1
2246,Treasure hunt,9.1.3,"app.background = 'lightSkyBlue'

# islands
Oval(270, 140, 200, 100, fill='wheat', rotateAngle=25)
Oval(150, 270, 180, 150, fill='wheat', rotateAngle=15)
Oval(200, 200, 250, 180, fill='mediumAquamarine', border='wheat', borderWidth=20)
Oval(265, 145, 140, 60, fill='mediumAquamarine', rotateAngle=25)
Oval(155, 265, 140, 110, fill='mediumAquamarine', rotateAngle=15)
Oval(50, 5, 200, 150, fill='mediumAquamarine', border='wheat', borderWidth=20)

# boat
Arc(330, 330, 70, 50, 90, 180, fill='sienna')
RegularPolygon(330, 310, 25, 3, fill='white')
Line(330, 285, 330, 330, fill='saddleBrown', lineWidth=3)
Star(330, 400, 53, 20, fill='lightSkyBlue', roundness=95)

# treasure
Line(200, 110, 230, 140, fill='crimson', lineWidth=8)
Line(200, 140, 230, 110, fill='crimson', lineWidth=8)
Line(190, 140, 180, 150, fill='crimson', lineWidth=3)
Line(175, 155, 170, 170, fill='crimson', lineWidth=3)
Line(170, 175, 180, 190, fill='crimson', lineWidth=3)
Line(185, 195, 190, 215, fill='crimson', lineWidth=3)
Line(190, 220, 205, 235, fill='crimson', lineWidth=3)
Line(210, 240, 220, 255, fill='crimson', lineWidth=3)
Line(225, 260, 245, 270, fill='crimson', lineWidth=3)
Line(250, 273, 270, 288, fill='crimson', lineWidth=3)
Line(180, 215, 160, 215, fill='crimson', lineWidth=3)
Line(155, 220, 145, 240, fill='crimson', lineWidth=3)
Line(145, 245, 165, 260, fill='crimson', lineWidth=3)
Line(170, 260, 185, 250, fill='crimson', lineWidth=3)
Line(185, 245, 185, 225, fill='crimson', lineWidth=3)

xLabel = Label('x = ' + str(0), 0, 0, size=20, bold=True)
yLabel = Label('y = ' + str(20), 0, 20, size=20, bold=True)

message = Label('You are very cold.', 200, 20, size=15, bold=True)

def onMouseMove(mouseX, mouseY):
    # Set the x label's position and value using mouseX and mouseY.
    ### Place Your Code Here ###

    # Set the y label's position and value using mouseX and mouseY.
    ### Place Your Code Here ###

    if (distance(mouseX, mouseY, 215, 125) <= 25):
        message.value = 'You are very close!!!'
    elif (distance(mouseX, mouseY, 215, 125) <= 100):
        message.value = 'Getting warmer!'
    else:
        message.value = 'You are very cold.'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightSkyBlue'

# islands
Oval(270, 140, 200, 100, fill='wheat', rotateAngle=25)
Oval(150, 270, 180, 150, fill='wheat', rotateAngle=15)
Oval(200, 200, 250, 180, fill='mediumAquamarine', border='wheat', borderWidth=20)
Oval(265, 145, 140, 60, fill='mediumAquamarine', rotateAngle=25)
Oval(155, 265, 140, 110, fill='mediumAquamarine', rotateAngle=15)
Oval(50, 5, 200, 150, fill='mediumAquamarine', border='wheat', borderWidth=20)

# boat
Arc(330, 330, 70, 50, 90, 180, fill='sienna')
RegularPolygon(330, 310, 25, 3, fill='white')
Line(330, 285, 330, 330, fill='saddleBrown', lineWidth=3)
Star(330, 400, 53, 20, fill='lightSkyBlue', roundness=95)

# treasure
Line(200, 110, 230, 140, fill='crimson', lineWidth=8)
Line(200, 140, 230, 110, fill='crimson', lineWidth=8)
Line(190, 140, 180, 150, fill='crimson', lineWidth=3)
Line(175, 155, 170, 170, fill='crimson', lineWidth=3)
Line(170, 175, 180, 190, fill='crimson', lineWidth=3)
Line(185, 195, 190, 215, fill='crimson', lineWidth=3)
Line(190, 220, 205, 235, fill='crimson', lineWidth=3)
Line(210, 240, 220, 255, fill='crimson', lineWidth=3)
Line(225, 260, 245, 270, fill='crimson', lineWidth=3)
Line(250, 273, 270, 288, fill='crimson', lineWidth=3)
Line(180, 215, 160, 215, fill='crimson', lineWidth=3)
Line(155, 220, 145, 240, fill='crimson', lineWidth=3)
Line(145, 245, 165, 260, fill='crimson', lineWidth=3)
Line(170, 260, 185, 250, fill='crimson', lineWidth=3)
Line(185, 245, 185, 225, fill='crimson', lineWidth=3)

xLabel = Label('x = ' + str(0), 0, 0, size=20, bold=True)
yLabel = Label('y = ' + str(20), 0, 20, size=20, bold=True)

message = Label('You are very cold.', 200, 20, size=15, bold=True)

def onMouseMove(mouseX, mouseY):
    # Set the x label's position and value using mouseX and mouseY.
    xLabel.centerX = mouseX
    xLabel.centerY = mouseY
    xLabel.value = 'x = ' + str(mouseX)

    # Set the y label's position and value using mouseX and mouseY.
    yLabel.centerX = mouseX
    yLabel.centerY = mouseY + 20
    yLabel.value = 'y = ' + str(mouseY)

    if (distance(mouseX, mouseY, 215, 125) <= 25):
        message.value = 'You are very close!!!'
    elif (distance(mouseX, mouseY, 215, 125) <= 100):
        message.value = 'Getting warmer!'
    else:
        message.value = 'You are very cold.'
",regular,1
2247,Apple addition,9.1.3,"# chalkboard
Rect(0, 0, 400, 400, fill=rgb(70, 70, 70), border='saddleBrown', borderWidth=15)
Rect(300, 375, 60, 10, fill='white')
Label('+', 200, 110, fill='white', size=60)
Label('=', 200, 230, fill='white', size=60)

# sum and summation statement
sumResult = Label('', 200, 290, fill='white', size=60)
statement = Label('', 200, 340, fill='white', size=12)

apples = Group()

def drawApple(x, y, color):
    # Draws an apple of the color and at the coordinates given.
    apples.add(
        Circle(x, y, 12, fill=color),
        Oval(x - 5, y - 12, 10, 5, fill='lightGreen', rotateAngle=20)
        )

def drawManyApples(num1, num2):
    # Draws multiple apples in a line.
    for i in range(num1):
        drawApple(i * 30 + 50, 50, 'lightCoral')

    for i in range(num2):
        drawApple(i * 30 + 50, 170, 'yellowGreen')

def onKeyPress(key):
    # Erases the chalkboard.
    apples.clear()

    # Asks for two one digit numbers.
    numRedApples = app.getTextInput('Give me a one digit number')
    numGreenApples = app.getTextInput('Give me another one digit number')

    # Using the two numbers inputted, draw the correct number of apples.
    # Modify the values of the sumResult label and the statement label
    # to describe the inputted math problem.
    ### (HINT: Use the helper function drawManyApples to help draw the apples.)
    ### Fix Your Code Here ###
    statement.value = '_ red apples and _ green apples makes _ apples total!'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# chalkboard
Rect(0, 0, 400, 400, fill=rgb(70, 70, 70), border='saddleBrown', borderWidth=15)
Rect(300, 375, 60, 10, fill='white')
Label('+', 200, 110, fill='white', size=60)
Label('=', 200, 230, fill='white', size=60)

# sum and summation statement
sumResult = Label('', 200, 290, fill='white', size=60)
statement = Label('', 200, 340, fill='white', size=12)

apples = Group()

def drawApple(x, y, color):
    # Draws an apple of the color and at the coordinates given.
    apples.add(
        Circle(x, y, 12, fill=color),
        Oval(x - 5, y - 12, 10, 5, fill='lightGreen', rotateAngle=20)
        )

def drawManyApples(num1, num2):
    # Draws multiple apples in a line.
    for i in range(num1):
        drawApple(i * 30 + 50, 50, 'lightCoral')

    for i in range(num2):
        drawApple(i * 30 + 50, 170, 'yellowGreen')

def onKeyPress(key):
    # Erases the chalkboard.
    apples.clear()

    # Asks for two one digit numbers.
    numRedApples = app.getTextInput('Give me a one digit number')
    numGreenApples = app.getTextInput('Give me another one digit number')

    integer1 = int(numRedApples)
    integer2 = int(numGreenApples)
    drawManyApples(integer1, integer2)
    sumResult.value = integer1 + integer2
    statement.value = (numRedApples + ' red apples and ' +
                       numGreenApples + ' green apples makes ' +
                       str(sumResult.value) + ' apples total!')
",regular,1
2248,Bad chatbot,9.1.3,"app.count = 0

# background
Rect(0, 0, 400, 400, fill=None, border='gainsboro', borderWidth=20)

Rect(35, 355, 300, 22, fill='lightGrey', border='darkGrey', opacity=50)
Rect(340, 355, 30, 22, fill='lightGrey', border='darkGrey', opacity=50)
Polygon(345, 360, 350, 367.5, 345, 375, 370, 367.5, fill='lightGrey')
messageCount = Label('message count: 0', 370, 350, fill='dimGrey', size=10,
                     align='right')
Label('Press any key to enter a message', 45, 365, fill='dimGrey', size=10,
      align='left')

chatHistory = Group()

def createMessage(message, person):
    # Creates a blue or grey chat bubble depending on whose message it is.
    chatHistory.centerY -= 60
    app.count += 1
    if (person == 'user'):
        chatHistory.add(
            Rect(120, 300, 240, 50, fill='royalBlue'),
            RegularPolygon(360, 345, 10, 3, fill='royalBlue'),
            Label(message, 125, 325, fill='white', align='left')
            )
    elif (person == 'bot'):
        chatHistory.add(
            Rect(40, 300, 240, 50, fill='gainsboro'),
            RegularPolygon(40, 345, 10, 3, fill='gainsboro'),
            Label(message, 275, 325, align='right')
            )

def onKeyPress(key):
    # Send a user message and its corresponding bot message to the chat.
    # The message count at the bottom of the screen should be updated.
    ### (HINT: We provide you with a createMessage helper function to send
    #          messages and an app.count custom property to keep track of
    #          the number of messages.)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.count = 0

# background
Rect(0, 0, 400, 400, fill=None, border='gainsboro', borderWidth=20)

Rect(35, 355, 300, 22, fill='lightGrey', border='darkGrey', opacity=50)
Rect(340, 355, 30, 22, fill='lightGrey', border='darkGrey', opacity=50)
Polygon(345, 360, 350, 367.5, 345, 375, 370, 367.5, fill='lightGrey')
messageCount = Label('message count: 0', 370, 350, fill='dimGrey', size=10,
                     align='right')
Label('Press any key to enter a message', 45, 365, fill='dimGrey', size=10,
      align='left')

chatHistory = Group()

def createMessage(message, person):
    # Creates a blue or grey chat bubble depending on whose message it is.
    chatHistory.centerY -= 60
    app.count += 1
    if (person == 'user'):
        chatHistory.add(
            Rect(120, 300, 240, 50, fill='royalBlue'),
            RegularPolygon(360, 345, 10, 3, fill='royalBlue'),
            Label(message, 125, 325, fill='white', align='left')
            )
    elif (person == 'bot'):
        chatHistory.add(
            Rect(40, 300, 240, 50, fill='gainsboro'),
            RegularPolygon(40, 345, 10, 3, fill='gainsboro'),
            Label(message, 275, 325, align='right')
            )

def onKeyPress(key):
    message = app.getTextInput()
    createMessage(message, 'user')
    createMessage(message + ', ok mhmm', 'bot')
    messageCount.value = 'message count: ' + str(app.count)
",regular,1
2249,Madlibs,9.1.3,"# lines on the paper
Line(200, 50, 200, 400, fill='royalBlue', lineWidth=400, opacity=50, dashes=(1, 19))
Line(30, 0, 30, 400, fill='red', opacity=50)

# title
Label('The Trip to the Dentist: A One Act Play', 220, 25, size=18)

Label('Patient: Thank you Dr. ________ for meeting me on such _______ notice',
      40, 60, size=11, align='left')
Label(""Doctor: What's the problem, ________________?"", 40, 80, size=11,
      align='left')
Label('Patient: I have a pain in my upper ___________ which is giving me a',
      40, 100, size=11, align='left')
Label('severe _____________ache.', 40, 120, size=11, align='left')
Label(""Doctor: Let me take a look. Open wide... Good. Now I'm going to"",
      40, 140, size=11, align='left')
Label('_______________ your ___________ with my forceps.',
      40, 160, size=11, align='left')
Label(""Patient: Shouldn\'t you give me a ____________ killer?"",
      40, 180, size=11, align='left')
Label(""Doctor: It shouldn't be necessary. _____________________! I think I see"",
      40, 200, size=11, align='left')
Label('a ____________ in your upper ____________.',
      40, 220, size=11, align='left')
Label('Patient: Are you going to pull my ____________ out?',
      40, 240, size=11, align='left')
Label(""Doctor: No, I'm just going to __________ your tooth and put it in a"",
      40, 260, size=11, align='left')
Label('temporary ____________.',
      40, 280, size=11, align='left')
Label('Patient: And how much is this procedure gonna run me?',
      40, 300, size=11, align='left')
Label('Doctor: ____________  dollars, paid in __________________________.',
      40, 320, size=11, align='left')

# filled in blanks
Label('Gravy', 175, 60)
Label('rainy', 340, 60)
Label('Guy Fieri', 230, 80)
Label('earlobe', 240, 100)
Label('heart', 115, 120)
Label('discombobulate', 88, 160)
Label('tounge', 193, 160)
Label('bug', 233, 180)
Label('Oof, wowzers', 266, 200)
Label('giraffe', 83, 220)
Label('antechamber', 230, 220)
Label('brain', 234, 240)
Label('skin graft', 207, 260)
Label('stromboli', 130, 280)

# blank lines
blank1 = Rect(78, 312, 72, 12, fill='gainsboro')
blank2 = Rect(236, 312, 150, 12, fill='gainsboro')

def onMousePress(mouseX, mouseY):
    if (blank1.contains(mouseX, mouseY) == True):
        # Get a number from the user. Use this number to decide what the label
        # should say.
        ### Place Your Code Here ###
        pass

    elif (blank2.contains(mouseX, mouseY) == True):
        word = app.getTextInput('Input a plural Noun')
        Label(word, 310, 318)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# lines on the paper
Line(200, 50, 200, 400, fill='royalBlue', lineWidth=400, opacity=50, dashes=(1, 19))
Line(30, 0, 30, 400, fill='red', opacity=50)

# title
Label('The Trip to the Dentist: A One Act Play', 220, 25, size=18)

Label('Patient: Thank you Dr. ________ for meeting me on such _______ notice',
      40, 60, size=11, align='left')
Label(""Doctor: What's the problem, ________________?"", 40, 80, size=11,
      align='left')
Label('Patient: I have a pain in my upper ___________ which is giving me a',
      40, 100, size=11, align='left')
Label('severe _____________ache.', 40, 120, size=11, align='left')
Label(""Doctor: Let me take a look. Open wide... Good. Now I'm going to"",
      40, 140, size=11, align='left')
Label('_______________ your ___________ with my forceps.',
      40, 160, size=11, align='left')
Label(""Patient: Shouldn\'t you give me a ____________ killer?"",
      40, 180, size=11, align='left')
Label(""Doctor: It shouldn't be necessary. _____________________! I think I see"",
      40, 200, size=11, align='left')
Label('a ____________ in your upper ____________.',
      40, 220, size=11, align='left')
Label('Patient: Are you going to pull my ____________ out?',
      40, 240, size=11, align='left')
Label(""Doctor: No, I'm just going to __________ your tooth and put it in a"",
      40, 260, size=11, align='left')
Label('temporary ____________.',
      40, 280, size=11, align='left')
Label('Patient: And how much is this procedure gonna run me?',
      40, 300, size=11, align='left')
Label('Doctor: ____________  dollars, paid in __________________________.',
      40, 320, size=11, align='left')

# filled in blanks
Label('Gravy', 175, 60)
Label('rainy', 340, 60)
Label('Guy Fieri', 230, 80)
Label('earlobe', 240, 100)
Label('heart', 115, 120)
Label('discombobulate', 88, 160)
Label('tounge', 193, 160)
Label('bug', 233, 180)
Label('Oof, wowzers', 266, 200)
Label('giraffe', 83, 220)
Label('antechamber', 230, 220)
Label('brain', 234, 240)
Label('skin graft', 207, 260)
Label('stromboli', 130, 280)

# blank lines
blank1 = Rect(78, 312, 72, 12, fill='gainsboro')
blank2 = Rect(236, 312, 150, 12, fill='gainsboro')

def onMousePress(mouseX, mouseY):
    if (blank1.contains(mouseX, mouseY) == True):
        # Get a number from the user. Use this number to decide what the label
        # should say.
        numString = app.getTextInput('Input a Number')
        money = int(numString)
        if (money < 1000):
            Label('Just ' + numString, 112, 318)
        else:
            Label(numString, 112, 318)

    elif (blank2.contains(mouseX, mouseY) == True):
        word = app.getTextInput('Input a plural Noun')
        Label(word, 310, 318)
",regular,1
2251,Letter grid,9.2.2,"app.background = 'black'

app.alphabet = 'abcdefghijklmnopqrstuvwxyz'
app.gridSize = 10

letters = Group()

def drawLetters(gridSize, letter):
    letters.clear()

    # Finds the amount of space between each letter and the starting
    # coordinate of the letters.
    spacing = 400 // (gridSize + 1)
    start = spacing // gridSize

    # Loops over each position in the grid.
    for x in range(start, 400, spacing):
        for y in range(start, 400, spacing):
            letterSize = randrange(20, 50)
            letterColor = rgb(randrange(150, 240), randrange(150, 240),
                              randrange(150, 240))

            # Add each letter to the letters group.
            ### Place Your Code Here ###
            pass

drawLetters(app.gridSize, 'i')

def onMousePress(mouseX, mouseY):
    # Update the letter by getting a random index between 0 and the length
    # of the alphabet. Then use that index to get the corresponding letter
    # of the alphabet and call drawLetters with the new letter and a
    # gridSize of index + 1.
    ### (HINT: Use the app.alphabet string defined above to pick the new letter.)
    ### Place Your Code Here ###
    # index =
    # newLetter =
    pass

def onStep():
    # Rotates each letter.
    for letter in letters:
        letter.rotateAngle += 5
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

app.alphabet = 'abcdefghijklmnopqrstuvwxyz'
app.gridSize = 10

letters = Group()

def drawLetters(gridSize, letter):
    letters.clear()

    # Finds the amount of space between each letter and the starting
    # coordinate of the letters.
    spacing = 400 // (gridSize + 1)
    start = spacing // gridSize

    # Loops over each position in the grid.
    for x in range(start, 400, spacing):
        for y in range(start, 400, spacing):
            letterSize = randrange(20, 50)
            letterColor = rgb(randrange(150, 240), randrange(150, 240),
                              randrange(150, 240))

            # Add each letter to the letters group.
            letters.add(
                Label(letter, x, y, fill=letterColor, size=letterSize)
                )

drawLetters(app.gridSize, 'i')

def onMousePress(mouseX, mouseY):
    # Update the letter by getting a random index between 0 and the length
    # of the alphabet. Then use that index to get the corresponding letter
    # of the alphabet and call drawLetters with the new letter and a
    # gridSize of index + 1.
    index = randrange(0, len(app.alphabet))
    newLetter = app.alphabet[index]
    drawLetters(index + 1, newLetter)

def onStep():
    # Rotates each letter.
    for letter in letters:
        letter.rotateAngle += 5
",regular,1
2252,Chasing letters,9.2.2,"app.background = 'black'
app.stepsPerSecond = 12

app.alphabet = 'abcdefghijklmnopqrstuvwxyz'
app.currentIndex = 0

letters = Group()

def drawLetters():
    # Draws the letters evenly spaced and add them to the letters group.
    spacing = 395 / len(app.alphabet)
    for i in range(len(app.alphabet)):
        x = 10 + i * spacing
        letters.add(
            Label(app.alphabet[i], x, 200, fill='white', size=15, bold=True)
            )

drawLetters()

def onStep():
    # Get the current letter by using the alphabet and app.currentIndex.
    ### Place Your Code Here ###
    # currentLetter =

    # Loops over the letters Group.
    for letter in letters:
        # Set the currentLetter's fill to red and increase its size.
        ### (HINT: Compare letter.value to currentLetter to find when
        #          letter is the currentLetter.)
        ### Place Your Code Here ###

        # Set all other letters' fills to white and decrease their size.
        ### Fix Your Code Here ###
        letter.fill = 'white'
        if (letter.size > 15):
            letter.size -= 3

    # Increase the currentIndex by 1 and reset to 0 if the end of the
    # alphabet is reached.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 12

app.alphabet = 'abcdefghijklmnopqrstuvwxyz'
app.currentIndex = 0

letters = Group()

def drawLetters():
    # Draws the letters evenly spaced and add them to the letters group.
    spacing = 395 / len(app.alphabet)
    for i in range(len(app.alphabet)):
        x = 10 + i * spacing
        letters.add(
            Label(app.alphabet[i], x, 200, fill='white', size=15, bold=True)
            )

drawLetters()

def onStep():
    # Get the current letter by using the alphabet and app.currentIndex.
    currentLetter = app.alphabet[app.currentIndex]

    # Loops over the letters Group.
    for letter in letters:
        # Set the currentLetter's fill to red and increase its size.
        if (letter.value == currentLetter):
            letter.fill = 'red'
            letter.size = 36

        # Set all other letters' fills to white and decrease their size.
        else:
            letter.fill = 'white'
            if (letter.size > 15):
                letter.size -= 3

    # Increase the currentIndex by 1 and reset to 0 if the end of the
    # alphabet is reached.
    app.currentIndex += 1
    if (app.currentIndex == len(app.alphabet)):
        app.currentIndex = 0
",regular,1
2253,Peace on earth,9.2.2,"app.background = gradient('white', 'dodgerBlue', start='bottom')

# the earth
earth = Circle(200, 200, 100, fill='royalBlue', border='black')
Polygon(176, 107, 188, 131, 167, 151, 170, 180, 150, 170, 130, 180, 115, 180,
        110, 160, 135, 130, fill='darkGreen')
Polygon(170, 180, 220, 170, 210, 190, 205, 200, 200, 220, 180, 280, 170, 250,
        160, 220, 160, 180, fill='darkGreen')
Polygon(230, 140, 240, 110, 290, 165, fill='darkGreen')
Circle(200, 200, 100, fill=None, border='black', borderWidth=6)

def drawMessage():
    message = 'PEACE ON EARTH '

    # Calculates the amount the angle should change between each letter.
    stepAngle = 360 / len(message)

    # Loops through the letters of the message to draw them separately.
    for i in range(len(message)):
        # Use getPointInDir and the stepAngle to calculate the (x, y) point for
        # each letter.
        ### (HINT: Use the radius of the circle + 15 for the distance.)
        ### Fix Your Code Here ###
        x, y = 0, 0

        # Use the stepAngle to also calculate the rotateAngle for each letter.
        ### Fix Your Code Here ###
        rAngle = stepAngle

        # Draw a label using the current character, position, and rotateAngle.
        ### Place Your Code Here ###

drawMessage()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('white', 'dodgerBlue', start='bottom')

# the earth
earth = Circle(200, 200, 100, fill='royalBlue', border='black')
Polygon(176, 107, 188, 131, 167, 151, 170, 180, 150, 170, 130, 180, 115, 180,
        110, 160, 135, 130, fill='darkGreen')
Polygon(170, 180, 220, 170, 210, 190, 205, 200, 200, 220, 180, 280, 170, 250,
        160, 220, 160, 180, fill='darkGreen')
Polygon(230, 140, 240, 110, 290, 165, fill='darkGreen')
Circle(200, 200, 100, fill=None, border='black', borderWidth=6)

def drawMessage():
    message = 'PEACE ON EARTH '

    # Calculates the amount the angle should change between each letter.
    stepAngle = 360 / len(message)

    # Loops through the letters of the message to draw them separately.
    for i in range(len(message)):
        # Use getPointInDir and the stepAngle to calculate the (x, y) point for
        # each letter.
        ### (HINT: Use the radius of the circle + 15 for the distance.)
        x, y = getPointInDir(200, 200, i * stepAngle, earth.radius + 15)

        # Use the stepAngle to also calculate the rotateAngle for each letter.
        rAngle = i * stepAngle

        # Draw a label using the current character, position, and rotateAngle.
        Label(message[i], x, y, size=30, rotateAngle=rAngle, bold=True)

drawMessage()
",regular,2
2250,Monkey Latin,9.2.2,"### For your reference, Monkey latin follows these rules:
#   - If the first letter of the word is a vowel, a 'way' is added to the end.
#   - If the first letter of the word is a consonant, the letter is put at the
#     end of the word and an 'ay' is added.

app.background = 'forestGreen'

# monkey
Arc(215, 270, 80, 70, 270, 180, fill=None, border='peru', borderWidth=16)
Arc(215, 270, 48, 38, 270, 180, fill='forestGreen')
Arc(280, 270, 80, 70, 90, 180, fill=None, border='peru', borderWidth=16)
Arc(280, 270, 48, 38, 90, 180, fill='forestGreen')
Circle(312, 270, 8, fill='peru')
Oval(180, 275, 50, 60, fill=rgb(190, 120, 50), rotateAngle=30)
Oval(70, 275, 50, 60, fill=rgb(190, 120, 50), rotateAngle=330)
Circle(125, 250, 65, fill='peru')
Oval(160, 235, 40, 70, fill=rgb(190, 120, 50), rotateAngle=40)
Oval(90, 235, 40, 70, fill=rgb(190, 120, 50), rotateAngle=320)
Oval(85, 310, 35, 20, fill='wheat')
Oval(165, 310, 35, 20, fill='wheat')
Circle(75, 170, 12, fill='wheat')
Circle(175, 170, 12, fill='wheat')
Circle(125, 172, 50, fill='peru')
Oval(125, 180, 60, 45, fill='wheat')
Circle(110, 165, 18, fill='wheat')
Circle(140, 165, 18, fill='wheat')
Oval(125, 177, 10, 5)
Circle(110, 165, 4)
Circle(140, 165, 4)

# speech bubble
Polygon(230, 95, 300, 85, 200, 145, fill='white', border='black')
Arc(200, 60, 300, 80, 168, 335, fill=None, border='black')
Oval(200, 60, 295, 75, fill='white')
translatedWord = Label('', 200, 60, size=18)

# tree
Rect(0, 0, 30, 400, fill=gradient('sienna', 'brown', start='right-top'))
Line(10, 335, 400, 335, fill=gradient('sienna', 'brown', start='right-top'),
     lineWidth=50)

Label('Press space to enter a word to translate', 215, 380, size=18, bold=True)

def speakMonkeyLatin():
    word = app.getTextInput()
    vowels = 'AEIOUaeiou'
    monkeyLatin = ''

    # If the first letter of the word is in the vowels string,
    # set monkeyLatin equal to that word + 'way'.
    ### Fix Your Code Here ###
    monkeyLatin = word + 'way'

    # Otherwise loop over the string, skipping the first letter.
    # Then put the first letter at the end and add 'ay'.
    ### Fix Your Code Here ###
    for index in range(0, len(word)):
        monkeyLatin += word[index]
    monkeyLatin += word[1]
    monkeyLatin += 'ay'

    translatedWord.value = monkeyLatin

def onKeyPress(key):
    if (key == 'space'):
        speakMonkeyLatin()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

### For your reference, Monkey latin follows these rules:
#   - If the first letter of the word is a vowel, a 'way' is added to the end.
#   - If the first letter of the word is a consonant, the letter is put at the
#     end of the word and an 'ay' is added.

app.background = 'forestGreen'

# monkey
Arc(215, 270, 80, 70, 270, 180, fill=None, border='peru', borderWidth=16)
Arc(215, 270, 48, 38, 270, 180, fill='forestGreen')
Arc(280, 270, 80, 70, 90, 180, fill=None, border='peru', borderWidth=16)
Arc(280, 270, 48, 38, 90, 180, fill='forestGreen')
Circle(312, 270, 8, fill='peru')
Oval(180, 275, 50, 60, fill=rgb(190, 120, 50), rotateAngle=30)
Oval(70, 275, 50, 60, fill=rgb(190, 120, 50), rotateAngle=330)
Circle(125, 250, 65, fill='peru')
Oval(160, 235, 40, 70, fill=rgb(190, 120, 50), rotateAngle=40)
Oval(90, 235, 40, 70, fill=rgb(190, 120, 50), rotateAngle=320)
Oval(85, 310, 35, 20, fill='wheat')
Oval(165, 310, 35, 20, fill='wheat')
Circle(75, 170, 12, fill='wheat')
Circle(175, 170, 12, fill='wheat')
Circle(125, 172, 50, fill='peru')
Oval(125, 180, 60, 45, fill='wheat')
Circle(110, 165, 18, fill='wheat')
Circle(140, 165, 18, fill='wheat')
Oval(125, 177, 10, 5)
Circle(110, 165, 4)
Circle(140, 165, 4)

# speech bubble
Polygon(230, 95, 300, 85, 200, 145, fill='white', border='black')
Arc(200, 60, 300, 80, 168, 335, fill=None, border='black')
Oval(200, 60, 295, 75, fill='white')
translatedWord = Label('', 200, 60, size=18)

# tree
Rect(0, 0, 30, 400, fill=gradient('sienna', 'brown', start='right-top'))
Line(10, 335, 400, 335, fill=gradient('sienna', 'brown', start='right-top'),
     lineWidth=50)

Label('Press space to enter a word to translate', 215, 380, size=18, bold=True)

def speakMonkeyLatin():
    word = app.getTextInput()
    vowels = 'AEIOUaeiou'
    monkeyLatin = ''

    # If the first letter of the word is in the vowels string,
    # set monkeyLatin equal to that word + 'way'.
    if (word[0] in vowels):
        monkeyLatin = word + 'way'

    # Otherwise loop over the string, skipping the first letter.
    # Then put the first letter at the end and add 'ay'.
    else:
        for index in range(1, len(word)):
            monkeyLatin += word[index]
        monkeyLatin += word[0]
        monkeyLatin += 'ay'

    translatedWord.value = monkeyLatin

def onKeyPress(key):
    if (key == 'space'):
        speakMonkeyLatin()
",regular,1
2254,Flying letters,9.2.2,"app.background = 'aliceBlue'
app.stepsPerSecond = 30
app.steps = 0

score = Label(0, 200, 200, fill='midnightBlue', size=80, font='monospace',
              bold=True)
keyWord = Label('keyword', 200, 50, fill='midnightBlue', size=40,
                font='monospace', bold=True)
Label('Press space to enter a new keyword', 200, 85, fill='midnightBlue',
      size=16, font='monospace')

bubbles = Group()

def onKeyPress(key):
    if (key == 'space'):
        # Lets the user enter a keyword.
        keyWord.value = app.getTextInput('Type in Your KeyWord')
    else:
        for bubble in bubbles.children:
            # If the key equals the bubble's letter, remove the bubble, and
            # add 1 to the score.
            ### Place Your Code Here ###
            pass

def onStep():
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    app.steps += 1

    # Every 10 steps, creates a new bubble with a random position and radius.
    if (app.steps % 10 == 0):
        bubbleX = randrange(0, 400)
        radius = randrange(30, 50)
        bubbleY = 400 + radius

        # Get a random letter from the alphabet.
        ### (HINT: Choose a random index for the alphabet string.)
        ### Fix Your Code Here ###
        letterIndex = 0
        letterInBubble = 'a'

        # If the letter is in the keyword, make its fill hotPink.
        # Otherwise, it should be deepSkyBlue.
        ### Fix Your Code Here ###
        bubbleColor = 'black'

        # Draws the bubble and the letter and adds them to the bubbles group.
        letterAndBubble = Group(
            Circle(bubbleX, bubbleY, radius, fill=bubbleColor, opacity=25),
            Label('i', bubbleX - (radius // 2), bubbleY + (radius // 2),
                  fill='aliceBlue', size=radius, rotateAngle=320, opacity=60,
                  bold=True),
            Label(letterInBubble, bubbleX, bubbleY, fill='white', size=40)
            )

        # Keeps track of the letter.
        letterAndBubble.letter = letterInBubble
        bubbles.add(letterAndBubble)

    # Updates the bubble's positions, removes any that move off the canvas,
    # and updates the score.
    for bubble in bubbles.children:
        bubble.centerY -= 5
        if (bubble.bottom < 0):
            bubbles.remove(bubble)

            # If the bubble's letter is in the keyWord, subtract 1 from the
            # score. Otherwise add 1.
            ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'aliceBlue'
app.stepsPerSecond = 30
app.steps = 0

score = Label(0, 200, 200, fill='midnightBlue', size=80, font='monospace',
              bold=True)
keyWord = Label('keyword', 200, 50, fill='midnightBlue', size=40,
                font='monospace', bold=True)
Label('Press space to enter a new keyword', 200, 85, fill='midnightBlue',
      size=16, font='monospace')

bubbles = Group()

def onKeyPress(key):
    if (key == 'space'):
        # Lets the user enter a keyword.
        keyWord.value = app.getTextInput('Type in Your KeyWord')
    else:
        for bubble in bubbles.children:
            # If the key equals the bubble's letter, remove the bubble, and
            # add 1 to the score.
            if (key == bubble.letter):
                score.value += 1
                bubbles.remove(bubble)

def onStep():
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    app.steps += 1

    # Every 10 steps, creates a new bubble with a random position and radius.
    if (app.steps % 10 == 0):
        bubbleX = randrange(0, 400)
        radius = randrange(30, 50)
        bubbleY = 400 + radius

        # Get a random letter from the alphabet.
        letterIndex = randrange(0, 26)
        letterInBubble = alphabet[letterIndex]

        # If the letter is in the keyword, make its fill hotPink.
        # Otherwise, it should be deepSkyBlue.
        if (letterInBubble in keyWord.value):
            bubbleColor = 'hotPink'
        else:
            bubbleColor = 'deepSkyBlue'

        # Draws the bubble and the letter and adds them to the bubbles group.
        letterAndBubble = Group(
            Circle(bubbleX, bubbleY, radius, fill=bubbleColor, opacity=25),
            Label('i', bubbleX - (radius // 2), bubbleY + (radius // 2),
                  fill='aliceBlue', size=radius, rotateAngle=320, opacity=60,
                  bold=True),
            Label(letterInBubble, bubbleX, bubbleY, fill='white', size=40)
            )

        # Keeps track of the letter.
        letterAndBubble.letter = letterInBubble
        bubbles.add(letterAndBubble)

    # Updates the bubble's positions, removes any that move off the canvas,
    # and updates the score.
    for bubble in bubbles.children:
        bubble.centerY -= 5
        if (bubble.bottom < 0):
            bubbles.remove(bubble)

            # If the bubble's letter is in the keyWord, subtract 1 from the
            # score. Otherwise add 1.
            if (bubble.letter in keyWord.value):
                score.value -= 1
            else:
                score.value += 1
",regular,2
2255,Guess the word,9.2.2,"# background
Rect(0, 0, 400, 350, fill=gradient('dodgerBlue', 'lightCyan', start='top'))
Rect(0, 350, 400, 110, fill=gradient('mediumSeaGreen', 'green', start='top'))

app.solution = ''
app.guesses = ''
app.numRight = 0
app.numWrong = 0
app.win = False
app.paused = True

instructions = Label('Press space to set the word', 200, 325, size=18,
                     bold=True)

upHouse = Group()

def makeBalloon(centerX, centerY, radius, color1, color2):
    # Draws a balloon and adds it to the upHouse group.
    balloon = Group(
        Line(200, 175, centerX, centerY, fill='white', lineWidth=1),
        Circle(centerX, centerY, radius,
               fill=gradient(color1, color2, start='right-top'))
        )
    balloon.type = 'balloon'
    upHouse.add(balloon)

makeBalloon(175, 2, 50, 'lightCoral', 'red')
makeBalloon(200, 50, 35, 'orange', 'orangeRed')
makeBalloon(260, 30, 45, 'plum', 'mediumVioletRed')
makeBalloon(150, 70, 30, 'lavenderBlush', 'pink')
makeBalloon(150, 15, 37, 'mediumPurple', 'darkOrchid')
makeBalloon(240, 1, 40, 'cornSilk', 'yellow')

# Draws the house and adds it to group upHouse.
house = Group(
    Rect(155, 260, 90, 10, fill='maroon'),
    Rect(160, 220, 40, 40, fill='pink'),
    Rect(200, 220, 40, 40, fill='lightGreen'),
    Polygon(150, 220, 250, 220, 240, 175, 160, 175, fill='darkSlateBlue'),
    Polygon(200, 220, 220, 190, 240, 220, fill='lemonChiffon'),
    Polygon(170, 208, 170, 195, 180, 185, 190, 195, 190, 208,
            fill='lemonChiffon'),
    Rect(180, 242, 12, 18, fill='maroon'),
    Rect(160, 220, 40, 15, fill='lightSkyBlue'),
    Rect(215, 232, 10, 18, fill='plum'),
    Rect(205, 232, 5, 18, fill='plum'),
    Rect(230, 232, 5, 18, fill='plum'),
    Rect(215, 205, 10, 12, fill='plum'),
    Rect(176, 193, 8, 10, fill='plum'),
    Rect(195, 165, 10, 18, fill='maroon'),
    Line(220, 190, 200, 220, fill='lightSkyBlue', lineWidth=5),
    Line(220, 190, 240, 220, fill='lightSkyBlue', lineWidth=5),
    Line(180, 185, 170, 195, fill='lightSkyBlue', lineWidth=5),
    Line(180, 185, 190, 195, fill='lightSkyBlue', lineWidth=5),
    Line(160, 220, 160, 260, fill='white', lineWidth=3),
    Line(160, 235, 200, 235, fill='white', lineWidth=3)
    )
house.type = 'house'
upHouse.add(house)

def drawInputLines():
    # Draws the lines that shows where the correct letters will be drawn.
    for index in range(len(app.solution)):
        lineCx = app.spacing * (index + 1 / 2)
        lineCy = 390
        Line(lineCx - 10, lineCy, lineCx + 10, lineCy, fill='white')

def drawLetter(index):
    # Draws a letter on the correct input line.
    letter = app.solution[index]
    letterX = app.spacing * (index + 1 / 2)
    letterY = 390
    Label(letter, letterX, letterY, fill='white', size=35, align='bottom')

def popBalloon():
    # Removes a balloon by setting its visibility to false.
    notChanged = False
    for housePart in upHouse:
        if (housePart.type == 'balloon'):
            if ((housePart.visible == True) and (notChanged == False)):
                housePart.visible = False
                notChanged = True

    # Drops the house a little.
    upHouse.centerY += 15
    if (upHouse.bottom >= 350):
        upHouse.bottom = 350

def checkWin():
    # When all of the letters have been correctly guessed, ends the game.
    if ((app.numRight == len(app.solution)) and (app.numRight != 0)):
        app.win = True
    elif (app.numWrong >= 6):
        Rect(0, 50, 400, 50, fill='lightCoral')
        Label(app.solution, 200, 75, fill='white', size=35, bold=True)
        app.stop()

def onKeyPress(key):
    if ((key == 'space') and (app.paused == True)):
        app.paused = False

        # Sets the instructions label to be invisible.
        instructions.visible = False

        # Gets a solution and if it is valid start the game.
        app.solution = app.getTextInput('Give me a word!')
        if (app.solution == ''):
            app.win = True
        else:
            app.spacing = 400 / len(app.solution)
            drawInputLines()
    else:
        # When a wrong letter is guessed, pops a balloon.
        if (key not in app.solution):
            popBalloon()
            app.numWrong += 1
        elif ((key in app.solution) and (key not in app.guesses)):
            # Loop through each letter in the solution. If the letter is
            # the same as the key, draw the letter and add 1 to numRight.
            ### (HINT: The drawLetter function is provided!)
            ### Place Your Code Here ###

            # Keeps track of the letters that were guessed.
            app.guesses = app.guesses + key

        checkWin()

def onStep():
    # Makes the house float away if the player wins.
    if (app.win == True):
        upHouse.centerY -= 5
        if (upHouse.bottom < 0):
            app.stop()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 350, fill=gradient('dodgerBlue', 'lightCyan', start='top'))
Rect(0, 350, 400, 110, fill=gradient('mediumSeaGreen', 'green', start='top'))

app.solution = ''
app.guesses = ''
app.numRight = 0
app.numWrong = 0
app.win = False
app.paused = True

instructions = Label('Press space to set the word', 200, 325, size=18,
                     bold=True)

upHouse = Group()

def makeBalloon(centerX, centerY, radius, color1, color2):
    # Draws a balloon and adds it to the upHouse group.
    balloon = Group(
        Line(200, 175, centerX, centerY, fill='white', lineWidth=1),
        Circle(centerX, centerY, radius,
               fill=gradient(color1, color2, start='right-top'))
        )
    balloon.type = 'balloon'
    upHouse.add(balloon)

makeBalloon(175, 2, 50, 'lightCoral', 'red')
makeBalloon(200, 50, 35, 'orange', 'orangeRed')
makeBalloon(260, 30, 45, 'plum', 'mediumVioletRed')
makeBalloon(150, 70, 30, 'lavenderBlush', 'pink')
makeBalloon(150, 15, 37, 'mediumPurple', 'darkOrchid')
makeBalloon(240, 1, 40, 'cornSilk', 'yellow')

# Draws the house and adds it to group upHouse.
house = Group(
    Rect(155, 260, 90, 10, fill='maroon'),
    Rect(160, 220, 40, 40, fill='pink'),
    Rect(200, 220, 40, 40, fill='lightGreen'),
    Polygon(150, 220, 250, 220, 240, 175, 160, 175, fill='darkSlateBlue'),
    Polygon(200, 220, 220, 190, 240, 220, fill='lemonChiffon'),
    Polygon(170, 208, 170, 195, 180, 185, 190, 195, 190, 208,
            fill='lemonChiffon'),
    Rect(180, 242, 12, 18, fill='maroon'),
    Rect(160, 220, 40, 15, fill='lightSkyBlue'),
    Rect(215, 232, 10, 18, fill='plum'),
    Rect(205, 232, 5, 18, fill='plum'),
    Rect(230, 232, 5, 18, fill='plum'),
    Rect(215, 205, 10, 12, fill='plum'),
    Rect(176, 193, 8, 10, fill='plum'),
    Rect(195, 165, 10, 18, fill='maroon'),
    Line(220, 190, 200, 220, fill='lightSkyBlue', lineWidth=5),
    Line(220, 190, 240, 220, fill='lightSkyBlue', lineWidth=5),
    Line(180, 185, 170, 195, fill='lightSkyBlue', lineWidth=5),
    Line(180, 185, 190, 195, fill='lightSkyBlue', lineWidth=5),
    Line(160, 220, 160, 260, fill='white', lineWidth=3),
    Line(160, 235, 200, 235, fill='white', lineWidth=3)
    )
house.type = 'house'
upHouse.add(house)

def drawInputLines():
    # Draws the lines that shows where the correct letters will be drawn.
    for index in range(len(app.solution)):
        lineCx = app.spacing * (index + 1 / 2)
        lineCy = 390
        Line(lineCx - 10, lineCy, lineCx + 10, lineCy, fill='white')

def drawLetter(index):
    # Draws a letter on the correct input line.
    letter = app.solution[index]
    letterX = app.spacing * (index + 1 / 2)
    letterY = 390
    Label(letter, letterX, letterY, fill='white', size=35, align='bottom')

def popBalloon():
    # Removes a balloon by setting its visibility to false.
    notChanged = False
    for housePart in upHouse:
        if (housePart.type == 'balloon'):
            if ((housePart.visible == True) and (notChanged == False)):
                housePart.visible = False
                notChanged = True

    # Drops the house a little.
    upHouse.centerY += 15
    if (upHouse.bottom >= 350):
        upHouse.bottom = 350

def checkWin():
    # When all of the letters have been correctly guessed, ends the game.
    if ((app.numRight == len(app.solution)) and (app.numRight != 0)):
        app.win = True
    elif (app.numWrong >= 6):
        Rect(0, 50, 400, 50, fill='lightCoral')
        Label(app.solution, 200, 75, fill='white', size=35, bold=True)
        app.stop()

def onKeyPress(key):
    if ((key == 'space') and (app.paused == True)):
        app.paused = False

        # Sets the instructions label to be invisible.
        instructions.visible = False

        # Gets a solution and if it is valid start the game.
        app.solution = app.getTextInput('Give me a word!')
        if (app.solution == ''):
            app.win = True
        else:
            app.spacing = 400 / len(app.solution)
            drawInputLines()
    else:
        # When a wrong letter is guessed, pops a balloon.
        if (key not in app.solution):
            popBalloon()
            app.numWrong += 1
        elif ((key in app.solution) and (key not in app.guesses)):
            # Loop through each letter in the solution. If the letter is
            # the same as the key, draw the letter and add 1 to numRight.
            for index in range(len(app.solution)):
                letter = app.solution[index]
                if (letter == key):
                    drawLetter(index)
                    app.numRight += 1

            # Keeps track of the letters that were guessed.
            app.guesses = app.guesses + key

        checkWin()

def onStep():
    # Makes the house float away if the player wins.
    if (app.win == True):
        upHouse.centerY -= 5
        if (upHouse.bottom < 0):
            app.stop()
",regular,3
2257,Caps lock,9.3.2,"app.background = gradient('cornSilk', 'wheat', start='top')

# Letters used to populate the keyboard.
app.letters = 'qwertyuiopasdfghjklzxcvbnm'

# screen borders
Rect(200, 200, 200, 340, align='center')
Rect(200, 200, 180, 360, align='center')
Circle(110, 30, 10)
Circle(110, 370, 10)
Circle(290, 30, 10)
Circle(290, 370, 10)
Rect(110, 60, 180, 265, fill='white')
Rect(200, 45, 50, 5, fill='dimGrey', align='center')
Rect(110, 60, 180, 50, fill='ghostWhite')
Line(110, 110, 290, 110, fill='gainsboro', lineWidth=1)
Circle(150, 45, 5, fill='dimGrey')
Circle(200, 30, 3, fill='dimGrey')
Circle(200, 350, 13, fill='dimGrey')

# status bar
Rect(113, 70, 2, 2, align='left-bottom')
Rect(116, 70, 2, 3, align='left-bottom')
Rect(119, 70, 2, 5, align='left-bottom')
Rect(122, 70, 2, 7, fill='lightGrey', align='left-bottom')
Label('8:00', 200, 65, size=6)
Rect(275, 63, 10, 5, fill='ghostWhite', border='grey', borderWidth=1)
Rect(276, 64, 2, 3, fill='red')

# CS Academy icon
Circle(200, 83, 11, fill='lightGray')
Label('CS', 200, 83, fill='white', size=10)
Label('CS Academy', 200, 100, size=8)

# text bubbles
Rect(120, 120, 100, 20, fill='lightGrey')
Polygon(120, 140, 130, 140, 120, 150, fill='lightGrey')
Rect(280, 150, 100, 20, fill='dodgerBlue', align='right-top')
Polygon(280, 170, 270, 170, 280, 180, fill='dodgerBlue')
Rect(120, 180, 100, 20, fill='lightGrey')
Polygon(120, 200, 130, 200, 120, 210, fill='lightGrey')

def drawKeyboard():
    # outline and buttons
    Rect(110, 235, 180, 90, fill='lightGrey')
    Rect(116, 218, 155, 15, fill='white', border='lightGrey', borderWidth=1)
    Label('Text Message', 120, 222, fill='darkGrey', size=10, align='left-top')
    Rect(275, 218, 12, 15, fill='dodgerBlue')
    Rect(281, 224, 4, 5, fill='white', align='top')
    Polygon(281, 220, 285, 224, 277, 224, fill='white')
    Rect(200, 308, 70, 12, fill='white', align='top')
    Rect(262, 285, 21, 20, fill='darkGray')
    Label('del', 272, 295, size=10)
    Rect(116, 285, 19, 20, fill='darkGray')

    # Draws all of the keys using the letters string.
    for index in range(len(app.letters)):
        letter = app.letters[index]

        # If we are in the first row.
        if (index < 10):
            x = 123 + index * 17
            y = 248
        # The second row.
        elif (index < 19):
            x = 130 + (index - 10) * 17
            y = 271
        # The third row.
        else:
            x = 147 + (index - 19) * 17
            y = 295
        Rect(x, y, 14, 20, fill='white', align='center')
        Label(letter, x, y, size=12)

capsLockArrow = Group(
    Polygon(125, 288, 131, 295, 119, 295, fill='white'),
    Rect(125, 295, 5, 7, fill='white', align='top')
    )

def capsLock(isCapsLockOn, text1, text2, text3):
    # If caps lock is on, all the texts should be uppercase. Otherwise they
    # should be lowercase.
    ### (HINT: The letters used to draw the keyboard should also become
    #          capitalized when caps lock is on.)
    ### Fix Your Code Here ###
    if (isCapsLockOn == True):
        app.letters = app.letters
        Label(text1, 125, 125, size=10, align='left-top')
        Label(text2, 185, 155, fill='white', size=10, align='left-top')
        Label(text3, 125, 185, size=10, align='left-top')

        # Changes the color of the capsLockArrow.
        capsLockArrow.fill = 'black'

    else:
        Label(text1, 125, 125, size=10, align='left-top')
        Label(text2, 185, 155, fill='white', size=10, align='left-top')
        Label(text3, 125, 185, size=10, align='left-top')

    # Draws the keyboard, and brings the capsLockArrow to front.
    drawKeyboard()
    capsLockArrow.toFront()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('cornSilk', 'wheat', start='top')

# Letters used to populate the keyboard.
app.letters = 'qwertyuiopasdfghjklzxcvbnm'

# screen borders
Rect(200, 200, 200, 340, align='center')
Rect(200, 200, 180, 360, align='center')
Circle(110, 30, 10)
Circle(110, 370, 10)
Circle(290, 30, 10)
Circle(290, 370, 10)
Rect(110, 60, 180, 265, fill='white')
Rect(200, 45, 50, 5, fill='dimGrey', align='center')
Rect(110, 60, 180, 50, fill='ghostWhite')
Line(110, 110, 290, 110, fill='gainsboro', lineWidth=1)
Circle(150, 45, 5, fill='dimGrey')
Circle(200, 30, 3, fill='dimGrey')
Circle(200, 350, 13, fill='dimGrey')

# status bar
Rect(113, 70, 2, 2, align='left-bottom')
Rect(116, 70, 2, 3, align='left-bottom')
Rect(119, 70, 2, 5, align='left-bottom')
Rect(122, 70, 2, 7, fill='lightGrey', align='left-bottom')
Label('8:00', 200, 65, size=6)
Rect(275, 63, 10, 5, fill='ghostWhite', border='grey', borderWidth=1)
Rect(276, 64, 2, 3, fill='red')

# CS Academy icon
Circle(200, 83, 11, fill='lightGray')
Label('CS', 200, 83, fill='white', size=10)
Label('CS Academy', 200, 100, size=8)

# text bubbles
Rect(120, 120, 100, 20, fill='lightGrey')
Polygon(120, 140, 130, 140, 120, 150, fill='lightGrey')
Rect(280, 150, 100, 20, fill='dodgerBlue', align='right-top')
Polygon(280, 170, 270, 170, 280, 180, fill='dodgerBlue')
Rect(120, 180, 100, 20, fill='lightGrey')
Polygon(120, 200, 130, 200, 120, 210, fill='lightGrey')

def drawKeyboard():
    # outline and buttons
    Rect(110, 235, 180, 90, fill='lightGrey')
    Rect(116, 218, 155, 15, fill='white', border='lightGrey', borderWidth=1)
    Label('Text Message', 120, 222, fill='darkGrey', size=10, align='left-top')
    Rect(275, 218, 12, 15, fill='dodgerBlue')
    Rect(281, 224, 4, 5, fill='white', align='top')
    Polygon(281, 220, 285, 224, 277, 224, fill='white')
    Rect(200, 308, 70, 12, fill='white', align='top')
    Rect(262, 285, 21, 20, fill='darkGray')
    Label('del', 272, 295, size=10)
    Rect(116, 285, 19, 20, fill='darkGray')

    # Draws all of the keys using the letters string.
    for index in range(len(app.letters)):
        letter = app.letters[index]

        # If we are in the first row.
        if (index < 10):
            x = 123 + index * 17
            y = 248
        # The second row.
        elif (index < 19):
            x = 130 + (index - 10) * 17
            y = 271
        # The third row.
        else:
            x = 147 + (index - 19) * 17
            y = 295
        Rect(x, y, 14, 20, fill='white', align='center')
        Label(letter, x, y, size=12)

capsLockArrow = Group(
    Polygon(125, 288, 131, 295, 119, 295, fill='white'),
    Rect(125, 295, 5, 7, fill='white', align='top')
    )

def capsLock(isCapsLockOn, text1, text2, text3):
    # If caps lock is on, all the texts should be uppercase. Otherwise they
    # should be lowercase.
    if (isCapsLockOn == True):
        app.letters = app.letters.upper()
        Label(text1.upper(), 125, 125, size=10, align='left-top')
        Label(text2.upper(), 185, 155, fill='white', size=10, align='left-top')
        Label(text3.upper(), 125, 185, size=10, align='left-top')

        # Changes the color of the capsLockArrow.
        capsLockArrow.fill = 'black'

    else:
        Label(text1.lower(), 125, 125, size=10, align='left-top')
        Label(text2.lower(), 185, 155, fill='white', size=10, align='left-top')
        Label(text3.lower(), 125, 185, size=10, align='left-top')

    # Draws the keyboard, and brings the capsLockArrow to front.
    drawKeyboard()
    capsLockArrow.toFront()
",regular,1
2258,Spongebob meme,9.3.2,"# Spongebob's face
app.background = rgb(255, 250, 80)

# eyelashes
Line(75, 135, 100, 180, lineWidth=4)
Line(100, 125, 100, 180, lineWidth=4)
Line(130, 130, 100, 180, lineWidth=4)
Line(265, 130, 290, 180, lineWidth=4)
Line(285, 125, 290, 180, lineWidth=4)
Line(305, 125, 290, 180, lineWidth=4)

# eyes
Circle(110, 180, 40, fill='white', border='black')
Circle(100, 175, 17)
Circle(100, 175, 15, border=rgb(130, 190, 235), borderWidth=7)
Circle(290, 180, 40, fill='white', border='black')
Circle(310, 180, 17)
Circle(310, 180, 15, border=rgb(130, 190, 235), borderWidth=7)

Label('Press space to input a sentence', 200, 30, size=15)

# Defines the labels that keep track of the meme text.
inputLabel = Label('', 200, 60, size=20, bold=True)
memeLabel = Label('', 200, 300, fill='white', border='black', size=35, bold=True)

def memefy():
    memeText = ''
    for index in range(len(inputLabel.value)):
        # If the letter in the input is at an even index, it should be
        # lowercase. Otherwise, make it uppercase.
        ### (HINT: You can use % 2 to test if the index is even
        #          and then add the correct character to the memeText string.)
        ### Place Your Code Here ###
        pass

    memeLabel.value = memeText

def onKeyPress(key):
    # Gets the text input.
    if (key == 'space'):
        inputLabel.value = app.getTextInput('Memefy a sentence:')
        memefy()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Spongebob's face
app.background = rgb(255, 250, 80)

# eyelashes
Line(75, 135, 100, 180, lineWidth=4)
Line(100, 125, 100, 180, lineWidth=4)
Line(130, 130, 100, 180, lineWidth=4)
Line(265, 130, 290, 180, lineWidth=4)
Line(285, 125, 290, 180, lineWidth=4)
Line(305, 125, 290, 180, lineWidth=4)

# eyes
Circle(110, 180, 40, fill='white', border='black')
Circle(100, 175, 17)
Circle(100, 175, 15, border=rgb(130, 190, 235), borderWidth=7)
Circle(290, 180, 40, fill='white', border='black')
Circle(310, 180, 17)
Circle(310, 180, 15, border=rgb(130, 190, 235), borderWidth=7)

Label('Press space to input a sentence', 200, 30, size=15)

# Defines the labels that keep track of the meme text.
inputLabel = Label('', 200, 60, size=20, bold=True)
memeLabel = Label('', 200, 300, fill='white', border='black', size=35, bold=True)

def memefy():
    memeText = ''
    for index in range(len(inputLabel.value)):
        # If the letter in the input is at an even index, it should be
        # lowercase. Otherwise, make it uppercase.
        letter = inputLabel.value[index]
        if (index % 2 == 0):
            memeText = memeText + letter.lower()
        else:
            memeText = memeText + letter.upper()

    memeLabel.value = memeText

def onKeyPress(key):
    # Gets the text input.
    if (key == 'space'):
        inputLabel.value = app.getTextInput('Memefy a sentence:')
        memefy()
",regular,1
2259,Character rain,9.3.2,"# background
app.background = gradient('white', 'lightCyan', start='top')

letters = Group()

# tank for letters
tanks = Group(
    Rect(0, 300, 200, 100, fill='lightSkyBlue'),
    Label('UPPERCASE', 100, 360, fill='white', size=18, bold=True),
    Rect(200, 300, 200, 100, fill='lightSkyBlue'),
    Label('lowercase', 300, 360, fill='white', size=18, bold=True),
    Rect(0, 300, 400, 25, fill='steelBlue'),
    Line(200, 300, 200, 400, fill='white', lineWidth=5)
    )

# cloud
Oval(50, 5, 180, 100, fill='silver')
Oval(160, 20, 160, 125, fill='silver')
Oval(270, 5, 130, 130, fill='silver')
Oval(360, 0, 140, 120, fill='silver')

def onStep():
    color = rgb(randrange(0, 100), randrange(100, 256), randrange(200, 256))
    alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'

    # Draw a new random letter with a centerX between 100 and 300 (inclusive)
    # and the color defined above.
    ### Fix Your Code Here ###
    randomLetter = 'change randomLetter'
    letter = Label('change the label and fill', randrange(100, 301), 0,
                   fill='blue', size=20, bold=True)

    # Then set a speed for the letter depending on if it is lowercase or
    # uppercase so that it will move into either the left or right pool.
    ### (HINT: The dx property should be either randrange(-5, -2) or
    #          randrange(2, 5), depending on the case of the letter.)
    ### Fix Your Code Here ###
    letter.dx = randrange(-5, 5)
    letter.dy = randrange(5, 10)
    letters.add(letter)

    # Updates locations of letters and removes letters that leave the canvas.
    for letter in letters.children:
        letter.centerX += letter.dx
        letter.centerY += letter.dy
        if ((letter.right < 0) or (letter.top > 400) or (letter.left > 400)):
            letters.remove(letter)

    tanks.toFront()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
app.background = gradient('white', 'lightCyan', start='top')

letters = Group()

# tank for letters
tanks = Group(
    Rect(0, 300, 200, 100, fill='lightSkyBlue'),
    Label('UPPERCASE', 100, 360, fill='white', size=18, bold=True),
    Rect(200, 300, 200, 100, fill='lightSkyBlue'),
    Label('lowercase', 300, 360, fill='white', size=18, bold=True),
    Rect(0, 300, 400, 25, fill='steelBlue'),
    Line(200, 300, 200, 400, fill='white', lineWidth=5)
    )

# cloud
Oval(50, 5, 180, 100, fill='silver')
Oval(160, 20, 160, 125, fill='silver')
Oval(270, 5, 130, 130, fill='silver')
Oval(360, 0, 140, 120, fill='silver')

def onStep():
    color = rgb(randrange(0, 100), randrange(100, 256), randrange(200, 256))
    alphabet = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz'

    # Draw a new random letter with a centerX between 100 and 300 (inclusive)
    # and the color defined above.
    randomLetter = alphabet[randrange(0, 52)]
    letter = Label(randomLetter, randrange(100, 301), 0,
                   fill=color, size=20, bold=True)

    # Then set a speed for the letter depending on if it is lowercase or
    # uppercase so that it will move into either the left or right pool.
    if (randomLetter.isupper() == True):
        letter.dx = randrange(-5, -2)
    elif (randomLetter.islower() == True):
        letter.dx = randrange(2, 5)
    letter.dy = randrange(5, 10)
    letters.add(letter)

    # Updates locations of letters and removes letters that leave the canvas.
    for letter in letters.children:
        letter.centerX += letter.dx
        letter.centerY += letter.dy
        if ((letter.right < 0) or (letter.top > 400) or (letter.left > 400)):
            letters.remove(letter)

    tanks.toFront()
",regular,2
2260,Gravity,9.3.2,"app.background = gradient(rgb(50, 50, 50), 'black')

# stars
for i in range (50):
    Star(randrange(0, 400), randrange(0, 400), 2, 4, fill='white', opacity=50)

# black hole
Circle(200, 200, 75, fill=gradient('black', 'orange', 'orangeRed',
                                   rgb(40, 40, 40), rgb(35, 35, 35)))

letters = Group()

def onMouseMove(mouseX, mouseY):
    alphabet = 'abcdefghijklmnopqrstuvxyz'

    # Gets a new random index from the alphabet and randomly pick upper or lower.
    randomIndex = randrange(len(alphabet))
    letter = alphabet[randomIndex]
    chance = randrange(0, 2)
    if (chance == 0):
        letter = letter.upper()
        color = rgb(randrange(200, 256), 220, 120)
    else:
        color = rgb(255, 255, randrange(220, 256))

    # Adds a new letter at the mouse position.
    letters.add(
        Label(letter, mouseX, mouseY, fill=color, size=randrange(12, 50))
        )

def onStep():
    # Move each letter towards or away from the center.
    for letter in letters.children:
        # Get the angle from the letter to the center of the canvas and use that
        # angle to get the next point of the letter using getPointInDir.
        # If the letter is lowercase, set distance accordingly and decrease the
        # letter's size by 1. If the lowercase letter's size becomes 0, remove
        # the letter from the letters group.
        ### (HINT: If the letter is lowercase, the distance should be positive 5.
        #          Otherwise, it should be negative 5.)
        ### Place Your Code Here ###

        # Move the letter to the new point and add the distance moved to its
        # rotateAngle.
        ### Place Your Code Here ###

        # Removes any letters that are off the canvas or in the center.
        if ((letter.centerX < 0) or (letter.centerX > 400) or
            (letter.centerY < 0) or (letter.centerY > 400)):
            letters.remove(letter)
        if (abs(letter.centerX - 200) < 25):
            letters.remove(letter)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient(rgb(50, 50, 50), 'black')

# stars
for i in range (50):
    Star(randrange(0, 400), randrange(0, 400), 2, 4, fill='white', opacity=50)

# black hole
Circle(200, 200, 75, fill=gradient('black', 'orange', 'orangeRed',
                                   rgb(40, 40, 40), rgb(35, 35, 35)))

letters = Group()

def onMouseMove(mouseX, mouseY):
    alphabet = 'abcdefghijklmnopqrstuvxyz'

    # Gets a new random index from the alphabet and randomly pick upper or lower.
    randomIndex = randrange(len(alphabet))
    letter = alphabet[randomIndex]
    chance = randrange(0, 2)
    if (chance == 0):
        letter = letter.upper()
        color = rgb(randrange(200, 256), 220, 120)
    else:
        color = rgb(255, 255, randrange(220, 256))

    # Adds a new letter at the mouse position.
    letters.add(
        Label(letter, mouseX, mouseY, fill=color, size=randrange(12, 50))
        )

def onStep():
    # Move each letter towards or away from the center.
    for letter in letters.children:
        # Get the angle from the letter to the center of the canvas and use that
        # angle to get the next point of the letter using getPointInDir.
        angle = angleTo(letter.centerX, letter.centerY, 200, 200)
        if (letter.value.islower() == True):
            dist = 5
            letter.size -= 1
            if (letter.size == 0):
                letters.remove(letter)
        else:
            dist = -5
        newX, newY = getPointInDir(letter.centerX, letter.centerY, angle, dist)

        # Move the letter to the new point and add the distance moved to its
        # rotateAngle.
        letter.centerX = newX
        letter.centerY = newY
        letter.rotateAngle += dist

        # Removes any letters that are off the canvas or in the center.
        if ((letter.centerX < 0) or (letter.centerX > 400) or
            (letter.centerY < 0) or (letter.centerY > 400)):
            letters.remove(letter)
        if (abs(letter.centerX - 200) < 25):
            letters.remove(letter)
",regular,2
2256,Find the letter,9.3.2,"app.background = 'midnightBlue'

Line(0, 200, 400, 200, fill='lightCyan', lineWidth=400, dashes=(2, 38))
Line(200, 0, 200, 400, fill='lightCyan', lineWidth=400, dashes=(2, 38))

labels = Group()

def drawLabels(letter, number):
    # Pick a random index for the letter.
    letterXIndex = randrange(0, 10)
    letterYIndex = randrange(0, 10)

    # Draws and adds the labels for each grid position to the labels group.
    for xIndex in range(0, 10):
        for yIndex in range(0, 10):
            centerX = 40 * (xIndex + 1 / 2)
            centerY = 40 * (yIndex + 1 / 2)
            # At the position where the letter should be, draws a letter.
            # Otherwise draws a number.
            if ((xIndex == letterXIndex) and (yIndex == letterYIndex)):
                labels.add(
                    Label(letter, centerX, centerY, fill='white', size=24,
                          bold=True)
                    )
            else:
                labels.add(
                    Label(number, centerX, centerY, fill='white', size=25,
                          bold=True)
                    )

def onKeyPress(key):
    if (key == 'space'):
        # Loop over each label and check if it is a letter.
        # If it is, change its fill and size.
        ### Place Your Code Here ###
        pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'midnightBlue'

Line(0, 200, 400, 200, fill='lightCyan', lineWidth=400, dashes=(2, 38))
Line(200, 0, 200, 400, fill='lightCyan', lineWidth=400, dashes=(2, 38))

labels = Group()

def drawLabels(letter, number):
    # Pick a random index for the letter.
    letterXIndex = randrange(0, 10)
    letterYIndex = randrange(0, 10)

    # Draws and adds the labels for each grid position to the labels group.
    for xIndex in range(0, 10):
        for yIndex in range(0, 10):
            centerX = 40 * (xIndex + 1 / 2)
            centerY = 40 * (yIndex + 1 / 2)
            # At the position where the letter should be, draws a letter.
            # Otherwise draws a number.
            if ((xIndex == letterXIndex) and (yIndex == letterYIndex)):
                labels.add(
                    Label(letter, centerX, centerY, fill='white', size=24,
                          bold=True)
                    )
            else:
                labels.add(
                    Label(number, centerX, centerY, fill='white', size=25,
                          bold=True)
                    )

def onKeyPress(key):
    if (key == 'space'):
        # Loop over each label and check if it is a letter.
        # If it is, change its fill and size.
        for label in labels.children:
            if (label.value.isalpha() == True):
                label.fill = 'red'
                label.size = 26
",regular,1
2262,Teleport landing,9.4.2,"app.background = 'black'
Circle(200, 800, 800, fill=gradient('lightSkyBlue', 'deepSkyBlue', 'black'),
       opacity=75)

Label('Press space to safely teleport!', 200, 30, fill='white', size=18,
      bold=True)
speech = Label('AHHHHH!', 50, 75, fill='white', size=14, bold=True,
               align='left')

planet = Group(
    Circle(200, 800, 500, fill='dodgerBlue'),
    Polygon(155, 305, 50, 330, 120, 355, 185, 335, 230, 355, 260, 330,
            330, 350, 365, 335, 255, 305, fill='darkGreen'),
    Circle(200, 800, 500, fill=None, border='darkGreen', borderWidth=10)
    )

# astronaut
astronaut = Group(
    Rect(15, 100, 40, 40, fill='darkGray'),
    Circle(35, 95, 15, fill='white'),
    Rect(20, 110, 30, 40, fill='white'),
    Rect(10, 110, 50, 12, fill='white'),
    Rect(25, 88, 20, 14, fill='steelBlue'),
    Line(35, 135, 35, 150),
    Rect(30, 117, 10, 10, fill='gray'),
    Rect(15, 110, 3, 12, fill='fireBrick'),
    Rect(52, 110, 3, 12, fill='fireBrick')
    )
astronaut.rescue = False

def onKeyPress(key):
    # Press 'space' to teleport the astronaut to ground level.
    if ((astronaut.rescue == False) and (key == 'space')):
        astronaut.rotateAngle = 0

        # Get the angle from the astronaut to the planet.
        ### Fix Your Code Here ###
        angle = 180

        # Move the astronaut by 1 pixel to the planet until the astronaut's
        # bottom is contained in the planet.
        ### (HINT: Use a while loop until the planet contains the
        #          center-bottom of the astronaut.)
        ### Place Your Code Here ###

        # Sets the astronaut as rescued and rotate.
        astronaut.rescue = True
        astronaut.rotateAngle = angle - 180

        # Changes and moves the text next to the astronaut.
        speech.value = 'Phew!'
        speech.centerX = astronaut.centerX
        speech.centerY = astronaut.centerY - 50

def onStep():
    # Moves the astronaut towards the right edge of the screen.
    if ((astronaut.left < 400) and (astronaut.rescue == False)):
        astronaut.centerX += 2
        astronaut.rotateAngle += 5
        speech.centerX += 2

    # If the astronaut flies off the screen, adds a label and pause the app.
    elif (astronaut.left >= 400):
        Label('NOOOOOO! Lost in space!', 200, 60, fill='white', size=14,
              bold=True)
        app.paused = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
Circle(200, 800, 800, fill=gradient('lightSkyBlue', 'deepSkyBlue', 'black'),
       opacity=75)

Label('Press space to safely teleport!', 200, 30, fill='white', size=18,
      bold=True)
speech = Label('AHHHHH!', 50, 75, fill='white', size=14, bold=True,
               align='left')

planet = Group(
    Circle(200, 800, 500, fill='dodgerBlue'),
    Polygon(155, 305, 50, 330, 120, 355, 185, 335, 230, 355, 260, 330,
            330, 350, 365, 335, 255, 305, fill='darkGreen'),
    Circle(200, 800, 500, fill=None, border='darkGreen', borderWidth=10)
    )

# astronaut
astronaut = Group(
    Rect(15, 100, 40, 40, fill='darkGray'),
    Circle(35, 95, 15, fill='white'),
    Rect(20, 110, 30, 40, fill='white'),
    Rect(10, 110, 50, 12, fill='white'),
    Rect(25, 88, 20, 14, fill='steelBlue'),
    Line(35, 135, 35, 150),
    Rect(30, 117, 10, 10, fill='gray'),
    Rect(15, 110, 3, 12, fill='fireBrick'),
    Rect(52, 110, 3, 12, fill='fireBrick')
    )
astronaut.rescue = False

def onKeyPress(key):
    # Press 'space' to teleport the astronaut to ground level.
    if ((astronaut.rescue == False) and (key == 'space')):
        astronaut.rotateAngle = 0

        # Get the angle from the astronaut to the planet.
        angle = angleTo(astronaut.centerX, astronaut.centerY,
                        planet.centerX, planet.centerY)

        # Move the astronaut by 1 pixel to the planet until the astronaut's
        # bottom is contained in the planet.
        while (planet.contains(astronaut.centerX, astronaut.bottom) == False):
            newX, newY = getPointInDir(astronaut.centerX, astronaut.centerY,
                                       angle, 1)
            astronaut.centerX = newX
            astronaut.centerY = newY

        # Sets the astronaut as rescued and rotate.
        astronaut.rescue = True
        astronaut.rotateAngle = angle - 180

        # Changes and moves the text next to the astronaut.
        speech.value = 'Phew!'
        speech.centerX = astronaut.centerX
        speech.centerY = astronaut.centerY - 50

def onStep():
    # Moves the astronaut towards the right edge of the screen.
    if ((astronaut.left < 400) and (astronaut.rescue == False)):
        astronaut.centerX += 2
        astronaut.rotateAngle += 5
        speech.centerX += 2

    # If the astronaut flies off the screen, adds a label and pause the app.
    elif (astronaut.left >= 400):
        Label('NOOOOOO! Lost in space!', 200, 60, fill='white', size=14,
              bold=True)
        app.paused = True
",regular,1
2263,Meteor shower,9.4.2,"# Repeatedly draw randomly positioned meteors until one hits the mountains.

app.background = gradient('black', 'darkBlue', start='top')

mountain = Polygon(-40, 400, 160, 310, 230, 330, 270, 290, 290, 300, 330, 240,
                   465, 400, opacity=50)
meteors = Group()

def drawMeteors():
    # Use a while loop to add meteors into the group until they hit
    # the mountain.
    ### (HINT: Fix the loop condition using hitsShape.)
    ### Fix Your Code Here ###
    while (1 < 0):
        startX = randrange(0, 400)
        startY = randrange(0, 175)
        meteor = Line(startX, startY, startX + 50, startY + 50,
                      fill=gradient(rgb(0, 0, 50), rgb(0, 0, 80), 'lightCyan',
                                    start='top'))
        meteor.dx = randrange(-15, -10)
        meteor.dy = randrange(10, 15)
        meteors.add(meteor)

        # Uses a for loop to move each meteor in meteors.children.
        for meteor in meteors.children:
            meteor.x2 += meteor.dx
            meteor.y2 += meteor.dy

drawMeteors()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Repeatedly draw randomly positioned meteors until one hits the mountains.

app.background = gradient('black', 'darkBlue', start='top')

mountain = Polygon(-40, 400, 160, 310, 230, 330, 270, 290, 290, 300, 330, 240,
                   465, 400, opacity=50)
meteors = Group()

def drawMeteors():
    # Use a while loop to add meteors into the group until they hit
    # the mountain.
    while (meteors.hitsShape(mountain) == False):
        startX = randrange(0, 400)
        startY = randrange(0, 175)
        meteor = Line(startX, startY, startX + 50, startY + 50,
                      fill=gradient(rgb(0, 0, 50), rgb(0, 0, 80), 'lightCyan',
                                    start='top'))
        meteor.dx = randrange(-15, -10)
        meteor.dy = randrange(10, 15)
        meteors.add(meteor)

        # Uses a for loop to move each meteor in meteors.children.
        for meteor in meteors.children:
            meteor.x2 += meteor.dx
            meteor.y2 += meteor.dy

drawMeteors()
",regular,1
2261,Ship scanner,9.4.2,"app.background = 'black'
app.stepsPerSecond = 15

Rect(200, 225, 500, 500, fill=gradient('lime', 'black', 'black'), opacity=80,
     align='center')

Label('Scanning for ships...', 200, 25, fill='white', size=20)

scanner = Group(
    Circle(200, 225, 10, fill='green')
    )
scanLine = Line(200, 50, 200, 400, fill='white', lineWidth=1)

signals = Group()

def drawOuterScanner():
    # Draw the rings of the scanner, and add them to the scanner group.
    ### Place Your Code Here ###
    pass

drawOuterScanner()

def drawShipAndSignals(x, y, radius):
    # Draw the red circles around the ship and add the circles to the signals
    # group. The radius of each circle is half of that of the next largest
    # circle.
    ### (HINT: Use a while loop and integer divide the radius in 2 each time.)
    ### Place Your Code Here ###

    # ship
    Oval(x, y, randrange(5, 20), randrange(5, 20), fill='steelBlue')

def onMousePress(mouseX, mouseY):
    if (scanner.contains(mouseX, mouseY) == True):
        drawShipAndSignals(mouseX, mouseY, randrange(20, 100))

def onStep():
    scanLine.rotateAngle += 3

    # Increases the radius of each signal.
    for signal in signals:
        signal.radius *= 1.05

        # Removes signals that are too large and add a new one.
        if (signal.radius >= 75):
            signals.remove(signal)
            signals.add(
                Circle(signal.centerX, signal.centerY, 5, fill=None,
                       border='red', opacity=70)
                )
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 15

Rect(200, 225, 500, 500, fill=gradient('lime', 'black', 'black'), opacity=80,
     align='center')

Label('Scanning for ships...', 200, 25, fill='white', size=20)

scanner = Group(
    Circle(200, 225, 10, fill='green')
    )
scanLine = Line(200, 50, 200, 400, fill='white', lineWidth=1)

signals = Group()

def drawOuterScanner():
    # Draw the rings of the scanner, and add them to the scanner group.
    for scannerNum in range(1, 7):
        scannerRadius = 30 * scannerNum
        scanner.add(
            Circle(200, 225, scannerRadius, fill=None, border='green')
            )

drawOuterScanner()

def drawShipAndSignals(x, y, radius):
    # Draw the red circles around the ship and add the circles to the signals
    # group. The radius of each circle is half of that of the next largest
    # circle.
    while (radius > 0):
        signals.add(
            Circle(x, y, radius, fill=None, border='red', opacity=70)
            )
        radius = radius // 2

    # ship
    Oval(x, y, randrange(5, 20), randrange(5, 20), fill='steelBlue')

def onMousePress(mouseX, mouseY):
    if (scanner.contains(mouseX, mouseY) == True):
        drawShipAndSignals(mouseX, mouseY, randrange(20, 100))

def onStep():
    scanLine.rotateAngle += 3

    # Increases the radius of each signal.
    for signal in signals:
        signal.radius *= 1.05

        # Removes signals that are too large and add a new one.
        if (signal.radius >= 75):
            signals.remove(signal)
            signals.add(
                Circle(signal.centerX, signal.centerY, 5, fill=None,
                       border='red', opacity=70)
                )
",regular,2
2264,Revolving rects,9.4.2,"app.background = 'black'

def drawRect(red, green, blue, index):
    # Draws a rectangle rotated slightly with a dashed border.
    side = 100 + index * 15
    angle = index * 10
    Rect(60, 60, side, side, fill=None, border=rgb(red, green, blue),
         borderWidth=3, rotateAngle=angle, dashes=(6, 2))

def drawChangingRects():
    red = randrange(50, 100)
    green = randrange(50, 100)
    blue = randrange(50, 100)
    index = 0

    # Loop until all of the rgb parts are greater than 200.
    ### (HINT: Use a while loop with 3 conditions: one for each color.)
    ### Place Your Code Here ###

    # On each pass through the loop, draw a rectangle using the drawRect
    # function and increment the index.
    ### Place Your Code Here ###

    # On each pass, increase exactly one color by 25. Choose which color to
    # increase by generating a random number (increase red when the number
    # is 0, green when it is 1, and blue when it is 2).
    ### (HINT: Don't increase the color unless it is less than 200.)
    ### Place Your Code Here ###

drawChangingRects()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

def drawRect(red, green, blue, index):
    # Draws a rectangle rotated slightly with a dashed border.
    side = 100 + index * 15
    angle = index * 10
    Rect(60, 60, side, side, fill=None, border=rgb(red, green, blue),
         borderWidth=3, rotateAngle=angle, dashes=(6, 2))

def drawChangingRects():
    red = randrange(50, 100)
    green = randrange(50, 100)
    blue = randrange(50, 100)
    index = 0

    # Loop until all of the rgb parts are greater than 200.
    while ((red < 200) or (green < 200) or (blue < 200)):
        # On each pass through the loop, draw a rectangle using the drawRect
        # function and increment the index.
        drawRect(red, green, blue, index)
        index = index + 1

        # On each pass, increase exactly one color by 25. Choose which color to
        # increase by generating a random number (increase red when the number
        # is 0, green when it is 1, and blue when it is 2).
        randomNum = randrange(0, 3)
        if ((red < 200) and (randomNum == 0)):
            red += 25
        if ((green < 200) and (randomNum == 1)):
            green += 25
        if ((blue < 200) and (randomNum == 2)):
            blue += 25

drawChangingRects()
",regular,2
2273,Meteor smash,9.5,"app.background = 'black'
app.steps = 0
app.word = 'meteor'

# background
for i in range (30):
    Star(randrange(0, 400), randrange(0, 400), 5, 4, fill='white', opacity=80)

meteors = Group()
spaceships = Group()

Label('Score: ', 325, 25, fill='white', size=20, bold=True)
score = Label(0, 375, 25, fill='white', size=20, bold=True)

def drawMeteor(meteorSize):
    # Draws a new meteor.
    meteor = Group(
        Polygon(0, 340, 0, 365, 20, 400, 40, 365, 40, 340,
                fill=gradient('orange', 'orangeRed', 'black', start='top')),
        Circle(20, 340, 20,
              fill=gradient('white', 'gray', 'dimGray', start='top')),
        Oval(30, 345, 5, 8, fill='dimGray', rotateAngle=20),
        Oval(30, 345, 7, 8,
             fill=gradient('silver', 'gray', start='top'), rotateAngle=20),
        Oval(12, 330, 3, 5,
             fill=gradient('silver', 'gray', start='top'), rotateAngle=20)
        )

    # Sets properties to position, angle, and size the meteor properly.
    meteor.rotateAngle = 180
    meteor.centerX = randrange(0, 400)
    meteor.bottom = 0
    meteor.width = meteorSize
    meteor.height = 2 * meteorSize

    # Randomly decides if the meteor has uppercase or lowercase letters.
    isCaps = randrange(0, 2)

    # Set the new meteor's word depending on if the word should be capital or not.
    ### (HINT: Set it to uppercase if isCaps is 0, and lowercase otherwise.)
    ### Fix Your Code Here ###
    meteor.word = app.word

    # Adds the letter to the meteor.
    meteor.add(
        Label(meteor.word, meteor.centerX, -15, size=meteorSize/5, bold=True)
        )
    meteors.add(meteor)

def onMousePress(mouseX, mouseY):
    # Draws a new spaceship.
    spaceship = Group(
        Polygon(15, 400, 4, 370, 26, 370,
                fill=gradient('orange', 'darkOrange', 'red', start='right-top')),
        Oval(15, 337, 32, 65, fill='white'),
        RegularPolygon(15, 307, 14, 3, fill='crimson'),
        Circle(15, 332, 10, fill='lightSkyBlue', border='dimGray', borderWidth=3),
        Rect(2, 358, 28, 12, fill='crimson')
        )

    # Sets the target for the spaceship and rotates it to be angled towards that
    # target.
    spaceship.targetX = mouseX
    spaceship.targetY = mouseY
    spaceship.rotateAngle = angleTo(spaceship.centerX, spaceship.centerY,
                                    mouseX, mouseY)
    spaceships.add(spaceship)

def onStep():
    app.steps += 1

    # When the player has 300 points, they win.
    if (score.value >= 300):
        Rect(0, 150, 400, 100, fill='white', opacity=60)
        Label('YOU WIN', 200, 200, size=42, bold=True)
        app.stop()

    # Makes a new star every 20 steps.
    if (app.steps >= 20):
        drawMeteor(randrange(40, 80))
        app.steps = 0

    # Moves each spaceship towards its target position.
    for spaceship in spaceships.children:
        newAngle = angleTo(spaceship.centerX, spaceship.centerY,
                           spaceship.targetX, spaceship.targetY)
        newX, newY = getPointInDir(spaceship.centerX, spaceship.centerY,
                                   newAngle, 5)
        spaceship.centerX = newX
        spaceship.centerY = newY

        # Checks if the spaceship reaches its target and remove it if it has.
        if ((abs(spaceship.centerX - spaceship.targetX) < 5) and
            (abs(spaceship.centerY - spaceship.targetY) < 5)):
            spaceships.remove(spaceship)

    # Moves each of the meteors.
    for meteor in meteors.children:
        meteor.centerY += 4

        # If a spaceship hits the meteor, increment or decrement the score
        # depending on if the meteor's letter is lower or upper case.
        ### (HINT: The score should be increased/decreased by half the
        #          width and should never be negative.)
        ### Place Your Code Here ###

        # Remove any meteors that are off the screen.
        ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.steps = 0
app.word = 'meteor'

# background
for i in range (30):
    Star(randrange(0, 400), randrange(0, 400), 5, 4, fill='white', opacity=80)

meteors = Group()
spaceships = Group()

Label('Score: ', 325, 25, fill='white', size=20, bold=True)
score = Label(0, 375, 25, fill='white', size=20, bold=True)

def drawMeteor(meteorSize):
    # Draws a new meteor.
    meteor = Group(
        Polygon(0, 340, 0, 365, 20, 400, 40, 365, 40, 340,
                fill=gradient('orange', 'orangeRed', 'black', start='top')),
        Circle(20, 340, 20,
              fill=gradient('white', 'gray', 'dimGray', start='top')),
        Oval(30, 345, 5, 8, fill='dimGray', rotateAngle=20),
        Oval(30, 345, 7, 8,
             fill=gradient('silver', 'gray', start='top'), rotateAngle=20),
        Oval(12, 330, 3, 5,
             fill=gradient('silver', 'gray', start='top'), rotateAngle=20)
        )

    # Sets properties to position, angle, and size the meteor properly.
    meteor.rotateAngle = 180
    meteor.centerX = randrange(0, 400)
    meteor.bottom = 0
    meteor.width = meteorSize
    meteor.height = 2 * meteorSize

    # Randomly decides if the meteor has uppercase or lowercase letters.
    isCaps = randrange(0, 2)

    # Set the new meteor's word depending on if the word should be capital or not.
    if (isCaps == 0):
        meteor.word = app.word.upper()
    else:
        meteor.word = app.word.lower()

    # Adds the letter to the meteor.
    meteor.add(
        Label(meteor.word, meteor.centerX, -15, size=meteorSize/5, bold=True)
        )
    meteors.add(meteor)

def onMousePress(mouseX, mouseY):
    # Draws a new spaceship.
    spaceship = Group(
        Polygon(15, 400, 4, 370, 26, 370,
                fill=gradient('orange', 'darkOrange', 'red', start='right-top')),
        Oval(15, 337, 32, 65, fill='white'),
        RegularPolygon(15, 307, 14, 3, fill='crimson'),
        Circle(15, 332, 10, fill='lightSkyBlue', border='dimGray', borderWidth=3),
        Rect(2, 358, 28, 12, fill='crimson')
        )

    # Sets the target for the spaceship and rotates it to be angled towards that
    # target.
    spaceship.targetX = mouseX
    spaceship.targetY = mouseY
    spaceship.rotateAngle = angleTo(spaceship.centerX, spaceship.centerY,
                                    mouseX, mouseY)
    spaceships.add(spaceship)

def onStep():
    app.steps += 1

    # When the player has 300 points, they win.
    if (score.value >= 300):
        Rect(0, 150, 400, 100, fill='white', opacity=60)
        Label('YOU WIN', 200, 200, size=42, bold=True)
        app.stop()

    # Makes a new star every 20 steps.
    if (app.steps >= 20):
        drawMeteor(randrange(40, 80))
        app.steps = 0

    # Moves each spaceship towards its target position.
    for spaceship in spaceships.children:
        newAngle = angleTo(spaceship.centerX, spaceship.centerY,
                           spaceship.targetX, spaceship.targetY)
        newX, newY = getPointInDir(spaceship.centerX, spaceship.centerY,
                                   newAngle, 5)
        spaceship.centerX = newX
        spaceship.centerY = newY

        # Checks if the spaceship reaches its target and remove it if it has.
        if ((abs(spaceship.centerX - spaceship.targetX) < 5) and
            (abs(spaceship.centerY - spaceship.targetY) < 5)):
            spaceships.remove(spaceship)

    # Moves each of the meteors.
    for meteor in meteors.children:
        meteor.centerY += 4

        # If a spaceship hits the meteor, increment or decrement the score
        # depending on if the meteor's letter is lower or upper case.
        if (spaceships.hitsShape(meteor) == True):
            meteors.remove(meteor)

            if (meteor.word.isupper() == True):
                score.value += meteor.width // 2
            elif (score.value >= meteor.width // 2):
                score.value -= meteor.width // 2

        # Remove any meteor that are off the screen.
        if (meteor.top > 400):
            meteors.remove(meteor)
",regular,3
2270,Alphabet soup,9.5,"app.background = gradient('sienna', 'saddleBrown', start='left-top')

app.alphabet = 'CSAcademyRocks'

# Keeps track of how many labels have been drawn.
app.successes = 0

# bowl of letter-less soup
Circle(200, 200, 125, fill='lightBlue')
soup = Star(200, 200, 100, 15, fill='tomato', roundness=97)
Arc(240, 160, 40, 40, 300, 180, fill='silver')
Rect(268, 53, 10, 100, fill='silver', rotateAngle=30)
Circle(297, 60, 5, fill='silver')
Label('Press space to pour a bowl of alphabet soup!', 200, 360, size=16,
      bold=True)

labels = Group()

def drawLabel():
    # Gets a random position and opacity.
    centerX = randrange(60, 340)
    centerY = randrange(60, 340)
    randOpacity = randrange(20, 80)

    # Get a random letter from the alphabet.
    ### Place Your Code Here ###

    # If the new position is in the soup and not already in
    # the labels group, draw the label and add to app.successes.
    ### Place Your Code Here ###

def drawLettersInSoup():
    # While fewer than 100 letters have been drawn, draw another label.
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    # When space is pressed, draws a new bowl of soup.
    if (key == 'space'):
        app.successes = 0
        labels.clear()
        drawLettersInSoup()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('sienna', 'saddleBrown', start='left-top')

app.alphabet = 'CSAcademyRocks'

# Keeps track of how many labels have been drawn.
app.successes = 0

# bowl of letter-less soup
Circle(200, 200, 125, fill='lightBlue')
soup = Star(200, 200, 100, 15, fill='tomato', roundness=97)
Arc(240, 160, 40, 40, 300, 180, fill='silver')
Rect(268, 53, 10, 100, fill='silver', rotateAngle=30)
Circle(297, 60, 5, fill='silver')
Label('Press space to pour a bowl of alphabet soup!', 200, 360, size=16,
      bold=True)

labels = Group()

def drawLabel():
    # Gets a random position and opacity.
    centerX = randrange(60, 340)
    centerY = randrange(60, 340)
    randOpacity = randrange(20, 80)

    # Get a random letter from the alphabet.
    index = randrange(0, len(app.alphabet))
    letter = app.alphabet[index]

    # If the new position is in the soup and not already in
    # the labels group, draw the label and add to app.successes.
    if ((soup.contains(centerX, centerY) == True) and
        (labels.contains(centerX, centerY) == False)):
        labels.add(
            Label(letter, centerX, centerY, fill='lemonChiffon', size=16,
                  opacity=randOpacity, bold=True)
            )
        app.successes += 1

def drawLettersInSoup():
    # While fewer than 100 letters have been drawn, draw another label.
    while (app.successes < 100):
        drawLabel()

def onKeyPress(key):
    # When space is pressed, draws a new bowl of soup.
    if (key == 'space'):
        app.successes = 0
        labels.clear()
        drawLettersInSoup()
",regular,2
2266,Minion translator,9.5,"app.background = 'paleGreen'

# chatbox
Oval(240, 150, 200, 150, fill='white')
Oval(215, 175, 220, 145, fill='paleGreen')
Oval(200, 85, 300, 80, fill='white')

# face and mouth
Rect(120, 200, 155, 300, fill='gold')
Circle(198, 210, 78, fill='gold')
Oval(200, 270, 50, 30)
Oval(200, 260, 50, 30, fill='gold')

# glasses and eyes
Rect(120, 200, 155, 20)
Circle(165, 210, 30, fill='snow', border='dimGray', borderWidth=8)
Circle(235, 210, 30, fill='snow', border='dimGray', borderWidth=8)
Circle(165, 210, 13, border='saddleBrown', borderWidth=5)
Circle(235, 210, 13, border='saddleBrown', borderWidth=5)
Circle(160, 205, 3, fill='white')
Circle(230, 205, 3, fill='white')

# arms and hands
Line(125, 300, 105, 325, fill='gold', lineWidth=8)
Line(106, 320, 110, 370, fill='gold', lineWidth=8)
Line(270, 285, 290, 325, fill='gold', lineWidth=8)
Line(290, 325, 290, 370, fill='gold', lineWidth=8)
Line(110, 360, 120, 370, lineWidth=8)
Line(290, 360, 280, 370, lineWidth=8)
Oval(110, 370, 15, 25)
Oval(290, 370, 15, 25)

# trousers
Line(120, 300, 160, 320, fill='steelBlue', lineWidth=10)
Line(275, 290, 240, 320, fill='steelBlue', lineWidth=10)
Rect(155, 315, 90, 80, fill='steelBlue')
Rect(120, 385, 155, 30, fill='steelBlue')
Rect(185, 340, 30, 20, fill='steelBlue', border='black', borderWidth=3,
     dashes=True)

Label('Press space to enter text to translate', 200, 20, size=15)
minionLabel = Label('', 200, 85, size=20, bold=True)

def onKeyPress(key):
    if (key == 'space'):
        # Gets the text to translate and creates the minion's alphabet.
        text = app.getTextInput('Minion, please translate this sentence for me:')
        minionAlphabet = text + '~!#? &@'
        minionText = ''

        # Add letters to minionText until it is the same length as minionAlphabet.
        ### (HINT: Use a loop!)
        ### Place Your Code Here ###

        # In the loop, get a random letter from the minion's alphabet.
        ### Place Your Code Here ###

        # Starting with the first letter, every other letter in minionText
        # should be uppercase. If the random letter picked should be
        # uppercase, make it uppercase then add it to minionText! Otherwise,
        # make it lower.
        ### (HINT: This should also be done inside the loop.)
        ### Place Your Code Here ###

        minionLabel.value = minionText
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'paleGreen'

# chatbox
Oval(240, 150, 200, 150, fill='white')
Oval(215, 175, 220, 145, fill='paleGreen')
Oval(200, 85, 300, 80, fill='white')

# face and mouth
Rect(120, 200, 155, 300, fill='gold')
Circle(198, 210, 78, fill='gold')
Oval(200, 270, 50, 30)
Oval(200, 260, 50, 30, fill='gold')

# glasses and eyes
Rect(120, 200, 155, 20)
Circle(165, 210, 30, fill='snow', border='dimGray', borderWidth=8)
Circle(235, 210, 30, fill='snow', border='dimGray', borderWidth=8)
Circle(165, 210, 13, border='saddleBrown', borderWidth=5)
Circle(235, 210, 13, border='saddleBrown', borderWidth=5)
Circle(160, 205, 3, fill='white')
Circle(230, 205, 3, fill='white')

# arms and hands
Line(125, 300, 105, 325, fill='gold', lineWidth=8)
Line(106, 320, 110, 370, fill='gold', lineWidth=8)
Line(270, 285, 290, 325, fill='gold', lineWidth=8)
Line(290, 325, 290, 370, fill='gold', lineWidth=8)
Line(110, 360, 120, 370, lineWidth=8)
Line(290, 360, 280, 370, lineWidth=8)
Oval(110, 370, 15, 25)
Oval(290, 370, 15, 25)

# trousers
Line(120, 300, 160, 320, fill='steelBlue', lineWidth=10)
Line(275, 290, 240, 320, fill='steelBlue', lineWidth=10)
Rect(155, 315, 90, 80, fill='steelBlue')
Rect(120, 385, 155, 30, fill='steelBlue')
Rect(185, 340, 30, 20, fill='steelBlue', border='black', borderWidth=3,
     dashes=True)

Label('Press space to enter text to translate', 200, 20, size=15)
minionLabel = Label('', 200, 85, size=20, bold=True)

def onKeyPress(key):
    if (key == 'space'):
        # Gets the text to translate and creates the minion's alphabet.
        text = app.getTextInput('Minion, please translate this sentence for me:')
        minionAlphabet = text + '~!#? &@'
        minionText = ''

        # Add letters to minionText until it is the same length as minionAlphabet.
        while (len(minionText) < len(minionAlphabet)):
            # In the loop, get a random letter from the minion's alphabet.
            randomIndex = randrange(0, len(minionAlphabet))
            randomLetter = minionAlphabet[randomIndex]

            # Starting with the first letter, every other letter in minionText
            # should be uppercase. If the random letter picked should be
            # uppercase, make it uppercase then add it to minionText! Otherwise,
            # make it lower.
            if (len(minionText) % 2 == 0):
                randomLetter = randomLetter.upper()
            else:
                randomLetter = randomLetter.lower()

            minionText += randomLetter

        minionLabel.value = minionText
",regular,1
2267,Letter art,9.5,"app.stepsPerSecond = 1

# background
Rect(0, 0, 400, 400)

def drawLetter(key, x, y, index, size, angle, red, green, blue):
    # Draws one rotated letter.
    green -= 25 * index
    blue -= 10 * index
    angle = angle + 10 * index
    Label(key, x, y, fill=rgb(red, green, blue), size=size, rotateAngle=angle)

def onStep():
    # Clears the canvas.
    app.group.clear()
    Rect(0, 0, 400, 400)

    # Sets variables.
    letterSize = 400
    index = 0

    letter = choice('abcdefghijklmnopqrstuvwxyz')
    rotateAngle = randrange(0, 360)
    r = randrange(0, 256)
    g = randrange(200, 256)
    b = randrange(200, 256)
    x = randrange(100, 300)
    y = randrange(100, 300)

    # Draw a letter until the letterSize reaches 0. After each letter is
    # drawn, randomly decrease the next letter size and add 1 to the index.
    ### Place Your Code Here ###
    sizeChange = randrange(40, 100)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 1

# background
Rect(0, 0, 400, 400)

def drawLetter(key, x, y, index, size, angle, red, green, blue):
    # Draws one rotated letter.
    green -= 25 * index
    blue -= 10 * index
    angle = angle + 10 * index
    Label(key, x, y, fill=rgb(red, green, blue), size=size, rotateAngle=angle)

def onStep():
    # Clears the canvas.
    app.group.clear()
    Rect(0, 0, 400, 400)

    # Sets variables.
    letterSize = 400
    index = 0

    letter = choice('abcdefghijklmnopqrstuvwxyz')
    rotateAngle = randrange(0, 360)
    r = randrange(0, 256)
    g = randrange(200, 256)
    b = randrange(200, 256)
    x = randrange(100, 300)
    y = randrange(100, 300)

    # Draw a letter until the letterSize reaches 0. After each letter is
    # drawn, randomly decrease the next letter size and add 1 to the index.
    while (letterSize > 0):
        drawLetter(letter, x, y, index, letterSize, rotateAngle, r, g, b)
        sizeChange = randrange(40, 100)
        letterSize -= sizeChange
        index += 1
",regular,1
2272,Sheep wool,9.5,"app.background = gradient('lightSkyBlue', 'lightCyan', start='top')
Rect(0, 300, 400, 100, fill=gradient('seaGreen', 'mediumSeaGreen', start='top'))

app.stepsPerSecond = 20
app.nextAngle = 0
app.radius = 145

# sheep body
Rect(120, 315, 40, 50, fill='dimGray')
Rect(240, 315, 40, 50, fill='dimGray')
Star(200, 200, 155, 20, fill='white', roundness=95)

# This stores all of the labels making up the wool texture.
woolTexture = Group()

# sheep head
Circle(200, 200, 60, fill='dimGray')
Oval(140, 175, 70, 25, fill='dimGray', rotateAngle=320)
Oval(260, 175, 70, 25, fill='dimGray', rotateAngle=40)
Circle(170, 195, 4)
Circle(230, 195, 4)
Polygon(195, 200, 205, 200, 200, 205)

def writeLetter(letter):
    app.nextAngle += 5

    # Use the getPointInDir function with app radius and nextAngle to get
    # the nextX and nextY for the label.
    ### Place Your Code Here ###

    # Gets a random color.
    randomGray = randrange(200, 256)
    color = rgb(randomGray, randomGray, randomGray)

    # Draw the label in the correct position and add it to the woolTexture group.
   ### Place Your Code Here ###

    # Gets the next ring of words.
    if (app.nextAngle == 360):
        app.nextAngle = 0
        app.radius -= 15

    # Stops when we reach the head.
    if (app.radius == 55):
        app.paused = True

def onStep():
    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

    # Get a random letter to call writeLetter with.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightSkyBlue', 'lightCyan', start='top')
Rect(0, 300, 400, 100, fill=gradient('seaGreen', 'mediumSeaGreen', start='top'))

app.stepsPerSecond = 20
app.nextAngle = 0
app.radius = 145

# sheep body
Rect(120, 315, 40, 50, fill='dimGray')
Rect(240, 315, 40, 50, fill='dimGray')
Star(200, 200, 155, 20, fill='white', roundness=95)

# This stores all of the labels making up the wool texture.
woolTexture = Group()

# sheep head
Circle(200, 200, 60, fill='dimGray')
Oval(140, 175, 70, 25, fill='dimGray', rotateAngle=320)
Oval(260, 175, 70, 25, fill='dimGray', rotateAngle=40)
Circle(170, 195, 4)
Circle(230, 195, 4)
Polygon(195, 200, 205, 200, 200, 205)

def writeLetter(letter):
    app.nextAngle += 5

    # Use the getPointInDir function with app radius and nextAngle to get
    # the nextX and nextY for the label.
    nextX, nextY = getPointInDir(200, 200, app.nextAngle, app.radius)

    # Gets a random color.
    randomGray = randrange(200, 256)
    color = rgb(randomGray, randomGray, randomGray)

    # Draw the label in the correct position and add it to the woolTexture group.
    woolTexture.add(
        Label(letter, nextX, nextY, fill=color, size=20, bold=True,
              rotateAngle=app.nextAngle)
        )

    # Gets the next ring of words.
    if (app.nextAngle == 360):
        app.nextAngle = 0
        app.radius -= 15

    # Stops when we reach the head.
    if (app.radius == 55):
        app.paused = True

def onStep():
    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

    # Get a random letter to call writeLetter with.
    letter = alphabet[randrange(0, len(alphabet))]
    writeLetter(letter)
",regular,3
2268,Super bubbles,9.5,"app.background = gradient('lightBlue', 'aliceBlue', start='top')
app.stepsPerSecond = 20
app.stepsSinceNewBubble = 0
app.gameOver = False

Label('Score:', 50, 370, size=20, bold=True)
score = Label(0, 100, 370, size=20, bold=True)

# bubbles
bubbles = Group()
bubbles.bubbleColor = gradient(rgb(255, 215, 230), rgb(255, 0, 100),
                               start='right-top')
bubbles.speed = 8

# player
player = Group(
    Polygon(200, 330, 180, 380, 195, 370, 205, 370, 220, 380,
            fill='white', border='lightSteelBlue'),
    Polygon(200, 330, 195, 370, 200, 380, 205, 370, fill='whiteSmoke',
            border='lightSteelBlue'),
    Line(200, 330, 200, 380, fill='lightSteelBlue')
    )

def changeBubbleColor():
    # Cycles through four different bubble colors.
    redColor = gradient(rgb(255, 215, 230), rgb(255, 0, 100), start='right-top')
    greenColor = gradient(rgb(230, 250, 210), rgb(110, 215, 30), start='right-top')
    blueColor = gradient(rgb(230, 235, 255), rgb(15, 80, 255), start='right-top')
    yellowColor = gradient(rgb(255, 245, 205), rgb(255, 205, 10), start='right-top')

    if (bubbles.bubbleColor == redColor):
        bubbles.bubbleColor = yellowColor
    elif (bubbles.bubbleColor == yellowColor):
        bubbles.bubbleColor = greenColor
    elif (bubbles.bubbleColor == greenColor):
        bubbles.bubbleColor = blueColor
    else:
        bubbles.bubbleColor = redColor

def drawBubble():
    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

    letterIndex = randrange(0, 52)
    letter = alphabet[letterIndex]

    # Change the color of the letter based on if it's uppercase or lowercase.
    ### Fix Your Code Here ###
    if (0 < 1):
        letterColor = 'dodgerBlue'
    else:
        letterColor = 'gold'

    # Gets the position, radius, and color, then draws the bubble.
    bubbleX = randrange(0, 400)
    bubbleRadius = randrange(15, 66)
    changeBubbleColor()
    bubble = Group(
        Circle(bubbleX, 0, bubbleRadius, fill=bubbles.bubbleColor,
               opacity=40),
        Label(letter, bubbleX, 0, fill=letterColor, size=20, bold=True)
        )
    bubble.letter = letter

    bubbles.add(bubble)

def onMouseMove(mouseX, mouseY):
    player.centerX = mouseX
    player.centerY = mouseY

def onStep():
    if (app.gameOver == False):
        app.stepsSinceNewBubble += 1

        # Creates a new bubble every 8 steps.
        if (app.stepsSinceNewBubble % 8 == 0):
            drawBubble()

        # Moves the bubbles down.
        bubbles.centerY += bubbles.speed
        for bubble in bubbles.children:
            # Check if the player is hitting the bubble.
            # Depending on if the letter is lowercase or uppercase, either
            # add or subtract from the player width, height, and score.
            ### (HINT: The width and height should never get below 20.)
            ### Place Your Code Here ###

            # Remove any bubble that was hit.
            ### Place Your Code Here ###

            # Removes a bubble if it is below the canvas.
            if (bubble.top >= 400):
                bubbles.remove(bubble)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightBlue', 'aliceBlue', start='top')
app.stepsPerSecond = 20
app.stepsSinceNewBubble = 0
app.gameOver = False

Label('Score:', 50, 370, size=20, bold=True)
score = Label(0, 100, 370, size=20, bold=True)

# bubbles
bubbles = Group()
bubbles.bubbleColor = gradient(rgb(255, 215, 230), rgb(255, 0, 100),
                               start='right-top')
bubbles.speed = 8

# player
player = Group(
    Polygon(200, 330, 180, 380, 195, 370, 205, 370, 220, 380,
            fill='white', border='lightSteelBlue'),
    Polygon(200, 330, 195, 370, 200, 380, 205, 370, fill='whiteSmoke',
            border='lightSteelBlue'),
    Line(200, 330, 200, 380, fill='lightSteelBlue')
    )

def changeBubbleColor():
    # Cycles through four different bubble colors.
    redColor = gradient(rgb(255, 215, 230), rgb(255, 0, 100), start='right-top')
    greenColor = gradient(rgb(230, 250, 210), rgb(110, 215, 30), start='right-top')
    blueColor = gradient(rgb(230, 235, 255), rgb(15, 80, 255), start='right-top')
    yellowColor = gradient(rgb(255, 245, 205), rgb(255, 205, 10), start='right-top')

    if (bubbles.bubbleColor == redColor):
        bubbles.bubbleColor = yellowColor
    elif (bubbles.bubbleColor == yellowColor):
        bubbles.bubbleColor = greenColor
    elif (bubbles.bubbleColor == greenColor):
        bubbles.bubbleColor = blueColor
    else:
        bubbles.bubbleColor = redColor

def drawBubble():
    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

    letterIndex = randrange(0, 52)
    letter = alphabet[letterIndex]

    # Change the color of the letter based on if it's uppercase or lowercase.
    if (letter.isupper() == True):
        letterColor = 'dodgerBlue'
    else:
        letterColor = 'crimson'

    # Gets the position, radius, and color, then draws the bubble.
    bubbleX = randrange(0, 400)
    bubbleRadius = randrange(15, 66)
    changeBubbleColor()
    bubble = Group(
        Circle(bubbleX, 0, bubbleRadius, fill=bubbles.bubbleColor,
               opacity=40),
        Label(letter, bubbleX, 0, fill=letterColor, size=20, bold=True)
        )
    bubble.letter = letter

    bubbles.add(bubble)

def onMouseMove(mouseX, mouseY):
    player.centerX = mouseX
    player.centerY = mouseY

def onStep():
    if (app.gameOver == False):
        app.stepsSinceNewBubble += 1

        # Creates a new bubble every 8 steps.
        if (app.stepsSinceNewBubble % 8 == 0):
            drawBubble()

        # Moves the bubbles down.
        bubbles.centerY += bubbles.speed
        for bubble in bubbles.children:
            # Check if the player is hitting the bubble.
            # Depending on if the letter is lowercase or uppercase, either
            # add or subtract from the player width, height, and score.
            if (player.hitsShape(bubble) == True):
                if (bubble.letter.islower() == True):
                    player.width += 10
                    player.height += 10
                    score.value += 1
                else:
                    if (player.width >= 30):
                        player.width -= 10
                        player.height -= 10
                    score.value -= 1

                # Remove any bubble that was hit.
                bubbles.remove(bubble)

            # Removes a bubble if it is below the canvas.
            if (bubble.top >= 400):
                bubbles.remove(bubble)
",regular,1
2269,Typewriter,9.5,"app.background = 'saddleBrown'

Polygon(0, 400, 0, 230, 15, 165, 385, 165, 400, 230, 400, 400, fill='sienna')
Line(15, 80, 15, 165, fill='sienna')
Line(385, 80, 385, 165, fill='sienna')

Polygon(0, 0, 0, 145, 15, 80, 385, 80, 400, 145, 400, 0, fill='lavender')
Polygon(0, 145, 15, 80, 385, 80, 400, 145, 400, 70, 10, 70, 0, 110,
        fill='saddleBrown', border='sienna')

# typewriter
Circle(315, 210, 25, fill='darkGray')
Polygon(50, 225, 350, 225, 360, 325, 40, 325, fill=rgb(100, 160, 210))
Polygon(50, 225, 350, 225, 300, 175, 100, 175, fill='steelBlue')
Polygon(105, 190, 295, 190, 275, 80, 125, 80, fill='white', border='darkGray')
Rect(100, 185, 200, 10, fill='darkGray')

# message
app.messageText = 'ilovetocode'
app.index = 0

letters = Group()
message = Label('', 200, 150, size=18, font='monospace')

def drawKeyboard():
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    x = 80
    y = 250

    # For each letter in the alphabet, draws the key.
    for letter in alphabet:
        # Moves to the next line when the key would be drawn past x=340.
        if (x > 340):
            x = 80
            y += 25

        # Draws the key.
        letterKey = Oval(x, y, 30, 20, fill='dimGray')
        Label(letter, x, y, fill='white', size=14, font='monospace')

        # Keeps track of the letters drawn.
        letterKey.letter = letter
        letters.add(letterKey)

        # Moves to the next location to draw the letter.
        x += 30

def highlightNextLetter():
    # If app.index goes beyond the length of the message, reset it.
    # Then, use the index to get the selected letter from app.messageText.
    ### (HINT: You will have to define an app custom property to store the
    #          selected letter for use in onKeyPress.)
    ### Place Your Code Here ###

    # Change the color of the key that matches the letter pressed.
    ### Place Your Code Here ###
    pass

drawKeyboard()
highlightNextLetter()

def onKeyPress(key):
    # When the selected letter is pressed, increase the index, highlight
    # the next letter, and add the key to the message.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'saddleBrown'

Polygon(0, 400, 0, 230, 15, 165, 385, 165, 400, 230, 400, 400, fill='sienna')
Line(15, 80, 15, 165, fill='sienna')
Line(385, 80, 385, 165, fill='sienna')

Polygon(0, 0, 0, 145, 15, 80, 385, 80, 400, 145, 400, 0, fill='lavender')
Polygon(0, 145, 15, 80, 385, 80, 400, 145, 400, 70, 10, 70, 0, 110,
        fill='saddleBrown', border='sienna')

# typewriter
Circle(315, 210, 25, fill='darkGray')
Polygon(50, 225, 350, 225, 360, 325, 40, 325, fill=rgb(100, 160, 210))
Polygon(50, 225, 350, 225, 300, 175, 100, 175, fill='steelBlue')
Polygon(105, 190, 295, 190, 275, 80, 125, 80, fill='white', border='darkGray')
Rect(100, 185, 200, 10, fill='darkGray')

# message
app.messageText = 'ilovetocode'
app.index = 0

letters = Group()
message = Label('', 200, 150, size=18, font='monospace')

def drawKeyboard():
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    x = 80
    y = 250

    # For each letter in the alphabet, draws the key.
    for letter in alphabet:
        # Moves to the next line when the key would be drawn past x=340.
        if (x > 340):
            x = 80
            y += 25

        # Draws the key.
        letterKey = Oval(x, y, 30, 20, fill='dimGray')
        Label(letter, x, y, fill='white', size=14, font='monospace')

        # Keeps track of the letters drawn.
        letterKey.letter = letter
        letters.add(letterKey)

        # Moves to the next location to draw the letter.
        x += 30

def highlightNextLetter():
    # If app.index goes beyond the length of the message, reset it.
    # Then, use the index to get the selected letter from app.messageText.
    if (app.index == len(app.messageText)):
        app.index = 0
    app.selectedLetter = app.messageText[app.index]

    # Change the fill of the key that matches the letter pressed.
    for letterKey in letters.children:
        if (letterKey.letter == app.selectedLetter):
            letterKey.fill = 'darkGreen'
        else:
            letterKey.fill = 'dimGray'

drawKeyboard()
highlightNextLetter()

def onKeyPress(key):
    # When the selected letter is pressed, increase the index, highlight
    # the next letter, and add the key to the message.
    if (key == app.selectedLetter):
        app.index += 1
        highlightNextLetter()
        message.value += key
",regular,2
2271,Trailing words,9.5,"Label('Press space to enter text', 200, 20, size=15)

mainText = Label('', 125, 275, fill='white', size=50)
trails = Group()

def onKeyPress(key):
    dx = randrange(5, 10)
    dy = randrange(5, 10)

    # Gets a word to display.
    if (key == 'space'):
        mainText.value = app.getTextInput()

    # Gets the change in x and y directions based on the key.
    if (key == 'right'):
        dy = 0
    elif (key == 'left'):
        dy = 0
        dx *= -1
    elif (key == 'down'):
        dx = 0
    elif (key == 'up'):
        dx = 0
        dy *= -1

    red = randrange(220, 256)
    green = randrange(220, 256)
    blue = randrange(220, 256)

    # Draw labels with changing colors (by changing the green and blue values),
    # and changing position (by changing the center coordinate by dx and dy).
    # Remember to make the mainText uppercase.
    ### (HINT: You will want to decrease the green value by 15
    #          and the blue value by 20 each step.)
    ### Place Your Code Here ###

    # If r is pressed, reset the trails and put mainText back to its
    # original position with its original value.
    ### Place Your Code Here
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

Label('Press space to enter text', 200, 20, size=15)

mainText = Label('', 125, 275, fill='white', size=50)
trails = Group()

def onKeyPress(key):
    dx = randrange(5, 10)
    dy = randrange(5, 10)

    # Gets a word to display.
    if (key == 'space'):
        mainText.value = app.getTextInput()

    # Gets the change in x and y directions based on the key.
    if (key == 'right'):
        dy = 0
    elif (key == 'left'):
        dy = 0
        dx *= -1
    elif (key == 'down'):
        dx = 0
    elif (key == 'up'):
        dx = 0
        dy *= -1

    red = randrange(220, 256)
    green = randrange(220, 256)
    blue = randrange(220, 256)

    # Draw labels with changing colors (by changing the green and blue values),
    # and changing position (by changing the center coordinate by dx and dy).
    # Remember to make the mainText uppercase.
    for i in range(0, 10):
        mainText.centerX += dx
        mainText.centerY += dy
        green -= 15
        blue -= 20
        mainText.value = mainText.value.upper()
        trails.add(
            Label(mainText.value, mainText.centerX, mainText.centerY,
                  fill=rgb(red, green, blue), size=50, bold=True)
            )

    # If r is pressed, reset the trails and put mainText back to its
    # original position.
    if (key == 'r'):
        trails.clear()
        mainText.value = ''
        mainText.centerX = 125
        mainText.centerY = 275
",regular,2
2265,Green Lantern logo,9.5,"# background
Rect(0, 0, 400, 400, fill=gradient('indigo', 'black', start='top'))
app.logoSize = 2

def drawLogo(x, y, size):
    # Draws a single Green Lantern logo.
    logo = Group(
        Circle(x, y, 7, fill=gradient('lime', 'mediumSeaGreen'),
               border='green', borderWidth=size),
        Circle(x, y, 3, fill=None, border='green', borderWidth=size),
        Line(x - 3, y - 3, x + 3, y - 3, fill='green', lineWidth=1),
        Line(x - 3, y + 3, x + 3, y + 3, fill='green', lineWidth=1)
        )
    logo.width *= size
    logo.height *= size

def drawLogos():
    # While the logoSize is less than 12, draw a logo at a random location.
    # Then, randomly add 1 or 2 to the logoSize.
    ### Place Your Code Here ###
    # randomX =
    # randomY =
    pass

def onKeyPress(key):
    # Draws a new set of logos.
    app.group.clear()
    Rect(0, 0, 400, 400, fill=gradient('indigo', 'black', start='top'))
    app.logoSize = 2
    drawLogos()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 400, fill=gradient('indigo', 'black', start='top'))
app.logoSize = 2

def drawLogo(x, y, size):
    # Draws a single Green Lantern logo.
    logo = Group(
        Circle(x, y, 7, fill=gradient('lime', 'mediumSeaGreen'),
               border='green', borderWidth=size),
        Circle(x, y, 3, fill=None, border='green', borderWidth=size),
        Line(x - 3, y - 3, x + 3, y - 3, fill='green', lineWidth=1),
        Line(x - 3, y + 3, x + 3, y + 3, fill='green', lineWidth=1)
        )
    logo.width *= size
    logo.height *= size

def drawLogos():
    # While the logoSize is less than 12, draw a logo at a random location.
    # Then, randomly add 1 or 2 to the logoSize.
    while (app.logoSize < 12):
        randomX = randrange(0, 400)
        randomY = randrange(0, 400)
        drawLogo(randomX, randomY, app.logoSize)
        app.logoSize += randrange(1, 3)

def onKeyPress(key):
    # Draws a new set of logos.
    app.group.clear()
    Rect(0, 0, 400, 400, fill=gradient('indigo', 'black', start='top'))
    app.logoSize = 2
    drawLogos()
",regular,1
2274,Ghost attack,9.6,"app.background = 'black'
app.stepsPerSecond = 20

app.ghost = None
app.ghostName = None

Label(""Type the ghost's name to fend it off!"", 200, 25, fill='white', size=15)

def drawName():
    # Positions the name around the center of the canvas.
    x = randrange(50, 351)
    if ((x >= 100) and (x <= 300)):
        y = 300 * randrange(0, 2) + randrange(25, 101)
    else:
        y = randrange(50, 351)

    # Draws the name.
    app.ghostName = Group(
        Rect(x, y, 8 * len(app.ghost.forbiddenName), 20, fill='aliceBlue',
             border='lightBlue', align='center'),
        Label(app.ghost.forbiddenName, x, y)
        )
    app.ghostName.opacity = 0
    app.ghostName.dO = 4
    app.ghostName.toFront()

def createGhost():
    app.ghost = Group(
        Arc(200, 175, 60, 60, 270, 180, fill='ghostWhite'),
        Rect(170, 174, 60, 65, fill='ghostWhite'),
        Oval(190, 170, 10, 20, rotateAngle=10),
        Oval(210, 170, 10, 20, rotateAngle=-10),
        Oval(200, 190, 10, 20),
        Arc(165, 200, 35, 30, 265, 90, fill='ghostWhite', rotateAngle=30),
        Arc(235, 200, 35, 30, 5, 90, fill='ghostWhite', rotateAngle=-30),
        Polygon(165, 200, 171, 180, 171, 210, fill='ghostWhite'),
        Polygon(235, 200, 229, 180, 229, 210, fill='ghostWhite'),
        Arc(190, 238, 40, 45, 90, 180, fill='ghostWhite'),
        Arc(210, 238, 40, 30, 90, 110, fill='ghostWhite')
        )

    # Creates the ghost's name. It either has 4 vowels or 20 characters.
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    app.ghost.forbiddenName = ''
    numVowels = 0
    while ((numVowels <= 3) and (len(app.ghost.forbiddenName) < 20)):
        randIndex = randrange(0, 26)
        newCharacter = alphabet[randIndex]
        app.ghost.forbiddenName += newCharacter
        if (newCharacter in 'aeiou'):
            numVowels += 1

    # Sets the amount that the ghost's opacity decreases each time a letter
    # is pressed that is in they name.
    app.ghost.dO = -50 / len(app.ghost.forbiddenName)

    # Draws the box which contains the ghost's name.
    drawName()

createGhost()

def endGame():
    Label('Oh no, the ghost got you!', 200, 225, size=15)
    Label(""The rest of the ghost's name was:"", 200, 250, size=15)
    Label(app.ghost.forbiddenName, 200, 275, size=15)
    app.stop()

def onKeyPress(key):
    # Checks each letter in the name to see if the key matches.
    newName = ''
    for i in range(len(app.ghost.forbiddenName)):
        character = app.ghost.forbiddenName[i]
        if (key != character):
            newName += character
        else:
            app.ghost.opacity += app.ghost.dO

    app.ghost.forbiddenName = newName

def onStep():
    # When the ghost's entire name has been said, creates a new ghost.
    if (app.ghost.forbiddenName == ''):
        app.group.clear()
        createGhost()

    # Increases the size of the ghost and end the game if it gets too big.
    app.ghost.width += 2
    app.ghost.height += 2
    if (app.ghost.width >= 500):
        endGame()

    # Makes the ghost's name appear and disappear.
    app.ghostName.opacity += app.ghostName.dO
    if ((app.ghostName.opacity >= 80) or (app.ghostName.opacity <= 0)):
        app.ghostName.dO *= -1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 20

app.ghost = None
app.ghostName = None

Label(""Type the ghost's name to fend it off!"", 200, 25, fill='white', size=15)

def drawName():
    # Positions the name around the center of the canvas.
    x = randrange(50, 351)
    if ((x >= 100) and (x <= 300)):
        y = 300 * randrange(0, 2) + randrange(25, 101)
    else:
        y = randrange(50, 351)

    # Draws the name.
    app.ghostName = Group(
        Rect(x, y, 8 * len(app.ghost.forbiddenName), 20, fill='aliceBlue',
             border='lightBlue', align='center'),
        Label(app.ghost.forbiddenName, x, y)
        )
    app.ghostName.opacity = 0
    app.ghostName.dO = 4
    app.ghostName.toFront()

def createGhost():
    app.ghost = Group(
        Arc(200, 175, 60, 60, 270, 180, fill='ghostWhite'),
        Rect(170, 174, 60, 65, fill='ghostWhite'),
        Oval(190, 170, 10, 20, rotateAngle=10),
        Oval(210, 170, 10, 20, rotateAngle=-10),
        Oval(200, 190, 10, 20),
        Arc(165, 200, 35, 30, 265, 90, fill='ghostWhite', rotateAngle=30),
        Arc(235, 200, 35, 30, 5, 90, fill='ghostWhite', rotateAngle=-30),
        Polygon(165, 200, 171, 180, 171, 210, fill='ghostWhite'),
        Polygon(235, 200, 229, 180, 229, 210, fill='ghostWhite'),
        Arc(190, 238, 40, 45, 90, 180, fill='ghostWhite'),
        Arc(210, 238, 40, 30, 90, 110, fill='ghostWhite')
        )

    # Creates the ghost's name. It either has 4 vowels or 20 characters.
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    app.ghost.forbiddenName = ''
    numVowels = 0
    while ((numVowels <= 3) and (len(app.ghost.forbiddenName) < 20)):
        randIndex = randrange(0, 26)
        newCharacter = alphabet[randIndex]
        app.ghost.forbiddenName += newCharacter
        if (newCharacter in 'aeiou'):
            numVowels += 1

    # Sets the amount that the ghost's opacity decreases each time a letter
    # is pressed that is in they name.
    app.ghost.dO = -50 / len(app.ghost.forbiddenName)

    # Draws the box which contains the ghost's name.
    drawName()

createGhost()

def endGame():
    Label('Oh no, the ghost got you!', 200, 225, size=15)
    Label(""The rest of the ghost's name was:"", 200, 250, size=15)
    Label(app.ghost.forbiddenName, 200, 275, size=15)
    app.stop()

def onKeyPress(key):
    # Checks each letter in the name to see if the key matches.
    newName = ''
    for i in range(len(app.ghost.forbiddenName)):
        character = app.ghost.forbiddenName[i]
        if (key != character):
            newName += character
        else:
            app.ghost.opacity += app.ghost.dO

    app.ghost.forbiddenName = newName

def onStep():
    # When the ghost's entire name has been said, creates a new ghost.
    if (app.ghost.forbiddenName == ''):
        app.group.clear()
        createGhost()

    # Increases the size of the ghost and end the game if it gets too big.
    app.ghost.width += 2
    app.ghost.height += 2
    if (app.ghost.width >= 500):
        endGame()

    # Makes the ghost's name appear and disappear.
    app.ghostName.opacity += app.ghostName.dO
    if ((app.ghostName.opacity >= 80) or (app.ghostName.opacity <= 0)):
        app.ghostName.dO *= -1
",sample,1
2277,Creative task 3,9.6,# Fill me in!,,creative,30
2278,Creative task 4,9.6,# Fill me in!,,creative,30
2279,Creative task 5,9.6,# Fill me in!,,creative,30
2275,Creative task 1,9.6,# Fill me in!,,creative,30
2276,Creative task 2,9.6,# Fill me in!,,creative,30
2280,Collaborative task,9.6,# Fill me in!,,creative,30
2287,Moving rings,10.1.2,"app.background = 'black'

app.numRings = 0
app.ringList = [ ]

def drawCircles(n):
    app.numRings = n

    # Creates n rings.
    for index in range(n):
        # Every second ring should be thin.
        if (index % 2 == 1):
            width = 3
        else:
            width = 5
        angle = 18 * index

        # Gets the center coordinate of the ring by using the angle
        # and the center of the canvas.
        centerX, centerY = getPointInDir(200, 200, angle, 60)

        # Adds the ring to the rings group.
        rings.add(
            Circle(centerX, centerY, 60, fill=None, border='mediumAquamarine',
                   borderWidth=width)
            )

rings = Group()
drawCircles(20)
app.ringList = rings.children

def onKeyHold(keys):
    borderColor = gradient('pink', 'hotPink', start='top')

    # For every other ring, set the border fill to borderColor and increase
    # or decrease the radius depending on if 'up' or 'down' is held.
    ### (HINT: The list app.ringList contains every ring in the
    #          rings group!)
    ### (HINT: Don't let the ring radius get below 5.)
    ### Place Your Code Here ###

def onKeyRelease(key):
    # Resets all the ring borders to white.
    for ring in app.ringList:
        ring.border = 'mediumAquamarine'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

app.numRings = 0
app.ringList = [ ]

def drawCircles(n):
    app.numRings = n

    # Creates n rings.
    for index in range(n):
        # Every second ring should be thin.
        if (index % 2 == 1):
            width = 3
        else:
            width = 5
        angle = 18 * index

        # Gets the center coordinate of the ring by using the angle
        # and the center of the canvas.
        centerX, centerY = getPointInDir(200, 200, angle, 60)

        # Adds the ring to the rings group.
        rings.add(
            Circle(centerX, centerY, 60, fill=None, border='mediumAquamarine',
                   borderWidth=width)
            )

rings = Group()
drawCircles(20)
app.ringList = rings.children

def onKeyHold(keys):
    borderColor = gradient('pink', 'hotPink', start='top')

    # For every other ring, set the border fill to borderColor and increase
    # or decrease the radius depending on if 'up' or 'down' is held.
    for index in range(0, app.numRings, 2):
        ring = app.ringList[index]
        ring.border = borderColor
        if ('up' in keys):
            ring.radius += 5
        elif (('down' in keys) and (ring.radius >= 10)):
            ring.radius -= 5

def onKeyRelease(key):
    # Resets all the ring borders to white.
    for ring in app.ringList:
        ring.border = 'mediumAquamarine'
",regular,2
2283,Colorful circles,10.1.2,"app.background = 'darkBlue'
app.stepsPerSecond = 3

circles = Group()

def onStep():
    colors = [ 'lightCoral', 'deepSkyBlue', 'mediumPurple',
               'lavender', 'crimson' ]

    # Loop through the colors and add a circle for each color.
    ### Place Your Code Here ###

    # Each circle should have a random x and y coordinate between 0 and
    # 400 and a random radius between 5 and 20. (not including 400 and 20.)
    ### Place Your Code Here ###

    # Increases the size of all the circles until they get to 50, then
    # removes them.
    for circle in circles.children:
        circle.radius += 5
        if (circle.radius > 50):
            circles.remove(circle)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'darkBlue'
app.stepsPerSecond = 3

circles = Group()

def onStep():
    colors = [ 'lightCoral', 'deepSkyBlue', 'mediumPurple',
               'lavender', 'crimson' ]

    # Loop through the colors and add a circle for each color.
    for color in colors:
        # Each circle should have a random x and y coordinate between 0 and
        # 400 and a random radius between 5 and 20. (not including 400 and 20.)
        centerX = randrange(0, 400)
        centerY = randrange(0, 400)
        radius = randrange(5, 20)
        circles.add(
            Circle(centerX, centerY, radius, fill=color, border='black',
                   borderWidth=3)
            )

    # Increases the size of all the circles until they get to 50, then
    # removes them.
    for circle in circles.children:
        circle.radius += 5
        if (circle.radius > 50):
            circles.remove(circle)
",regular,1
2284,Fireworks revisited,10.1.2,"app.background = gradient('midnightBlue', 'steelBlue', start='top')
app.stepsPerSecond = 60

Polygon(150, 400, 300, 200, 450, 400,
        fill=gradient('darkSlateBlue', 'darkBlue', start='top'))
Polygon(-100, 400, 100, 100, 300, 400,
        fill=gradient('darkSlateBlue', 'midnightBlue', start='top'))

fireworks = Group()
streams = Group()

clouds = Group(
    Circle(90, 50, 20, fill=rgb(80, 80, 150)),
    Circle(110, 50, 20, fill=rgb(80, 80, 150)),
    Circle(100, 60, 20, fill=rgb(80, 80, 150)),
    Circle(120, 60, 20, fill=rgb(80, 80, 150)),
    Circle(80, 60, 20, fill=rgb(80, 80, 150))
    )

ferrisWheel = Star(100, 300, 75, 20, fill='white', roundness=15)

def drawRings():
    # Adds inner loops for ferris wheel.
    ringBorderColors = [ 'lightBlue', 'red', 'yellow', 'green', 'purple', 'blue' ]
    ringNumber = 1

    # Make a ring for each of the colors in the ringBorderColors list.
    ### (HINT: The radius of each ring should be the radius of the ferrisWheel
    #          divided by how many rings we have made so far, including the
    #          new ring.)
    ### Place Your Code Here ###

drawRings()

# Adds highlights and legs for ferris wheel.
Circle(100, 300, 71, fill=None, border='white')
Circle(100, 300, 79, fill=None, border='white')
Line(75, 400, 100, 300, fill='white', lineWidth=4)
Line(125, 400, 100, 300, fill='white', lineWidth=4)

def onMousePress(mouseX, mouseY):
    fireWorkColors = [ 'red', 'lime', 'magenta', 'yellow', 'orangeRed',
                       'powderBlue' ]

    # Get a random color for the firework from fireWorkColors.
    ### Fix Your Code Here ###
    randomColor = fireWorkColors[0]

    # Makes the firework.
    newStream = Line(mouseX, 400, mouseX, 460, fill=randomColor)
    newStream.fireworkHeight = mouseY
    newStream.color = randomColor
    streams.add(newStream)

def makeNewExplosion(cx, cy, color):
    # Firework goes off.
    firework = Group(
        Star(cx, cy, randrange(5, 20), 1500, fill=color),
        Star(cx, cy, 1, 30, fill=color, roundness=10)
        )
    fireworks.add(firework)

def animateLaunches():
    # Moves the firework trails up.
    streams.toFront()
    for stream in streams.children:
        stream.top -= 5
        stream.opacity -= 1

        # If the firework has reached the height, it should explode.
        if (stream.top <= stream.fireworkHeight):
            streams.remove(stream)
            makeNewExplosion(stream.x1, stream.y1, stream.color)

def animateExplosions():
    # Expands and fades out all of the explosions.
    fireworks.toFront()
    for firework in fireworks.children:
        firework.width += 1
        firework.height += 1
        firework.opacity -= 2
        firework.rotateAngle += 5

        # Once the firework has faded enough, removes it completely.
        if (firework.opacity <= 3):
            fireworks.remove(firework)

def rotateFerrisWheel():
    ferrisWheel.rotateAngle += 0.1

def moveCloud():
    clouds.centerX += 1
    if (clouds.left >= 400):
        clouds.right = 0

def onStep():
    animateExplosions()
    animateLaunches()
    rotateFerrisWheel()
    moveCloud()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('midnightBlue', 'steelBlue', start='top')
app.stepsPerSecond = 60

Polygon(150, 400, 300, 200, 450, 400,
        fill=gradient('darkSlateBlue', 'darkBlue', start='top'))
Polygon(-100, 400, 100, 100, 300, 400,
        fill=gradient('darkSlateBlue', 'midnightBlue', start='top'))

fireworks = Group()
streams = Group()

clouds = Group(
    Circle(90, 50, 20, fill=rgb(80, 80, 150)),
    Circle(110, 50, 20, fill=rgb(80, 80, 150)),
    Circle(100, 60, 20, fill=rgb(80, 80, 150)),
    Circle(120, 60, 20, fill=rgb(80, 80, 150)),
    Circle(80, 60, 20, fill=rgb(80, 80, 150))
    )

ferrisWheel = Star(100, 300, 75, 20, fill='white', roundness=15)

def drawRings():
    # Adds inner loops for ferris wheel.
    ringBorderColors = [ 'lightBlue', 'red', 'yellow', 'green', 'purple', 'blue' ]
    ringNumber = 1

    # Make a ring for each of the colors in the ringBorderColors list.
    for borderColor in ringBorderColors:
        newRadius = ferrisWheel.radius / (ringNumber)
        Circle(100, 300, newRadius, fill=None, border=borderColor, borderWidth=8,
               opacity=70)
        ringNumber += 1

drawRings()

# Adds highlights and legs for ferris wheel.
Circle(100, 300, 71, fill=None, border='white')
Circle(100, 300, 79, fill=None, border='white')
Line(75, 400, 100, 300, fill='white', lineWidth=4)
Line(125, 400, 100, 300, fill='white', lineWidth=4)

def onMousePress(mouseX, mouseY):
    fireWorkColors = [ 'red', 'lime', 'magenta', 'yellow', 'orangeRed',
                       'powderBlue' ]

    # Get a random color for the firework from fireWorkColors.
    randomColor = fireWorkColors[randrange(0, len(fireWorkColors))]

    # Makes the firework.
    newStream = Line(mouseX, 400, mouseX, 460, fill=randomColor)
    newStream.fireworkHeight = mouseY
    newStream.color = randomColor
    streams.add(newStream)

def makeNewExplosion(cx, cy, color):
    # Firework goes off.
    firework = Group(
        Star(cx, cy, randrange(5, 20), 1500, fill=color),
        Star(cx, cy, 1, 30, fill=color, roundness=10)
        )
    fireworks.add(firework)

def animateLaunches():
    # Moves the firework trails up.
    streams.toFront()
    for stream in streams.children:
        stream.top -= 5
        stream.opacity -= 1

        # If the firework has reached the height, it should explode.
        if (stream.top <= stream.fireworkHeight):
            streams.remove(stream)
            makeNewExplosion(stream.x1, stream.y1, stream.color)

def animateExplosions():
    # Expands and fades out all of the explosions.
    fireworks.toFront()
    for firework in fireworks.children:
        firework.width += 1
        firework.height += 1
        firework.opacity -= 2
        firework.rotateAngle += 5

        # Once the firework has faded enough, removes it completely.
        if (firework.opacity <= 3):
            fireworks.remove(firework)

def rotateFerrisWheel():
    ferrisWheel.rotateAngle += 0.1

def moveCloud():
    clouds.centerX += 1
    if (clouds.left >= 400):
        clouds.right = 0

def onStep():
    animateExplosions()
    animateLaunches()
    rotateFerrisWheel()
    moveCloud()
",regular,1
2285,Is for,10.1.2,"app.background = gradient('mediumPurple', 'darkSlateBlue', start='top')

# Initializes all the sentences.
app.sentences = [ 'a is for apple', 'b is for banana', 'c is for cherry',
                  'd is for dragon fruit', 'e is for elderberry', 'f is for fig',
                  'g is for grapes', 'h is for honeydew melon', 'i is for imbe',
                  'j is for jackfruit', 'k is for kiwi', 'l is for lime',
                  'm is for mango', 'n is for nectarine', 'o is for orange',
                  'p is for papaya', 'q is for quince', 'r is for raspberries',
                  's is for strawberries', 't is for tomato', 'u is for ugli fruit',
                  'v is for vanilla bean', 'w is for watermelon', 'x is for xigua',
                  'y is for yucca root', 'z is for zuchinni' ]

letters = Group()

def getFirstLetter():
    # Loop over all the sentences and get the first letter of each sentence.
    ### Fix Your Code Here ###
    sentences = [ ]
    for sentence in sentences:
        letter = sentence
        letters.add(
            Label(letter, randrange(30, 371), randrange(30, 371),
                  fill='lightCyan', size=30)
            )

getFirstLetter()
sentenceBox = Group()

def drawSentenceBox(letter):
    # Draws the box containing the 'is for' sentence.
    for line in app.sentences:
        if (line[0] == letter.value):
            centerX = letter.centerX
            centerY = letter.centerY - 30
            label = Label(line, centerX, centerY, fill='white', size=15)
            sentenceBox.add(
                Rect(centerX, centerY, label.width + 10, 20, opacity=40,
                     align='center'),
                RegularPolygon(centerX, centerY + 12, 5, 3, rotateAngle=180,
                               opacity=40),
                label
                )

def onMouseMove(mouseX, mouseY):
    sentenceBox.clear()

    # Checks if the mouse is hovering over a letter and draws a sentence if so.
    for letter in letters.children:
        if (letter.contains(mouseX, mouseY) == True):
            drawSentenceBox(letter)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('mediumPurple', 'darkSlateBlue', start='top')

# Initializes all the sentences.
app.sentences = [ 'a is for apple', 'b is for banana', 'c is for cherry',
                  'd is for dragon fruit', 'e is for elderberry', 'f is for fig',
                  'g is for grapes', 'h is for honeydew melon', 'i is for imbe',
                  'j is for jackfruit', 'k is for kiwi', 'l is for lime',
                  'm is for mango', 'n is for nectarine', 'o is for orange',
                  'p is for papaya', 'q is for quince', 'r is for raspberries',
                  's is for strawberries', 't is for tomato', 'u is for ugli fruit',
                  'v is for vanilla bean', 'w is for watermelon', 'x is for xigua',
                  'y is for yucca root', 'z is for zuchinni' ]

letters = Group()

def getFirstLetter():
    # Loop over all the sentences and get the first letter of each sentence.
    for sentence in app.sentences:
        letter = sentence[0]
        letters.add(
            Label(letter, randrange(30, 371), randrange(30, 371),
                  fill='lightCyan', size=30)
            )

getFirstLetter()
sentenceBox = Group()

def drawSentenceBox(letter):
    # Draws the box containing the 'is for' sentence.
    for line in app.sentences:
        if (line[0] == letter.value):
            centerX = letter.centerX
            centerY = letter.centerY - 30
            label = Label(line, centerX, centerY, fill='white', size=15)
            sentenceBox.add(
                Rect(centerX, centerY, label.width + 10, 20, opacity=40,
                     align='center'),
                RegularPolygon(centerX, centerY + 12, 5, 3, rotateAngle=180,
                               opacity=40),
                label
                )

def onMouseMove(mouseX, mouseY):
    sentenceBox.clear()

    # Checks if the mouse is hovering over a letter and draws a sentence if so.
    for letter in letters.children:
        if (letter.contains(mouseX, mouseY) == True):
            drawSentenceBox(letter)
",regular,1
2286,Popcorn,10.1.2,"app.background = rgb(0, 0, 80)

# screen
Rect(0, 25, 400, 350)

# curtains
Oval(0, 0, 100, 600, fill=rgb(50, 10, 0), rotateAngle=5)
Oval(400, 0, 100, 600, fill=rgb(50, 10, 0), rotateAngle=-5)

# chairs
Oval(200, 500, 350, 350, fill=rgb(130, 20, 10))
Oval(-100, 500, 350, 350, fill=rgb(130, 20, 10))
Oval(500, 500, 350, 350, fill=rgb(130, 20, 10))

popcorn = Group()

def drawCup():
    # Draws the cup in front of everything else.
    Polygon(100, 400, 70, 250, 330, 250, 300, 400, fill='red')
    for centerX in range(110, 261, 50):
        Rect(centerX, 250, 30, 150, fill='white')

def drawPopcorn(centerX, centerY):
    color1 = gradient('gold', 'khaki')
    color2 = 'paleGoldenrod'
    popcornPiece = Group(
        Circle(centerX, centerY, 25, fill=color1, border=color2),
        Circle(centerX + 15, centerY - 25, 15, fill=color1, border=color2),
        Circle(centerX + 20, centerY - 10, 15, fill=color1, border=color2),
        Circle(centerX - 15, centerY - 25, 15, fill=color1, border=color2),
        Circle(centerX - 20, centerY - 10, 15, fill=color1, border=color2),
        Circle(centerX, centerY-5, 15, fill=color1),
        )
    popcorn.add(popcornPiece)

    # Create a custom property isMovingUp for each piece.
    ### Place Your Code Here ###

def makePopcorn():
    # Creates the lists we need.
    xList = [ 100, 140, 170, 200, 240, 280, 300 ]
    yList = [ 170, 200, 240 ]

    # Loop through each list and draw a piece of popcorn using that
    # centerX and centerY.
    ### (HINT: You should use a nested loop through xList and yList.)
    ### Place Your Code Here ###

makePopcorn()
drawCup()

def onStep():
    # As long as we have some popcorn, gets a random piece of popcorn.
    if (len(popcorn.children) > 0):
        popcornPiece = popcorn.children[randrange(0, len(popcorn.children))]

        # Moves the popcorn either up or down and change direction for next step.
        if (popcornPiece.isMovingUp == True):
            popcornPiece.centerY -= 10
            popcornPiece.isMovingUp = False
        else:
            popcornPiece.centerY += 10
            popcornPiece.isMovingUp = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(0, 0, 80)

# screen
Rect(0, 25, 400, 350)

# curtains
Oval(0, 0, 100, 600, fill=rgb(50, 10, 0), rotateAngle=5)
Oval(400, 0, 100, 600, fill=rgb(50, 10, 0), rotateAngle=-5)

# chairs
Oval(200, 500, 350, 350, fill=rgb(130, 20, 10))
Oval(-100, 500, 350, 350, fill=rgb(130, 20, 10))
Oval(500, 500, 350, 350, fill=rgb(130, 20, 10))

popcorn = Group()

def drawCup():
    # Draws the cup in front of everything else.
    Polygon(100, 400, 70, 250, 330, 250, 300, 400, fill='red')
    for centerX in range(110, 261, 50):
        Rect(centerX, 250, 30, 150, fill='white')

def drawPopcorn(centerX, centerY):
    color1 = gradient('gold', 'khaki')
    color2 = 'paleGoldenrod'
    popcornPiece = Group(
        Circle(centerX, centerY, 25, fill=color1, border=color2),
        Circle(centerX + 15, centerY - 25, 15, fill=color1, border=color2),
        Circle(centerX + 20, centerY - 10, 15, fill=color1, border=color2),
        Circle(centerX - 15, centerY - 25, 15, fill=color1, border=color2),
        Circle(centerX - 20, centerY - 10, 15, fill=color1, border=color2),
        Circle(centerX, centerY-5, 15, fill=color1),
        )
    popcorn.add(popcornPiece)

    # Create a custom property isMovingUp for each piece.
    popcornPiece.isMovingUp = True

def makePopcorn():
    # Creates the lists we need.
    xList = [ 100, 140, 170, 200, 240, 280, 300 ]
    yList = [ 170, 200, 240 ]

    # Loop through each list and draw a piece of popcorn using that
    # centerX and centerY.
    for centerX in xList:
        for centerY in yList:
            drawPopcorn(centerX, centerY)

makePopcorn()
drawCup()

def onStep():
    # As long as we have some popcorn, gets a random piece of popcorn.
    if (len(popcorn.children) > 0):
        popcornPiece = popcorn.children[randrange(0, len(popcorn.children))]

        # Moves the popcorn either up or down and change direction for next step.
        if (popcornPiece.isMovingUp == True):
            popcornPiece.centerY -= 10
            popcornPiece.isMovingUp = False
        else:
            popcornPiece.centerY += 10
            popcornPiece.isMovingUp = True
",regular,2
2288,Grow roses,10.1.2,"app.background='skyBlue'

app.lightColor = 'lightCoral'
app.darkColor = 'darkRed'

roseBush = Group(
    Oval(220, 130, 150, 120, fill='seaGreen'),
    Oval(130, 180, 210, 150, fill='seaGreen'),
    Oval(20, 240, 180, 150, fill='seaGreen'),
    Oval(320, 180, 210, 170, fill='seaGreen'),
    Rect(0, 200, 400, 200, fill='seaGreen')
    )

def getRoseColors():
    # Picks a random color for the rose to be.
    randNum = randrange(0, 3)
    if (randNum == 0):
        app.lightColor = 'lightCoral'
        app.darkColor = 'darkRed'
    elif (randNum == 1):
        app.lightColor = 'mistyRose'
        app.darkColor = 'pink'
    else:
        app.lightColor = 'gold'
        app.darkColor = 'orange'

def drawPetalRing(numberOfPetals, x, y):
    width = 1.5 * numberOfPetals
    height = 3 * numberOfPetals

    # Create a ring of petals.
    for i in range(numberOfPetals):
        angle = 30 * i

        # Alternate whether the color of the petal is light or dark.
        ### (HINT: The first petal should be the light color.)
        ### Place Your Code Here ###

        # Draw a petal.
        ### Place Your Code Here ###

def onMousePress(mouseX, mouseY):
    numberOfPetalsInRing = [ 19, 17, 13, 11, 7, 5, 1 ]

    # If you click on the roseBush, draw a rose.
    if (roseBush.hits(mouseX, mouseY) == True):
        randNum = randrange(0, 3)
        getRoseColors()

        # To draw a rose, draw one petal ring for each number in the
        # numberOfPetalsInRing list.
        ### Fix Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background='skyBlue'

app.lightColor = 'lightCoral'
app.darkColor = 'darkRed'

roseBush = Group(
    Oval(220, 130, 150, 120, fill='seaGreen'),
    Oval(130, 180, 210, 150, fill='seaGreen'),
    Oval(20, 240, 180, 150, fill='seaGreen'),
    Oval(320, 180, 210, 170, fill='seaGreen'),
    Rect(0, 200, 400, 200, fill='seaGreen')
    )

def getRoseColors():
    # Picks a random color for the rose to be.
    randNum = randrange(0, 3)
    if (randNum == 0):
        app.lightColor = 'lightCoral'
        app.darkColor = 'darkRed'
    elif (randNum == 1):
        app.lightColor = 'mistyRose'
        app.darkColor = 'pink'
    else:
        app.lightColor = 'gold'
        app.darkColor = 'orange'

def drawPetalRing(numberOfPetals, x, y):
    width = 1.5 * numberOfPetals
    height = 3 * numberOfPetals

    # Create a ring of petals.
    for i in range(numberOfPetals):
        angle = 30 * i

        # Alternate whether the color of the petal is light or dark.
        if (i % 2 == 0):
            color = app.lightColor
        else:
            color = app.darkColor

        # Draw a petal.
        Rect(x, y, width, height, fill=color, rotateAngle=angle,
             align='center')

def onMousePress(mouseX, mouseY):
    numberOfPetalsInRing = [ 19, 17, 13, 11, 7, 5, 1 ]

    # If you click on the roseBush, draw a rose.
    if (roseBush.hits(mouseX, mouseY) == True):
        randNum = randrange(0, 3)
        getRoseColors()

        # To draw a rose, draw one petal ring for each number in the
        # numberOfPetalsInRing list.
        for num in numberOfPetalsInRing:
            drawPetalRing(num, mouseX, mouseY)
",regular,3
2294,Tree creator,10.2.2,"app.background = 'skyBlue'

# tree
Polygon(175, 400, 225, 400, 205, 120, 195, 120,
        fill=gradient('saddleBrown', 'burlyWood', start='left'))
Rect(0, 370, 400, 30, fill='forestGreen')

app.lastX = 200
app.lastY = 120
app.oldXVals = [ ]
app.oldYVals = [ ]
app.leafColors = [ 'darkGreen', 'forestGreen', 'oliveDrab', 'mediumSeaGreen' ]

def onKeyPress(key):
    if (len(app.oldXVals) > 1):
        # Set app.lastX and app.lastY to a random element from the
        # oldVals lists.
        ### (HINT: While using a random index would give the same result,
        #          for this exercise try getting a random element a
        #          different way!)
        ### Place Your Code Here ###
        pass

def onStep():
    # Gets a new (x,y) position.
    newX = app.lastX + randrange(-20, 21)
    newY = app.lastY + randrange(-20, 21)

    # Get a new color for the leaf and then draw a line using the app properties.
    ### Place Your Code Here ###

    # Add the lastX and lastX to the oldVals lists.
    ### Place Your Code Here ###

    # Update lastX and lastY to the new positions.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'skyBlue'

# tree
Polygon(175, 400, 225, 400, 205, 120, 195, 120,
        fill=gradient('saddleBrown', 'burlyWood', start='left'))
Rect(0, 370, 400, 30, fill='forestGreen')

app.lastX = 200
app.lastY = 120
app.oldXVals = [ ]
app.oldYVals = [ ]
app.leafColors = [ 'darkGreen', 'forestGreen', 'oliveDrab', 'mediumSeaGreen' ]

def onKeyPress(key):
    if (len(app.oldXVals) > 1):
        # Set app.lastX and app.lastY to a random element from the
        # oldVals lists.
        app.lastX = choice(app.oldXVals)
        app.lastY = choice(app.oldYVals)

def onStep():
    # Gets a new (x,y) position.
    newX = app.lastX + randrange(-20, 21)
    newY = app.lastY + randrange(-20, 21)

    # Get a new color for the leaf and then draw a line using the app properties.
    color = choice(app.leafColors)
    Line(app.lastX, app.lastY, newX, newY, fill=color, lineWidth=20)

    # Add the lastX and lastY to the oldVals lists.
    app.oldXVals.append(app.lastX)
    app.oldYVals.append(app.lastY)

    # Update lastX and lastY to the new positions.
    app.lastX = newX
    app.lastY = newY
",regular,3
2292,Flashy,10.2.2,"app.stepsPerSecond = 10

# Creates the lists of x and y coordinates for the circles.
app.listX = [ ]
app.listY = [ ]
app.listColors = [ 'lightCoral', 'paleGreen', 'lavender' ]

Rect(0, 0, 400, 400)

def addCircle():
    centerX = randrange(0, 400)
    centerY = randrange(0, 400)

    # Add the x coordinate and y coordinate to the appropriate list.
    ### Place Your Code Here ###

def removeCircle():
    if (len(app.listX) > 10):
        removeIndex = randrange(0, len(app.listX))

        # Use removeIndex to get rid of the element at that index in
        # both listX and listY.
        ### Fix Your Code Here ###
        app.listX.pop()
        app.listY.pop()

def drawCircles():
    # Clears the canvas and redraws the background.
    app.group.clear()
    Rect(0, 0, 400, 400)

    # Loops over all the coordinates and draws 2 circles with random
    # radius and color.
    for index in range(len(app.listX)):
        centerX = app.listX[index]
        centerY = app.listY[index]
        radius = randrange(5, 25)

        color = choice(app.listColors)

        Circle(centerX, centerY, radius, fill=None, border=color)
        Circle(centerX, centerY, radius + 5, fill=None, border=color,
               borderWidth=3)

def onStep():
    addCircle()
    removeCircle()
    drawCircles()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 10

# Creates the lists of x and y coordinates for the circles.
app.listX = [ ]
app.listY = [ ]
app.listColors = [ 'lightCoral', 'paleGreen', 'lavender' ]

Rect(0, 0, 400, 400)

def addCircle():
    centerX = randrange(0, 400)
    centerY = randrange(0, 400)

    # Add the x coordinate and y coordinate to the appropriate list.
    app.listX.append(centerX)
    app.listY.append(centerY)

def removeCircle():
    if (len(app.listX) > 10):
        removeIndex = randrange(0, len(app.listX))

        # Use removeIndex to get rid of the element at that index in
        # both listX and listY.
        app.listX.pop(removeIndex)
        app.listY.pop(removeIndex)

def drawCircles():
    # Clears the canvas and redraws the background.
    app.group.clear()
    Rect(0, 0, 400, 400)

    # Loops over all the coordinates and draws 2 circles with random
    # radius and color.
    for index in range(len(app.listX)):
        centerX = app.listX[index]
        centerY = app.listY[index]
        radius = randrange(5, 25)

        color = choice(app.listColors)

        Circle(centerX, centerY, radius, fill=None, border=color)
        Circle(centerX, centerY, radius + 5, fill=None, border=color,
               borderWidth=3)

def onStep():
    addCircle()
    removeCircle()
    drawCircles()
",regular,1
2289,Reds,10.2.2,"app.stepsPerSecond = 5

app.reds = [ 255, 220, 200, 150, 125, 100, 90, 75, 50, 10 ]
app.y = 0

Rect(0, 0, 400, 400)

def drawRowOfRectangles():
    x = 0
    # Draws a rectangle for each red value.
    for red in app.reds:
        Rect(x, app.y, 40, 25, fill=rgb(red, 0, 0))
        x += 40

def onStep():
    drawRowOfRectangles()

    # Remove the last value from the app.reds list and store it in newVal.
    ### Fix Your Code Here ###
    newVal = 0

    # Creates a new list with the last value.
    newList = [ newVal ]

    # Add back all of the other values.
    ### (HINT: Loop over app.reds and add each element to newList.)
    ### Place Your Code Here ###

    # Sets app.reds equal to the new list.
    app.reds = newList

    # Shifts where the next rectangle will be drawn.
    app.y += 25
    if (app.y >= 400):
        app.paused = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 5

app.reds = [ 255, 220, 200, 150, 125, 100, 90, 75, 50, 10 ]
app.y = 0

Rect(0, 0, 400, 400)

def drawRowOfRectangles():
    x = 0
    # Draws a rectangle for each red value.
    for red in app.reds:
        Rect(x, app.y, 40, 25, fill=rgb(red, 0, 0))
        x += 40

def onStep():
    drawRowOfRectangles()

    # Remove the last value from the app.reds list and store it in newVal.
    newVal = app.reds.pop()

    # Creates a new list with the last value.
    newList = [ newVal ]

    # Add back all of the other values.
    for r in app.reds:
        newList.append(r)

    # Sets app.reds equal to the new list.
    app.reds = newList

    # Shifts where the next rectangle will be drawn.
    app.y += 25
    if (app.y >= 400):
        app.paused = True
",regular,1
2290,Random sentence generator,10.2.2,"app.background = gradient('tan', 'sienna', start='left-top')
app.stepsPerSecond = 20

app.x = 40
app.y = 90
app.words = [ 'the', 'dog', 'cat', 'was', 'blue', 'nice', 'and' ]

# book
Rect(25, 75, 350, 250, fill='fireBrick')
Oval(200, 325, 60, 10, fill='fireBrick')
Rect(225, 25, 20, 55, fill='red')
Polygon(225, 25, 225, 15, 235, 20, 245, 15, 245, 25, fill='red')
Rect(30, 80, 340, 240, fill='white')
Line(200, 80, 200, 320, lineWidth=5, opacity=10)

def drawWord(word):
    # Draws a word at the current app location.
    x = app.x + 2 * len(word)
    Label(word, x, app.y, size=9)

def onKeyPress(key):
    # If 'space' is pressed, ask the user to 'Type a word' and add
    # it to app.words.
    if (key == 'space'):
        newWord = app.getTextInput('Type a word')
        ### Place Your Code Here ###

    # If r is pressed, get rid of the last word in app.words.
    ### (HINT: Make sure there is something to remove from app.words first!)
    ### Place Your Code Here ###

def onStep():
    # Gets a new random word from app.words and draws it.
    if (len(app.words) > 0):
        newWord = choice(app.words)
        drawWord(newWord)

    # Moves where we will draw the next word.
    app.x += 20
    if ((app.x < 215) and (app.x > 180)):
        app.y += 10
        app.x = 40
    elif (app.x > 350):
        app.y += 10
        app.x = 215
    if ((app.y > 310) and (app.x < 200)):
        app.x = 215
        app.y = 90
    elif ((app.y > 310) and (app.x > 200)):
        app.paused = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('tan', 'sienna', start='left-top')
app.stepsPerSecond = 20

app.x = 40
app.y = 90
app.words = [ 'the', 'dog', 'cat', 'was', 'blue', 'nice', 'and' ]

# book
Rect(25, 75, 350, 250, fill='fireBrick')
Oval(200, 325, 60, 10, fill='fireBrick')
Rect(225, 25, 20, 55, fill='red')
Polygon(225, 25, 225, 15, 235, 20, 245, 15, 245, 25, fill='red')
Rect(30, 80, 340, 240, fill='white')
Line(200, 80, 200, 320, lineWidth=5, opacity=10)

def drawWord(word):
    # Draws a word at the current app location.
    x = app.x + 2 * len(word)
    Label(word, x, app.y, size=9)

def onKeyPress(key):
    # If 'space' is pressed, ask the user to 'Type a word' and add
    # it to app.words.
    if (key == 'space'):
        newWord = app.getTextInput('Type a word')
        app.words.append(newWord)

    # If r is pressed, get rid of the last word in app.words.
    elif ((key == 'r') and (len(app.words) > 0)):
        app.words.pop()

def onStep():
    # Gets a new random word from app.words and draws it.
    if (len(app.words) > 0):
        newWord = choice(app.words)
        drawWord(newWord)

    # Moves where we will draw the next word.
    app.x += 20
    if ((app.x < 215) and (app.x > 180)):
        app.y += 10
        app.x = 40
    elif (app.x > 350):
        app.y += 10
        app.x = 215
    if ((app.y > 310) and (app.x < 200)):
        app.x = 215
        app.y = 90
    elif ((app.y > 310) and (app.x > 200)):
        app.paused = True
",regular,1
2291,Reverse sentence,10.2.2,"# background
Rect(0, 0, 400, 200, fill='cornSilk')
Rect(0, 200, 400, 200, fill='steelBlue')
Circle(200, 200, 55, fill='white', border='black', borderWidth=1, dashes=True)
Label('reversed is', 200, 200, size=20)

def drawSentence(L, centerX, centerY, isReversed):
    # Constructs a sentence using the words in L.
    sentence = ''
    for word in L:
        sentence += word

        # Adds spaces in-between the words in our sentence.
        sentence += ' '

    color = 'aquamarine'
    if (isReversed == False):
        color = 'salmon'

    Label(sentence, centerX, centerY, fill=color, size=33)

def reverseSentence(wordList):
    # Draws the normal sentence.
    drawSentence(wordList, 200, 100, False)

    reversedList = [ ]

    # Loop through the list of words and pop each word.
    # Then add it to reversedList, building up the list in reverse order!
    ### Place Your Code Here ###

    # Draws the reversed sentence.
    drawSentence(reversedList, 200, 300, True)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# background
Rect(0, 0, 400, 200, fill='cornSilk')
Rect(0, 200, 400, 200, fill='steelBlue')
Circle(200, 200, 55, fill='white', border='black', borderWidth=1, dashes=True)
Label('reversed is', 200, 200, size=20)

def drawSentence(L, centerX, centerY, isReversed):
    # Constructs a sentence using the words in L.
    sentence = ''
    for word in L:
        sentence += word

        # Adds spaces in-between the words in our sentence.
        sentence += ' '

    color = 'aquamarine'
    if (isReversed == False):
        color = 'salmon'

    Label(sentence, centerX, centerY, fill=color, size=33)

def reverseSentence(wordList):
    # Draws the normal sentence.
    drawSentence(wordList, 200, 100, False)

    reversedList = [ ]

    # Loop through the list of words and pop each word.
    # Then add it to reversedList, building up the list in reverse order!
    for num in range(len(wordList)):
        word = wordList.pop()
        reversedList.append(word)

    # Draws the reversed sentence.
    drawSentence(reversedList, 200, 300, True)
",regular,1
2293,Whack a bug,10.2.2,"app.stepsPerSecond = 2
app.bugs = [ ]

# background
Rect(0, 0, 400, 150, fill=gradient('cornSilk', 'ghostWhite', start='top'))
Rect(0, 150, 400, 250, fill=gradient('peru', 'saddleBrown', start='top'))

Label('You have whacked', 150, 60, fill='saddleBrown', size=20, bold=True)
score = Label(0, 255, 60, fill='saddleBrown', size=20, bold=True)
Label('bugs!', 300, 60, fill='saddleBrown', size=20, bold=True)

def drawBug(x, y):
    Oval(x, y, 100, 40,
         fill=gradient('saddleBrown', rgb(120, 15, 10), start='top'))

    bugColor = gradient('greenYellow', rgb(135, 170, 65), start='right')
    bug = Group(
        Rect(x, y, 30, 60, fill=bugColor, align='bottom'),
        Circle(x, y - 60, 15, fill=bugColor),
        Label('O o', x, y - 70, bold=True),
        Label('_', x, y - 65, bold=True),
        Line(x, y, x, y - 60, fill='oliveDrab', lineWidth=30, dashes=(2, 12))
        )

    # Hide the bug and add it to our list of bugs.
    ### Place Your Code Here ###

def drawBugs():
    # Creates all of the bugs at once.
    bugXCoords = [ 75, 200, 325, 135, 260, 200 ]
    bugYCoords = [ 220, 220, 220, 300, 300, 380 ]
    for index in range(len(bugXCoords)):
        x = bugXCoords[index]
        y = bugYCoords[index]
        drawBug(x, y)

drawBugs()

# hammer
hammer = Group(
    Rect(185, 100, 50, 40, fill='salmon'),
    Oval(185, 120, 20, 40, fill='salmon'),
    Oval(235, 120, 20, 40, fill=rgb(195, 80, 80)),
    Rect(204, 140, 12, 50, fill=gradient('peru', 'burlyWood', start='left'))
    )
hammer.rotateAngle = 35

def checkGameOver():
    # Checks the number of bugs that are up.
    upCount = 0
    for bug in app.bugs:
        if (bug.visible == True):
            upCount += 1

    # If all the bugs are up, the game is over.
    if (upCount == len(app.bugs)):
        Rect(50, 185, 300, 100, fill=gradient('maroon', 'crimson'),
             border='white')
        Label('Game Over', 200, 235, fill='white', size=50, font='monospace',
              bold=True)
        app.stop()

def onMousePress(mouseX, mouseY):
    # Rotates the hammer.
    hammer.rotateAngle = 90

    # Checks if any bug is hit by the hammer.
    for bug in app.bugs:
        if ((bug.visible == True) and (bug.hitsShape(hammer) == True)):
            bug.visible = False
            score.value += 1

def onMouseRelease(mouseX, mouseY):
    # Returns the hammer to the original rotateAngle.
    hammer.rotateAngle = 35

def onMouseMove(mouseX, mouseY):
    hammer.centerX = mouseX
    hammer.centerY = mouseY

def onStep():
    # Choose a random bug from the list to turn visible.
    ### Place Your Code Here ###

    checkGameOver()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.stepsPerSecond = 2
app.bugs = [ ]

# background
Rect(0, 0, 400, 150, fill=gradient('cornSilk', 'ghostWhite', start='top'))
Rect(0, 150, 400, 250, fill=gradient('peru', 'saddleBrown', start='top'))

Label('You have whacked', 150, 60, fill='saddleBrown', size=20, bold=True)
score = Label(0, 255, 60, fill='saddleBrown', size=20, bold=True)
Label('bugs!', 300, 60, fill='saddleBrown', size=20, bold=True)

def drawBug(x, y):
    Oval(x, y, 100, 40,
         fill=gradient('saddleBrown', rgb(120, 15, 10), start='top'))

    bugColor = gradient('greenYellow', rgb(135, 170, 65), start='right')
    bug = Group(
        Rect(x, y, 30, 60, fill=bugColor, align='bottom'),
        Circle(x, y - 60, 15, fill=bugColor),
        Label('O o', x, y - 70, bold=True),
        Label('_', x, y - 65, bold=True),
        Line(x, y, x, y - 60, fill='oliveDrab', lineWidth=30, dashes=(2, 12))
        )

    # Hide the bug and add it to our list of bugs.
    bug.visible = False
    app.bugs.append(bug)

def drawBugs():
    # Creates all of the bugs at once.
    bugXCoords = [ 75, 200, 325, 135, 260, 200 ]
    bugYCoords = [ 220, 220, 220, 300, 300, 380 ]
    for index in range(len(bugXCoords)):
        x = bugXCoords[index]
        y = bugYCoords[index]
        drawBug(x, y)

drawBugs()

# hammer
hammer = Group(
    Rect(185, 100, 50, 40, fill='salmon'),
    Oval(185, 120, 20, 40, fill='salmon'),
    Oval(235, 120, 20, 40, fill=rgb(195, 80, 80)),
    Rect(204, 140, 12, 50, fill=gradient('peru', 'burlyWood', start='left'))
    )
hammer.rotateAngle = 35

def checkGameOver():
    # Checks the number of bugs that are up.
    upCount = 0
    for bug in app.bugs:
        if (bug.visible == True):
            upCount += 1

    # If all the bugs are up, the game is over.
    if (upCount == len(app.bugs)):
        Rect(50, 185, 300, 100, fill=gradient('maroon', 'crimson'),
             border='white')
        Label('Game Over', 200, 235, fill='white', size=50, font='monospace',
              bold=True)
        app.stop()

def onMousePress(mouseX, mouseY):
    # Rotates the hammer.
    hammer.rotateAngle = 90

    # Checks if any bug is hit by the hammer.
    for bug in app.bugs:
        if ((bug.visible == True) and (bug.hitsShape(hammer) == True)):
            bug.visible = False
            score.value += 1

def onMouseRelease(mouseX, mouseY):
    # Returns the hammer to the original rotateAngle.
    hammer.rotateAngle = 35

def onMouseMove(mouseX, mouseY):
    hammer.centerX = mouseX
    hammer.centerY = mouseY

def onStep():
    # Choose a random bug from the list to turn visible.
    bug = choice(app.bugs)
    bug.visible = True

    checkGameOver()
",regular,2
2295,Mosaic maker,10.3.2,"# Initially sets the fill color to white.
app.color = 'white'

colorSwatches = Group()

def drawColorSwatches():
    # Creates a list of colors to pick from.
    colors = [ 'black', 'white', 'navy', 'yellow', 'red' ]
    colorX = 375
    colorY = 40
    colorHeight = 400 / len(colors)

    # Loops through the colors list and adds to the colorSwatches group.
    for i in range(len(colors)):
        colorSwatches.add(
            Circle(colorX, colorY + i * 80, 25, fill=colors[i], border='black',
                   borderWidth=3)
            )

drawColorSwatches()

# Creates a group for the mosaic.
mosaic = Group(
    Rect(150, 0, 200, 200, fill='white', border='black', borderWidth=3),
    Rect(150, 200, 200, 70, fill='white', border='black', borderWidth=3),
    Rect(150, 270, 100, 130, fill='white', border='black', borderWidth=3),
    Rect(250, 270, 100, 130, fill='white', border='black', borderWidth=3),
    Rect(0, 0, 75, 100, fill='white', border='black', borderWidth=3),
    Rect(75, 0, 75, 100, fill='white', border='black', borderWidth=3),
    Rect(0, 100, 50, 50, fill='white', border='black', borderWidth=3),
    Rect(0, 150, 50, 150, fill='white', border='black', borderWidth=3),
    Rect(50, 100, 100, 200, fill='white', border='black', borderWidth=3),
    Rect(0, 300, 150, 40, fill='white', border='black', borderWidth=3),
    Rect(0, 340, 150, 60, fill='white', border='black', borderWidth=3)
    )

def onMousePress(mouseX, mouseY):
    # Check if the click is in a box in the mosaic and fill it.
    ### (HINT: Don't forget to check if hitTest returns None.)
    ### Place Your Code Here ###

    # Check if the click is in a color swatch and change app.color.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Initially sets the fill color to white.
app.color = 'white'

colorSwatches = Group()

def drawColorSwatches():
    # Creates a list of colors to pick from.
    colors = [ 'black', 'white', 'navy', 'yellow', 'red' ]
    colorX = 375
    colorY = 40
    colorHeight = 400 / len(colors)

    # Loops through the colors list and adds to the colorSwatches group.
    for i in range(len(colors)):
        colorSwatches.add(
            Circle(colorX, colorY + i * 80, 25, fill=colors[i], border='black',
                   borderWidth=3)
            )

drawColorSwatches()

# Creates a group for the mosaic.
mosaic = Group(
    Rect(150, 0, 200, 200, fill='white', border='black', borderWidth=3),
    Rect(150, 200, 200, 70, fill='white', border='black', borderWidth=3),
    Rect(150, 270, 100, 130, fill='white', border='black', borderWidth=3),
    Rect(250, 270, 100, 130, fill='white', border='black', borderWidth=3),
    Rect(0, 0, 75, 100, fill='white', border='black', borderWidth=3),
    Rect(75, 0, 75, 100, fill='white', border='black', borderWidth=3),
    Rect(0, 100, 50, 50, fill='white', border='black', borderWidth=3),
    Rect(0, 150, 50, 150, fill='white', border='black', borderWidth=3),
    Rect(50, 100, 100, 200, fill='white', border='black', borderWidth=3),
    Rect(0, 300, 150, 40, fill='white', border='black', borderWidth=3),
    Rect(0, 340, 150, 60, fill='white', border='black', borderWidth=3)
    )

def onMousePress(mouseX, mouseY):
    # Check if the click is in a box in the mosaic and fill it.
    block = mosaic.hitTest(mouseX, mouseY)
    if (block != None):
        block.fill = app.color

    # Check if the click is in a color swatch and change app.color.
    color = colorSwatches.hitTest(mouseX, mouseY)
    if (color != None):
        app.color = color.fill
",regular,1
2296,Snowing,10.3.2,"app.background = gradient('lightCyan', 'skyBlue', start='bottom')
snowflakes = Group()

def onMouseMove(mouseX, mouseY):
    # Check if the mouse is on a snowflake.
    ### (HINT: Check to make sure hitTest doesn't return None.)
    ### Place Your Code Here ###

    # If the mouse is on a snowflake, rotate the flake and increase
    # its opacity.
    ### (HINT: Make sure the opacity never goes above 100!)
    ### Place Your Code Here ###
    pass

def onStep():
    # Makes at most 70 snowflakes.
    if (len(snowflakes.children) < 70):
        # Creates a new flake with a random position, dx, and dy.
        snowflake = Label('*', randrange(0, 400), 0, fill='white', size=70,
                          opacity=30, bold=True)
        snowflake.dx = randrange(-1, 2)
        snowflake.dy = randrange(5, 8)
        snowflakes.add(snowflake)

    # Moves all the snowflakes and removes the ones that are off the canvas.
    for snowflake in snowflakes.children:
        snowflake.centerX += snowflake.dx
        snowflake.centerY += snowflake.dy
        if ((snowflake.right < 0) or (snowflake.top > 400) or
            (snowflake.left > 400)):
            snowflakes.remove(snowflake)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('lightCyan', 'skyBlue', start='bottom')
snowflakes = Group()

def onMouseMove(mouseX, mouseY):
    # Check if the mouse is on a snowflake.
    snowflake = snowflakes.hitTest(mouseX, mouseY)
    if (snowflake != None):
        # If the mouse is on a snowflake, rotate the flake and increase
        # its opacity.
        snowflake.rotateAngle += 10
        if (snowflake.opacity <= 90):
            snowflake.opacity += 10

def onStep():
    # Makes at most 70 snowflakes.
    if (len(snowflakes.children) < 70):
        # Creates a new flake with a random position, dx, and dy.
        snowflake = Label('*', randrange(0, 400), 0, fill='white', size=70,
                          opacity=30, bold=True)
        snowflake.dx = randrange(-1, 2)
        snowflake.dy = randrange(5, 8)
        snowflakes.add(snowflake)

    # Moves all the snowflakes and removes the ones that are off the canvas.
    for snowflake in snowflakes.children:
        snowflake.centerX += snowflake.dx
        snowflake.centerY += snowflake.dy
        if ((snowflake.right < 0) or (snowflake.top > 400) or
            (snowflake.left > 400)):
            snowflakes.remove(snowflake)
",regular,1
2298,Pacman lite,10.3.2,"app.background = 'black'

# maze
Rect(5, 20, 390, 6, fill=None, border='royalBlue')
Rect(5, 380, 390, 6, fill=None, border='royalBlue')
Rect(5, 100, 155, 6, fill=None, border='royalBlue')
Rect(240, 100, 155, 6, fill=None, border='royalBlue')
Rect(154, 108, 6, 50, fill=None, border='royalBlue')
Rect(240, 108, 6, 50, fill=None, border='royalBlue')
Rect(5, 160, 155, 6, fill=None, border='royalBlue')
Rect(240, 160, 155, 6, fill=None, border='royalBlue')
Rect(5, 240, 35, 6, fill=None, border='royalBlue')
Rect(120, 240, 275, 6, fill=None, border='royalBlue')
Rect(34, 248, 6, 50, fill=None, border='royalBlue')
Rect(120, 248, 6, 50, fill=None, border='royalBlue')
Rect(5, 300, 35, 6, fill=None, border='royalBlue')
Rect(120, 300, 275, 6, fill=None, border='royalBlue')
Rect(240, 308, 6, 70, fill=None, border='royalBlue')

path = Group(
    Line(-30, 63, 430, 63, fill='royalBlue', opacity=70),
    Line(200, 63, 200, 200, fill='royalBlue', opacity=70),
    Line(-30, 200, 430, 200, fill='royalBlue', opacity=70),
    Line(80, 200, 80, 343, fill='royalBlue', opacity=70),
    Line(-30, 343, 215, 343, fill='royalBlue', opacity=70),
    Line(270, 343, 430, 343, fill='royalBlue', opacity=70),
    )

def drawDots(y):
    for x in range(20, 400, 60):
        # If the dot is placed on a path, draws it.
        line = path.hitTest(x, y)
        if (line != None):
            dots.add(
                Circle(x, y, 5, fill='lightSalmon')
                )

# small dots
dots = Group()
drawDots(63)
drawDots(134)
drawDots(200)
drawDots(273)
drawDots(343)
powerDot = Circle(270, 343, 10, fill='lightSalmon')

# ghost
pinky = Group(
    Circle(350, 200, 25, fill='magenta'),
    Rect(325, 200, 50, 25, fill='magenta'),
    Circle(331, 225, 6, fill='magenta'),
    Circle(344, 225, 6, fill='magenta'),
    Circle(356, 225, 6, fill='magenta'),
    Circle(369, 225, 6, fill='magenta'),
    Circle(335, 190, 6, fill='white'),
    Circle(355, 190, 6, fill='white'),
    Circle(333, 190, 3, fill='royalBlue'),
    Circle(353, 190, 3, fill='royalBlue')
    )
pinky.dx = 2
pinky.color = 'magenta'

pacman = Arc(100, 200, 50, 50, 120, 300, fill='yellow')
pacman.dx = 2
pacman.dy = 0
pacman.dS = 10

def movePacman():
    # Changes pacman's start and sweep angles to open and close its mouth.
    pacman.startAngle -= pacman.dS // 2
    pacman.sweepAngle += pacman.dS
    if (pacman.sweepAngle <= 300):
        pacman.dS *= -1
    elif (pacman.sweepAngle >= 360):
        pacman.dS *= -1

    # Check to see if the next location pacman's center will move to is on the path.
    # If it is, move pacman to that spot.
    ### Place Your Code Here ###

    # Wraparound.
    if (pacman.left > 400):
        pacman.right = 0
    elif (pacman.right < 0):
        pacman.left = 400

def onKeyHold(keys):
    # Checks whether moving two pixels in each direction will be on the path.
    lineLeft = path.hitTest(pacman.centerX - 2, pacman.centerY)
    lineRight = path.hitTest(pacman.centerX + 2, pacman.centerY)
    lineUp = path.hitTest(pacman.centerX, pacman.centerY - 2)
    lineDown = path.hitTest(pacman.centerX, pacman.centerY + 2)

    # Changes direction with the arrow keys.
    if (('left' in keys) and (lineLeft != None)):
        pacman.dx = -2
        pacman.dy = 0
        pacman.rotateAngle = 180
    elif (('right' in keys) and (lineRight != None)):
        pacman.dx = 2
        pacman.dy = 0
        pacman.rotateAngle = 0
    elif (('up' in keys) and (lineUp != None)):
        pacman.dx = 0
        pacman.dy = -2
        pacman.rotateAngle = 270
    elif (('down' in keys) and (lineDown != None)):
        pacman.dx = 0
        pacman.dy = 2
        pacman.rotateAngle = 90

def onStep():
    # Moves pacman.
    movePacman()

    # Check to see if pacman's center is hitting a dot and if so, remove it.
    ### Place Your Code Here ###

    # Otherwise, check if any part of pacman is hitting the powerDot and set it
    # to invisible. Then, change the ghost color.
    ### (HINT: Change both the fill and the color custom property!)
    ### Place Your Code Here ###

    # Moves the ghost with bouncing.
    pinky.centerX += pinky.dx
    if ((pinky.centerX <= 25) or (pinky.centerX >= 375)):
        pinky.dx *= -1

    # If pacman hits the ghost when it is pink, the player loses.
    # Otherwise, the ghost's body disappears.
    if (pacman.hitsShape(pinky) == True):
        if (pinky.color == 'royalBlue'):
            pinky.visible = False
        else:
            Label('Ooops!', 265, 273, fill='white', size=24)
            app.stop()

    # Checks if the player won.
    if ((len(dots.children) == 0) and (pinky.visible == False)):
        Label('You Won!', 265, 273, fill='white', size=24)
        app.stop()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# maze
Rect(5, 20, 390, 6, fill=None, border='royalBlue')
Rect(5, 380, 390, 6, fill=None, border='royalBlue')
Rect(5, 100, 155, 6, fill=None, border='royalBlue')
Rect(240, 100, 155, 6, fill=None, border='royalBlue')
Rect(154, 108, 6, 50, fill=None, border='royalBlue')
Rect(240, 108, 6, 50, fill=None, border='royalBlue')
Rect(5, 160, 155, 6, fill=None, border='royalBlue')
Rect(240, 160, 155, 6, fill=None, border='royalBlue')
Rect(5, 240, 35, 6, fill=None, border='royalBlue')
Rect(120, 240, 275, 6, fill=None, border='royalBlue')
Rect(34, 248, 6, 50, fill=None, border='royalBlue')
Rect(120, 248, 6, 50, fill=None, border='royalBlue')
Rect(5, 300, 35, 6, fill=None, border='royalBlue')
Rect(120, 300, 275, 6, fill=None, border='royalBlue')
Rect(240, 308, 6, 70, fill=None, border='royalBlue')

path = Group(
    Line(-30, 63, 430, 63, fill='royalBlue', opacity=70),
    Line(200, 63, 200, 200, fill='royalBlue', opacity=70),
    Line(-30, 200, 430, 200, fill='royalBlue', opacity=70),
    Line(80, 200, 80, 343, fill='royalBlue', opacity=70),
    Line(-30, 343, 215, 343, fill='royalBlue', opacity=70),
    Line(270, 343, 430, 343, fill='royalBlue', opacity=70),
    )

def drawDots(y):
    for x in range(20, 400, 60):
        # If the dot is placed on a path, draws it.
        line = path.hitTest(x, y)
        if (line != None):
            dots.add(
                Circle(x, y, 5, fill='lightSalmon')
                )

# small dots
dots = Group()
drawDots(63)
drawDots(134)
drawDots(200)
drawDots(273)
drawDots(343)
powerDot = Circle(270, 343, 10, fill='lightSalmon')

# ghost
pinky = Group(
    Circle(350, 200, 25, fill='magenta'),
    Rect(325, 200, 50, 25, fill='magenta'),
    Circle(331, 225, 6, fill='magenta'),
    Circle(344, 225, 6, fill='magenta'),
    Circle(356, 225, 6, fill='magenta'),
    Circle(369, 225, 6, fill='magenta'),
    Circle(335, 190, 6, fill='white'),
    Circle(355, 190, 6, fill='white'),
    Circle(333, 190, 3, fill='royalBlue'),
    Circle(353, 190, 3, fill='royalBlue')
    )
pinky.dx = 2
pinky.color = 'magenta'

pacman = Arc(100, 200, 50, 50, 120, 300, fill='yellow')
pacman.dx = 2
pacman.dy = 0
pacman.dS = 10

def movePacman():
    # Changes pacman's start and sweep angles to open and close its mouth.
    pacman.startAngle -= pacman.dS // 2
    pacman.sweepAngle += pacman.dS
    if (pacman.sweepAngle <= 300):
        pacman.dS *= -1
    elif (pacman.sweepAngle >= 360):
        pacman.dS *= -1

    # Check to see if the next location pacman's center will move to is on the path.
    # If it is, move pacman to that spot.
    newX = pacman.centerX + pacman.dx
    newY = pacman.centerY + pacman.dy
    if (path.hitTest(newX, newY) != None):
        pacman.centerX = newX
        pacman.centerY = newY

    # Wraparound.
    if (pacman.left > 400):
        pacman.right = 0
    elif (pacman.right < 0):
        pacman.left = 400

def onKeyHold(keys):
    # Checks whether moving two pixels in each direction will be on the path.
    lineLeft = path.hitTest(pacman.centerX - 2, pacman.centerY)
    lineRight = path.hitTest(pacman.centerX + 2, pacman.centerY)
    lineUp = path.hitTest(pacman.centerX, pacman.centerY - 2)
    lineDown = path.hitTest(pacman.centerX, pacman.centerY + 2)

    # Changes direction with the arrow keys.
    if (('left' in keys) and (lineLeft != None)):
        pacman.dx = -2
        pacman.dy = 0
        pacman.rotateAngle = 180
    elif (('right' in keys) and (lineRight != None)):
        pacman.dx = 2
        pacman.dy = 0
        pacman.rotateAngle = 0
    elif (('up' in keys) and (lineUp != None)):
        pacman.dx = 0
        pacman.dy = -2
        pacman.rotateAngle = 270
    elif (('down' in keys) and (lineDown != None)):
        pacman.dx = 0
        pacman.dy = 2
        pacman.rotateAngle = 90

def onStep():
    # Moves pacman.
    movePacman()

    # Check to see if pacman's center is hitting a dot and if so, remove it.
    dot = dots.hitTest(pacman.centerX, pacman.centerY)
    if (dot != None):
        dots.remove(dot)

    # Otherwise, check if any part of pacman is hitting the powerDot and set it
    # to invisible. Then, change the ghost color.
    if (pacman.hitsShape(powerDot) == True):
        powerDot.visible = False
        pinky.fill = 'royalBlue'
        pinky.color = 'royalBlue'

    # Moves the ghost with bouncing.
    pinky.centerX += pinky.dx
    if ((pinky.centerX <= 25) or (pinky.centerX >= 375)):
        pinky.dx *= -1

    # If pacman hits the ghost when it is pink, the player loses.
    # Otherwise, the ghost's body disappears.
    if (pacman.hitsShape(pinky) == True):
        if (pinky.color == 'royalBlue'):
            pinky.visible = False
        else:
            Label('Ooops!', 265, 273, fill='white', size=24)
            app.stop()

    # Checks if the player won.
    if ((len(dots.children) == 0) and (pinky.visible == False)):
        Label('You Won!', 265, 273, fill='white', size=24)
        app.stop()
",regular,3
2297,Crazy intersection,10.3.2,"app.background = 'mediumSeaGreen'
app.stepsTillNextCar = 0

# roads
Rect(150, 0, 100, 400, fill='dimGray')
Rect(0, 150, 400, 100, fill='dimGray')
Rect(-100, 150, 600, 100, fill='dimGray', rotateAngle=45)
Rect(-100, 150, 600, 100, fill='dimGray', rotateAngle=315)

lines = Group()
cars = Group()

def makeLines():
    # Adds four dashed lines.
    lines.add(
        Line(200, 0, 200, 400, fill='fireBrick', lineWidth=8, dashes=True),
        Line(0, 200, 400, 200, fill='gold', lineWidth=8, dashes=True),
        Line(0, 0, 400, 400, fill='mediumSeaGreen', lineWidth=8, dashes=True),
        Line(400, 0, 0, 400, fill='dodgerBlue', lineWidth=8, dashes=True)
        )

    # Sets the originalFill of each line so we can reset it later.
    originalFills = [ 'fireBrick', 'gold', 'mediumSeaGreen', 'dodgerBlue' ]
    for i in range(len(lines.children)):
        lines.children[i].originalFill = originalFills[i]

makeLines()

def drawCar(x, y, angle, color):
    car = Group(
        Rect(200, 200, 30, 60, fill=color, align='center'),
        Rect(200, 185, 34, 3, fill=color, align='center'),
        Rect(188, 172, 5, 4, fill='yellow', align='center'),
        Rect(213, 172, 5, 4, fill='yellow', align='center'),
        Rect(200, 220, 20, 8, fill='gray', align='center'),
        Rect(200, 190, 20, 12, fill='gray', align='center')
        )
    car.rotateAngle = angle
    car.centerX = x
    car.centerY = y
    cars.add(car)

def onMouseMove(mouseX, mouseY):
    # Resets each line back to its original color.
    for line in lines.children:
        line.fill = line.originalFill

    # If the mouse is on a line, set its fill to white.
    ### Place Your Code Here ###
    pass

def onStep():
    app.stepsTillNextCar += 1

    # Every 30 steps, tries to create a new car in the correct road.
    if (app.stepsTillNextCar >= 30):
        app.stepsTillNextCar = 0
        for line in lines:
            # If any of the lines are being hovered over, draw a new car.
            if (line.fill == 'white'):
                if (line.originalFill == 'fireBrick'):
                    drawCar(175, -30, 180, 'fireBrick')
                elif (line.originalFill == 'gold'):
                    drawCar(-30, 225, 90, 'gold')
                elif (line.originalFill == 'mediumSeaGreen'):
                    drawCar(-20, 15, 135, 'mediumSeaGreen')
                else:
                    drawCar(15, 420, 45, 'dodgerBlue')

    for car in cars:
        # Move each car 5 pixels in the direction that it is facing.
        ### Place Your Code Here ###

        # Removes any cars that leave the canvas.
        if ((car.left >= 400) or (car.top >= 400)):
            cars.remove(car)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'mediumSeaGreen'
app.stepsTillNextCar = 0

# roads
Rect(150, 0, 100, 400, fill='dimGray')
Rect(0, 150, 400, 100, fill='dimGray')
Rect(-100, 150, 600, 100, fill='dimGray', rotateAngle=45)
Rect(-100, 150, 600, 100, fill='dimGray', rotateAngle=315)

lines = Group()
cars = Group()

def makeLines():
    # Adds four dashed lines.
    lines.add(
        Line(200, 0, 200, 400, fill='fireBrick', lineWidth=8, dashes=True),
        Line(0, 200, 400, 200, fill='gold', lineWidth=8, dashes=True),
        Line(0, 0, 400, 400, fill='mediumSeaGreen', lineWidth=8, dashes=True),
        Line(400, 0, 0, 400, fill='dodgerBlue', lineWidth=8, dashes=True)
        )

    # Sets the originalFill of each line so we can reset it later.
    originalFills = [ 'fireBrick', 'gold', 'mediumSeaGreen', 'dodgerBlue' ]
    for i in range(len(lines.children)):
        lines.children[i].originalFill = originalFills[i]

makeLines()

def drawCar(x, y, angle, color):
    car = Group(
        Rect(200, 200, 30, 60, fill=color, align='center'),
        Rect(200, 185, 34, 3, fill=color, align='center'),
        Rect(188, 172, 5, 4, fill='yellow', align='center'),
        Rect(213, 172, 5, 4, fill='yellow', align='center'),
        Rect(200, 220, 20, 8, fill='gray', align='center'),
        Rect(200, 190, 20, 12, fill='gray', align='center')
        )
    car.rotateAngle = angle
    car.centerX = x
    car.centerY = y
    cars.add(car)

def onMouseMove(mouseX, mouseY):
    # Resets each line back to its original color.
    for line in lines.children:
        line.fill = line.originalFill

    # If the mouse is on a line, set its fill to white.
    line = lines.hitTest(mouseX, mouseY)
    if (line != None):
        line.fill = 'white'

def onStep():
    app.stepsTillNextCar += 1

    # Every 30 steps, tries to create a new car in the correct road.
    if (app.stepsTillNextCar >= 30):
        app.stepsTillNextCar = 0
        for line in lines:
            # If any of the lines are being hovered over, draw a new car.
            if (line.fill == 'white'):
                if (line.originalFill == 'fireBrick'):
                    drawCar(175, -30, 180, 'fireBrick')
                elif (line.originalFill == 'gold'):
                    drawCar(-30, 225, 90, 'gold')
                elif (line.originalFill == 'mediumSeaGreen'):
                    drawCar(-20, 15, 135, 'mediumSeaGreen')
                else:
                    drawCar(15, 420, 45, 'dodgerBlue')

    for car in cars:
        # Move each car 5 pixels in the direction that it is facing.
        newX, newY = getPointInDir(car.centerX, car.centerY, car.rotateAngle, 5)
        car.centerX = newX
        car.centerY = newY

        # Removes any cars that leave the canvas.
        if ((car.left >= 400) or (car.top >= 400)):
            cars.remove(car)
",regular,2
2299,Bouncing bubbles,10.3.2,"app.background = 'black'
app.bubbleColors = [ 'mediumPurple', 'orchid', 'powderBlue', 'lightCoral',
                     'lightSalmon' ]

bubbles = Group()

def createBubbles():
    for i in range(10):
        bubbleColor = choice(app.bubbleColors)
        bubbleX = randrange(50, 350)
        bubbleY = randrange(50, 350)

        bubble = Group(
            Circle(bubbleX, bubbleY, 30, fill=None, border=bubbleColor),
            Oval(bubbleX - 18, bubbleY - 18, 4, 12, fill='white', rotateAngle=45)
            )
        bubble.dx = randrange(-3, 4)
        bubble.dy = randrange(2, 5)
        bubbles.add(bubble)

createBubbles()

def moveBubbles():
    # Moves each of the bubbles.
    for bubble in bubbles.children:
        bubble.centerX += bubble.dx
        bubble.centerY += bubble.dy

def checkWallCollision():
    # Checks if any of the bubbles collide with a wall and bounce off.
    for bubble in bubbles.children:
        if ((bubble.left < 0) or (bubble.right > 400)):
            bubble.dx = -bubble.dx
            bubble.centerX += bubble.dx
        if ((bubble.top < 0) or (bubble.bottom > 400)):
            bubble.dy = -bubble.dy
            bubble.centerY += bubble.dy

def onMouseMove(mouseX, mouseY):
    # Check to see if the mouse is on a bubble.
    ### Place Your Code Here ###

    # Reset the dx and dy of the bubble based on where the mouse is
    # hitting the bubble.
    ### (HINT: If the mouse is left of the bubble's center, set dx to 3.
    #          Otherwise, set it to -3. Similarly for dy if the mouse is above
    #          or below the bubble's center.)
    ### Place Your Code Here ###
    pass

def onStep():
    moveBubbles()
    checkWallCollision()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.bubbleColors = [ 'mediumPurple', 'orchid', 'powderBlue', 'lightCoral',
                     'lightSalmon' ]

bubbles = Group()

def createBubbles():
    for i in range(10):
        bubbleColor = choice(app.bubbleColors)
        bubbleX = randrange(50, 350)
        bubbleY = randrange(50, 350)

        bubble = Group(
            Circle(bubbleX, bubbleY, 30, fill=None, border=bubbleColor),
            Oval(bubbleX - 18, bubbleY - 18, 4, 12, fill='white', rotateAngle=45)
            )
        bubble.dx = randrange(-3, 4)
        bubble.dy = randrange(2, 5)
        bubbles.add(bubble)

createBubbles()

def moveBubbles():
    # Moves each of the bubbles.
    for bubble in bubbles.children:
        bubble.centerX += bubble.dx
        bubble.centerY += bubble.dy

def checkWallCollision():
    # Checks if any of the bubbles collide with a wall and bounce off.
    for bubble in bubbles.children:
        if ((bubble.left < 0) or (bubble.right > 400)):
            bubble.dx = -bubble.dx
            bubble.centerX += bubble.dx
        if ((bubble.top < 0) or (bubble.bottom > 400)):
            bubble.dy = -bubble.dy
            bubble.centerY += bubble.dy

def onMouseMove(mouseX, mouseY):
    # Check to see if the mouse is on a bubble.
    bubble = bubbles.hitTest(mouseX, mouseY)
    if (bubble != None):
        # Reset the dx and dy of the bubble based on where the mouse is
        # hitting the bubble.
        if (mouseX < bubble.centerX):
            bubble.dx = 3
        else:
            bubble.dx = -3

        if (mouseY < bubble.centerY):
            bubble.dy = 3
        else:
            bubble.dy = -3

def onStep():
    moveBubbles()
    checkWallCollision()
",regular,2
2300,Fortune teller,10.3.4,"app.background = gradient('mediumPurple', 'black')
app.stepsPerSecond = 3
app.index = 0

# crystal ball
glass = Circle(200, 175, 125, fill='lightBlue')
crystalBall = Group(
    Polygon(120 ,315, 280, 315, 300, 350, 100, 350, fill='darkGoldenrod'),
    Oval(200, 350, 200, 50, fill='darkGoldenrod'),
    Oval(200, 315, 160, 40, fill='goldenrod'),
    glass,
    Polygon(100, 250, 200, 295, 300, 250, 310, 270, 200, 315, 90, 270,
            fill='darkGoldenrod'),
    Oval(200, 312, 70, 18, fill='darkGoldenrod'),
    glass,
    Oval(255, 100, 30, 95, fill='white', rotateAngle=-50, opacity=50)
    )

def getFortune(index):
    fortunes = [ 'A good suprise is in your future :)',
                 'You will stain your shirt :(',
                 'Your next dream will come true :)',
                 'You will drop your phone :(' ]

    # Return the fortune at the index.
    ### Place Your Code Here ###
    pass

def onMousePress(mouseX, mouseY):
    # If the ball is clicked on, display the appropriate fortune.
    if ((crystalBall.contains(mouseX, mouseY) == True) and (app.paused == False)):
        ### Fix Your Code Here ###
        fortune = 'call the function here!'

        app.paused = True

def onStep():
    colors = [ 'lightBlue', rgb(235, 225, 180), 'thistle', rgb(180, 225, 180) ]

    # Cycles through the colors with wraparound.
    app.index += 1
    if (app.index == len(colors)):
        app.index = 0

    glass.fill = colors[app.index]
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('mediumPurple', 'black')
app.stepsPerSecond = 3
app.index = 0

# crystal ball
glass = Circle(200, 175, 125, fill='lightBlue')
crystalBall = Group(
    Polygon(120 ,315, 280, 315, 300, 350, 100, 350, fill='darkGoldenrod'),
    Oval(200, 350, 200, 50, fill='darkGoldenrod'),
    Oval(200, 315, 160, 40, fill='goldenrod'),
    glass,
    Polygon(100, 250, 200, 295, 300, 250, 310, 270, 200, 315, 90, 270,
            fill='darkGoldenrod'),
    Oval(200, 312, 70, 18, fill='darkGoldenrod'),
    glass,
    Oval(255, 100, 30, 95, fill='white', rotateAngle=-50, opacity=50)
    )

def getFortune(index):
    fortunes = [ 'A good suprise is in your future :)',
                 'You will stain your shirt :(',
                 'Your next dream will come true :)',
                 'You will drop your phone :(' ]

    # Return the fortune at the index.
    return fortunes[index]

def onMousePress(mouseX, mouseY):
    # If the ball is clicked on, display the appropriate fortune.
    if ((crystalBall.contains(mouseX, mouseY) == True) and (app.paused == False)):
        fortune = getFortune(app.index)
        Label(fortune, 200, 180, fill='darkSlateBlue', size=14, bold=True)

        app.paused = True

def onStep():
    colors = [ 'lightBlue', rgb(235, 225, 180), 'thistle', rgb(180, 225, 180) ]

    # Cycles through the colors with wraparound.
    app.index += 1
    if (app.index == len(colors)):
        app.index = 0

    glass.fill = colors[app.index]
",regular,1
2301,Crowd noise,10.3.4,"app.background = 'deepSkyBlue'
app.stepsPerSecond = 4

# This is used to store the input sentence.
app.sentence = ''
app.colors = [ 'crimson', 'gold', 'cornflowerBlue', 'seaGreen' ]

# speech bubble
Polygon(0, 0, 400, 0, 400, 175, 300, 175, 315, 195, 270, 175, 130, 175, 85, 195,
        100, 175, 0, 175, fill='aliceBlue', border='black')

app.words = [ ]

def createPeople():
    headColors = [ 'saddleBrown', 'peachPuff', 'burlywood', 'tan' ]

    # Draws a crowd of people of random colors.
    for row in range(6):
        for col in range(9):
            color = choice(app.colors)
            headColor = choice(headColors)

            if (row % 2 == 0):
                x = 50 * col + 25
            else:
                x = 50 * col
            y = 30 * row + 280

            Circle(x, y - 65, 15, fill=headColor, border='black')
            Arc(x, y, 50, 100, 270, 180, fill=color, border='black')

createPeople()

# speech bubble
Line(0, 175, 100, 175)
Line(100, 175, 85, 195)
Line(85, 195, 130, 175)
Line(130, 175, 270, 175)
Line(300, 175, 315, 195)
Line(315, 195, 270, 175)
Line(300, 175, 400, 175)

def onKeyPress(key):
    # Gets a new sentence.
    if (key == 'space'):
        app.sentence = app.getTextInput('Enter a sentence')

def getJumbledLetters(sentence):
    # Gets a random step between 1 and half the length of the text.
    letters = ''
    halfLength = (len(sentence) // 2) + 1
    if (halfLength > 1):
        step = randrange(1, halfLength)
    else:
        step = 1

    # Create a jumbled version of the input sentece by looping over the sentence
    # using step to pick the letters. Then return the letters variable.
    ### Place Your Code Here ###
    pass

def onStep():
    # Removes a word if there are too many.
    if (len(app.words) >= 10):
        word = app.words.pop(0)
        word.visible = False


    # Create a string of jumbled letters and set it to the letters variable.
    ### Fix Your Code Here ###
    letters = 'a'

    # Draws a new random label with the letters and add it to the words group.
    app.words.append(
        Label(letters.upper(), randrange(50, 351), randrange(50, 151),
              fill=choice(app.colors), size=randrange(14, 40),
              rotateAngle=randrange(0, 360), bold=True)
        )
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'deepSkyBlue'
app.stepsPerSecond = 4

# This is used to store the input sentence.
app.sentence = ''
app.colors = [ 'crimson', 'gold', 'cornflowerBlue', 'seaGreen' ]

# speech bubble
Polygon(0, 0, 400, 0, 400, 175, 300, 175, 315, 195, 270, 175, 130, 175, 85, 195,
        100, 175, 0, 175, fill='aliceBlue', border='black')

app.words = [ ]

def createPeople():
    headColors = [ 'saddleBrown', 'peachPuff', 'burlywood', 'tan' ]

    # Draws a crowd of people of random colors.
    for row in range(6):
        for col in range(9):
            color = choice(app.colors)
            headColor = choice(headColors)

            if (row % 2 == 0):
                x = 50 * col + 25
            else:
                x = 50 * col
            y = 30 * row + 280

            Circle(x, y - 65, 15, fill=headColor, border='black')
            Arc(x, y, 50, 100, 270, 180, fill=color, border='black')

createPeople()

# speech bubble
Line(0, 175, 100, 175)
Line(100, 175, 85, 195)
Line(85, 195, 130, 175)
Line(130, 175, 270, 175)
Line(300, 175, 315, 195)
Line(315, 195, 270, 175)
Line(300, 175, 400, 175)

def onKeyPress(key):
    # Gets a new sentence.
    if (key == 'space'):
        app.sentence = app.getTextInput('Enter a sentence')

def getJumbledLetters(sentence):
    # Gets a random step between 1 and half the length of the text.
    letters = ''
    halfLength = (len(sentence) // 2) + 1
    if (halfLength > 1):
        step = randrange(1, halfLength)
    else:
        step = 1

    # Create a jumbled version of the input sentece by looping over the sentence
    # using step to pick the letters. Then return the letters variable.
    for i in range(0, len(sentence), step):
        letters += sentence[i]

    return letters

def onStep():
    # Removes a word if there are too many.
    if (len(app.words) >= 10):
        word = app.words.pop(0)
        word.visible = False


    # Create a string of jumbled letters and set it to the letters variable.
    letters = getJumbledLetters(app.sentence)

    # Draws a new random label with the letters and add it to the words group.
    app.words.append(
        Label(letters.upper(), randrange(50, 351), randrange(50, 151),
              fill=choice(app.colors), size=randrange(14, 40),
              rotateAngle=randrange(0, 360), bold=True)
        )
",regular,1
2302,Cool clock,10.3.4,"app.background = 'whiteSmoke'

app.expectedTime = 5
app.actualTime = 0

# clock background
Label('How good are you at guessing time?', 200, 35, size=20, bold=True)
bottomText = Label('Press space after ' + str(app.expectedTime) + ' s',
                   200, 370, size=18)
Star(200, 200, 140, 4, fill='maroon')
Star(200, 200, 130, 8, fill='goldenrod', roundness=30, rotateAngle=23)

# clock body
clock = Group(
    Circle(200, 200, 100, fill=gradient('peru', 'saddleBrown'),
           border='saddleBrown'),
    Circle(200, 200, 90, fill='white', border='black', borderWidth=5),
    Circle(200, 200, 70, fill='cornSilk'),
    Circle(200, 200, 3),
    Line(200, 200, 200, 150, arrowEnd=True)
    )

def drawTickMarks():
    # Draws the tick marks around the clock.
    for index in range(12):
        angle = 30 * (index + 1)
        x1, y1 = getPointInDir(200, 200, angle, 75)
        x2, y2 = getPointInDir(200, 200, angle, 85)
        Line(x1, y1, x2, y2)

drawTickMarks()

def calculateDifference():
    # Divide app.actualTime by the stepsPerSecond to get the time in seconds.
    # Subtract the actual time from the expected time to get the difference.
    ### (HINT: Use abs to get a positive value for the difference.)
    ### Place Your Code Here ###
    pass

def onKeyPress(key):
    if (key == 'space'):
        # Get the difference between the actual and expected times.
        ### Fix Your Code Here ###
        difference = 0

        if (difference == 0):
            bottomText.value = 'WOW! Right on'
        else:
            bottomText.value = 'You were off by ' + str(difference) + ' s'

        app.stop()

def onStep():
    # Moves the hand of the clock and adds to the time.
    clock.rotateAngle += 2
    app.actualTime += 1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'whiteSmoke'

app.expectedTime = 5
app.actualTime = 0

# clock background
Label('How good are you at guessing time?', 200, 35, size=20, bold=True)
bottomText = Label('Press space after ' + str(app.expectedTime) + ' s',
                   200, 370, size=18)
Star(200, 200, 140, 4, fill='maroon')
Star(200, 200, 130, 8, fill='goldenrod', roundness=30, rotateAngle=23)

# clock body
clock = Group(
    Circle(200, 200, 100, fill=gradient('peru', 'saddleBrown'),
           border='saddleBrown'),
    Circle(200, 200, 90, fill='white', border='black', borderWidth=5),
    Circle(200, 200, 70, fill='cornSilk'),
    Circle(200, 200, 3),
    Line(200, 200, 200, 150, arrowEnd=True)
    )

def drawTickMarks():
    # Draws the tick marks around the clock.
    for index in range(12):
        angle = 30 * (index + 1)
        x1, y1 = getPointInDir(200, 200, angle, 75)
        x2, y2 = getPointInDir(200, 200, angle, 85)
        Line(x1, y1, x2, y2)

drawTickMarks()

def calculateDifference():
    # Divide app.actualTime by the stepsPerSecond to get the time in seconds.
    # Subtract the actual time from the expected time to get the difference.
    app.actualTime = app.actualTime // app.stepsPerSecond
    return abs(app.expectedTime - app.actualTime)

def onKeyPress(key):
    if (key == 'space'):
        # Get the difference between the actual and expected times.
        difference = calculateDifference()

        if (difference == 0):
            bottomText.value = 'WOW! Right on'
        else:
            bottomText.value = 'You were off by ' + str(difference) + ' s'

        app.stop()

def onStep():
    # Moves the hand of the clock and adds to the time.
    clock.rotateAngle += 2
    app.actualTime += 1
",regular,2
2309,Undo and redo,10.4,"app.background = 'black'
app.stepsPerSecond = 20

Label('Click on the canvas to add stars.', 200, 15, fill='white', size=18)
Label('Press left arrow key to undo.', 200, 35, fill='white', size=18)
Label('Press right arrow key to redo.', 200, 55, fill='white', size=18)

app.stars = [ ]
app.removedStars = [ ]

def undo():
    # Pop the last star from app.stars and add it to app.removedStars.
    # Also make it invisible.
    ### (HINT: Make sure that there is a star to remove!)
    ### Place Your Code Here ###
    pass

def redo():
    # Pop the last star from app.removedStars and add it to app.stars.
    ### (HINT: Make sure that there is a star to add back!)
    ### Place Your Code Here ###
    pass

def onMousePress(mouseX, mouseY):
    # Adds a star with a random color and radius at the mouse press location.
    radius = randrange(25, 45)
    colors = [ 'fuchsia', 'yellow', 'aqua', 'lawnGreen', 'ghostWhite' ]
    color = choice(colors)
    app.stars.append(
        Star(mouseX, mouseY, radius, 5, fill=None, border=color, borderWidth=4,
             roundness=60)
        )

def onKeyPress(key):
    # Undo when left key is pressed. Redo when right key is pressed.
    if (key == 'left'):
        undo()
    elif (key == 'right'):
        redo()

def onStep():
    for star in app.stars:
        star.rotateAngle += 5
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 20

Label('Click on the canvas to add stars.', 200, 15, fill='white', size=18)
Label('Press left arrow key to undo.', 200, 35, fill='white', size=18)
Label('Press right arrow key to redo.', 200, 55, fill='white', size=18)

app.stars = [ ]
app.removedStars = [ ]

def undo():
    # Pop the last star from app.stars and add it to app.removedStars.
    # Also make it invisible.
    if (len(app.stars) > 0):
        lastStar = app.stars.pop()
        lastStar.visible = False
        app.removedStars.append(lastStar)

def redo():
    # Pop the last star from app.removedStars and add it to app.stars.
    if (len(app.removedStars) > 0):
        lastStar = app.removedStars.pop()
        lastStar.visible = True
        app.stars.append(lastStar)

def onMousePress(mouseX, mouseY):
    # Adds a star with a random color and radius at the mouse press location.
    radius = randrange(25, 45)
    colors = [ 'fuchsia', 'yellow', 'aqua', 'lawnGreen', 'ghostWhite' ]
    color = choice(colors)
    app.stars.append(
        Star(mouseX, mouseY, radius, 5, fill=None, border=color, borderWidth=4,
             roundness=60)
        )

def onKeyPress(key):
    # Undo when left key is pressed. Redo when right key is pressed.
    if (key == 'left'):
        undo()
    elif (key == 'right'):
        redo()

def onStep():
    for star in app.stars:
        star.rotateAngle += 5
",regular,2
2303,Shape invaders,10.4,"app.background = 'black'
app.index = 0

# Earth
Oval(200, 400, 600, 100, fill='lightSkyBlue', border='mediumSeaGreen',
     borderWidth=8)
Polygon(-50, 375, 40, 390, 140, 365, 205, 380, 290, 365, 355, 360,
        400, 365, 245, 355, 145, 355, fill='mediumSeaGreen')

# Draws stars in the background.
for i in range(100):
    Circle(randrange(0, 400), randrange(0, 350), 1, fill='white')

# Shapes along the bottom.
app.shapes = [ Circle(70, 310, 30, fill='tomato', border='lime'),
               RegularPolygon(200, 310, 35, 3, fill='darkGray', border='gray'),
               RegularPolygon(330, 310, 35, 4, fill='orange', border='gray') ]

# Shapes that fall from the top.
app.fallingShapes = [ RegularPolygon(70, 0, 35, 3, fill='darkGray', border='gray'),
                      RegularPolygon(200, 0, 35, 4, fill='orange', border='gray'),
                      Circle(330, 0, 30, fill='tomato', border='gray') ]

def checkShapes():
    # Loops through each of the shapes.
    for i in range(len(app.shapes)):
        # If the fills don't match, return False.
        if (app.fallingShapes[i].fill != app.shapes[i].fill):
            ### Place Your Code Here ###
            pass

    # If all the fills match, return True.
    ### Place Your Code Here ###

def setBorders():
    # Highlights the selected shape.
    for i in range(len(app.shapes)):
        if (i == app.index):
            app.shapes[i].border = 'lime'
        else:
            app.shapes[i].border = 'gray'

def onKeyPress(key):
    x = app.index * 130 + 70

    # Changes the selected shape on space.
    if (key == 'space'):
        app.index += 1
        if (app.index == 3):
            app.index = 0
        setBorders()

    # If the key is c, change the shape at app.index to a circle.
    if (key == 'c'):
        app.shapes[app.index].visible = False
        ### Place Your Code Here ###

    # If the key is t, change the shape at app.index to a triangle.
    if (key == 't'):
        app.shapes[app.index].visible = False
        ### Place Your Code Here ###

    # If the key is d, change the shape at app.index to a diamond.
    if (key == 'd'):
        app.shapes[app.index].visible = False
        ### Place Your Code Here ###

def onStep():
    # Moves all the shapes and check for a win or loss.
    for shape in app.fallingShapes:
        shape.centerY += 3
        if (shape.centerY >= 310):
            if (checkShapes() == False):
                Label('YOU LOSE', 200, 200, fill='gold', size=40)
            else:
                Label('YOU WIN', 200, 200, fill='gold', size=40)

            app.stop()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.index = 0

# Earth
Oval(200, 400, 600, 100, fill='lightSkyBlue', border='mediumSeaGreen',
     borderWidth=8)
Polygon(-50, 375, 40, 390, 140, 365, 205, 380, 290, 365, 355, 360,
        400, 365, 245, 355, 145, 355, fill='mediumSeaGreen')

# Draws stars in the background.
for i in range(100):
    Circle(randrange(0, 400), randrange(0, 350), 1, fill='white')

# Shapes along the bottom.
app.shapes = [ Circle(70, 310, 30, fill='tomato', border='lime'),
               RegularPolygon(200, 310, 35, 3, fill='darkGray', border='gray'),
               RegularPolygon(330, 310, 35, 4, fill='orange', border='gray') ]

# Shapes that fall from the top.
app.fallingShapes = [ RegularPolygon(70, 0, 35, 3, fill='darkGray', border='gray'),
                      RegularPolygon(200, 0, 35, 4, fill='orange', border='gray'),
                      Circle(330, 0, 30, fill='tomato', border='gray') ]

def checkShapes():
    # Loops through each of the shapes.
    for i in range(len(app.shapes)):
        # If the fills don't match, return False.
        if (app.fallingShapes[i].fill != app.shapes[i].fill):
            return False

    # If all the fills match, return True.
    return True

def setBorders():
    # Highlights the selected shape.
    for i in range(len(app.shapes)):
        if (i == app.index):
            app.shapes[i].border = 'lime'
        else:
            app.shapes[i].border = 'gray'

def onKeyPress(key):
    x = app.index * 130 + 70

    # Changes the selected shape on space.
    if (key == 'space'):
        app.index += 1
        if (app.index == 3):
            app.index = 0
        setBorders()

    # If the key is c, change the shape at app.index to a circle.
    if (key == 'c'):
        app.shapes[app.index].visible = False
        app.shapes[app.index] = Circle(x, 310, 30, fill='tomato',
                                       border='lime')

    # If the key is t, change the shape at app.index to a triangle.
    if (key == 't'):
        app.shapes[app.index].visible = False
        app.shapes[app.index] = RegularPolygon(x, 310, 35, 3, fill='darkGray',
                                               border='lime')

    # If the key is d, change the shape at app.index to a diamond.
    if (key == 'd'):
        app.shapes[app.index].visible = False
        app.shapes[app.index] = RegularPolygon(x, 310, 35, 4, fill='orange',
                                               border='lime')

def onStep():
    # Moves all the shapes and check for a win or loss.
    for shape in app.fallingShapes:
        shape.centerY += 3
        if (shape.centerY >= 310):
            if (checkShapes() == False):
                Label('YOU LOSE', 200, 200, fill='gold', size=40)
            else:
                Label('YOU WIN', 200, 200, fill='gold', size=40)

            app.stop()
",regular,1
2305,Word cloud,10.4,"app.background = rgb(205, 210, 215)

seenWords = Group()

def countWord(paragraph, targetWord):
    # Counts the number of times the targetWord appears in the paragraph.
    count = 0
    for word in paragraph:
        # If the word is the target word, adds one to count.
        if (word == targetWord):
            count += 1

    # Return count.
    ### Place Your Code Here ###

def drawWordCloud(text):
    colors = [ 'indigo', 'navy', 'royalBlue', 'dodgerBlue', 'mediumSlateBlue' ]

    # Loops over each word in the paragraph.
    for word in text:
        # The size should be 10 + 2 times the word count and the color is random.
        # The angle is one of 0, 90, or 270 and the position should be between
        # 50 and 350 (inclusive).
        ### Fix Your Code Here ###
        size = 12
        color = 'black'
        angle = 0
        x = 200
        y = 200

        # Draws the word with the properties generated above.
        label = Label(word, x, y, fill=color, size=size, rotateAngle=angle,
                      bold=True)

        # Tries to reposition the word so it doesn't hit any other words.
        attempts = 0
        while ((label.hitsShape(seenWords) == True) and (attempts <= 500)):
            x = randrange(50, 351)
            y = randrange(50, 351)
            label.centerX = x
            label.centerY = y

            attempts += 1

        seenWords.add(label)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(205, 210, 215)

seenWords = Group()

def countWord(paragraph, targetWord):
    # Counts the number of times the targetWord appears in the paragraph.
    count = 0
    for word in paragraph:
        # If the word is the target word, adds one to count.
        if (word == targetWord):
            count += 1

    # Return count.
    return count

def drawWordCloud(text):
    colors = [ 'indigo', 'navy', 'royalBlue', 'dodgerBlue', 'mediumSlateBlue' ]

    # Loops over each word in the paragraph.
    for word in text:
        # The size should be 10 + 2 times the word count and the color is random.
        # The angle is one of 0, 90, or 270 and the position should be between
        # 50 and 350 (inclusive).
        size = 10 + 2 * countWord(text, word)
        color = choice(colors)
        angle = choice([ 0, 90, 270 ])

        x = randrange(50, 351)
        y = randrange(50, 351)

        # Draws the word with the properties generated above.
        label = Label(word, x, y, fill=color, size=size, rotateAngle=angle,
                      bold=True)

        # Tries to reposition the word so it doesn't hit any other words.
        attempts = 0
        while ((label.hitsShape(seenWords) == True) and (attempts <= 500)):
            x = randrange(50, 351)
            y = randrange(50, 351)
            label.centerX = x
            label.centerY = y

            attempts += 1

        seenWords.add(label)
",regular,1
2306,Wheel of fortune,10.4,"app.background = 'blanchedAlmond'
app.spinning = True

# wheel stand and base
Polygon(175, 20, 225, 20, 250, 375, 150, 375, fill='peru')
Polygon(125, 375, 275, 375, 290, 400, 110, 400, fill='peru')
Circle(200, 200, 150, fill='sandyBrown')

wheel = Group()

def drawArc(num):
    # Draws one arc of the wheel.
    colorList = [ 'lightCoral', 'mediumAquamarine', 'lightBlue', 'plum',
                  'royalBlue' ]
    color = colorList[num % 5]
    startAngle = 36 * num
    sweepAngle = 36
    wheel.add(
        Arc(200, 200, 260, 260, startAngle, sweepAngle, fill=color, border='white')
        )

def drawLabel(num):
    prizes = [ '$0', '$100', '$200', '$300', '$400', '$500', '$1000', '$5000' ]

    # Get a random prize amount.
    ### Fix Your Code Here ###
    text = '$$$'

    # Adds the prize to the wheel.
    angle = 36 * num + 18
    centerX, centerY = getPointInDir(200, 200, angle, 90)
    rotate = 300 + 36 * num
    wheel.add(
        Label(text, centerX, centerY, fill='white', size=18, bold=True,
              rotateAngle=rotate)
        )

    # Adds the dots to the outside of the wheel.
    dotX, dotY = getPointInDir(200, 200, angle, 140)
    wheel.add(
        Circle(dotX, dotY, 4, fill='beige')
        )

def drawWheel():
    # Draws the wheel pointer and center circle.
    Polygon(185, 30, 215, 30, 200, 70, fill='tomato', border='white',
            borderWidth=3)
    Circle(200, 200, 20, fill=gradient('silver', 'white', start='left'),
           border='sandyBrown', borderWidth=10)

    for num in range(10):
        drawArc(num)
        drawLabel(num)

drawWheel()

def onKeyPress(key):
    # Begins slowing the wheel.
    if (key == 'space'):
        app.spinning = False

def onStep():
    # Gradually slows the wheel.
    if (app.spinning == False):
        app.stepsPerSecond -= 1

    # When the wheel has stopped, check which part of the wheel is touching the
    # triangle and set its fill. Also draw the winner label.
    if (app.stepsPerSecond == 0):
        ### Place Your Code Here ###
        pass

    wheel.rotateAngle += 3
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'blanchedAlmond'
app.spinning = True

# wheel stand and base
Polygon(175, 20, 225, 20, 250, 375, 150, 375, fill='peru')
Polygon(125, 375, 275, 375, 290, 400, 110, 400, fill='peru')
Circle(200, 200, 150, fill='sandyBrown')

wheel = Group()

def drawArc(num):
    # Draws one arc of the wheel.
    colorList = [ 'lightCoral', 'mediumAquamarine', 'lightBlue', 'plum',
                  'royalBlue' ]
    color = colorList[num % 5]
    startAngle = 36 * num
    sweepAngle = 36
    wheel.add(
        Arc(200, 200, 260, 260, startAngle, sweepAngle, fill=color, border='white')
        )

def drawLabel(num):
    prizes = [ '$0', '$100', '$200', '$300', '$400', '$500', '$1000', '$5000' ]

    # Get a random prize amount.
    text = choice(prizes)

    # Adds the prize to the wheel.
    angle = 36 * num + 18
    centerX, centerY = getPointInDir(200, 200, angle, 90)
    rotate = 300 + 36 * num
    wheel.add(
        Label(text, centerX, centerY, fill='white', size=18, bold=True,
              rotateAngle=rotate)
        )

    # Adds the dots to the outside of the wheel.
    dotX, dotY = getPointInDir(200, 200, angle, 140)
    wheel.add(
        Circle(dotX, dotY, 4, fill='beige')
        )

def drawWheel():
    # Draws the wheel pointer and center circle.
    Polygon(185, 30, 215, 30, 200, 70, fill='tomato', border='white',
            borderWidth=3)
    Circle(200, 200, 20, fill=gradient('silver', 'white', start='left'),
           border='sandyBrown', borderWidth=10)

    for num in range(10):
        drawArc(num)
        drawLabel(num)

drawWheel()

def onKeyPress(key):
    # Begins slowing the wheel.
    if (key == 'space'):
        app.spinning = False

def onStep():
    # Gradually slows the wheel.
    if (app.spinning == False):
        app.stepsPerSecond -= 1

    # When the wheel has stopped, check which part of the wheel is touching the
    # triangle and set its fill. Also draw the winner label.
    if (app.stepsPerSecond == 0):
        winningArc = wheel.hitTest(200, 80)
        winningArc.fill = 'lime'
        Label('WINNER!', 200, 300, fill='gold', border='black', size=50, bold=True)

    wheel.rotateAngle += 3
",regular,1
2307,Building jumper,10.4,"app.background = gradient('black', 'midnightBlue', start='top')

app.buildingHeights = [ ]

def drawBuildings():
    # Draws 16 buildings, each with three windows.
    for x in range(0, 400, 25):
        height = randrange(100, 400)
        Rect(x, height, 25, 400 - height,
             fill=gradient('dimGray', 'slateGray', start='top'))

        # Draws three windows on each building.
        for i in range(3):
            Rect(x + randrange(5, 10), randrange(height, 400), 10, 5, fill='gold')

        # Store the top of the rectangle in buildingHeights.
        ### Place Your Code Here ###

drawBuildings()

spiderman = Group(
    Circle(200, 200, 8, fill='red'),
    Rect(188, 208, 24, 6, fill='red'),
    Rect(192, 214, 16, 16, fill='red'),
    Arc(197, 199, 5, 5, 110, 180, fill='white', border='black', borderWidth=0.5),
    Arc(203, 199, 5, 5, 70, 180, fill='white', border='black', borderWidth=0.5),
    Rect(192, 220, 16, 6, fill='blue'),
    Rect(192, 214, 4, 5, fill='blue'),
    Rect(204, 214, 4, 5, fill='blue'),
    Circle(200, 213, 1),
    Line(200, 232, 200, 223, opacity=40)
    )
spiderman.centerX = -50

def onMouseMove(mouseX, mouseY):
    # Move spiderman to follow mouseX and set the bottom of the group equal
    # to the height of the building it is currently on.
    ### (HINT: Index into the buildingHeights list by integer dividing
    #          mouseX by the width of the building!)
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('black', 'midnightBlue', start='top')

app.buildingHeights = [ ]

def drawBuildings():
    # Draws 16 buildings, each with three windows.
    for x in range(0, 400, 25):
        height = randrange(100, 400)
        Rect(x, height, 25, 400 - height,
             fill=gradient('dimGray', 'slateGray', start='top'))

        # Draws three windows on each building.
        for i in range(3):
            Rect(x + randrange(5, 10), randrange(height, 400), 10, 5, fill='gold')

        # Store the top of the rectangle in buildingHeights.
        app.buildingHeights.append(height)

drawBuildings()

spiderman = Group(
    Circle(200, 200, 8, fill='red'),
    Rect(188, 208, 24, 6, fill='red'),
    Rect(192, 214, 16, 16, fill='red'),
    Arc(197, 199, 5, 5, 110, 180, fill='white', border='black', borderWidth=0.5),
    Arc(203, 199, 5, 5, 70, 180, fill='white', border='black', borderWidth=0.5),
    Rect(192, 220, 16, 6, fill='blue'),
    Rect(192, 214, 4, 5, fill='blue'),
    Rect(204, 214, 4, 5, fill='blue'),
    Circle(200, 213, 1),
    Line(200, 232, 200, 223, opacity=40)
    )
spiderman.centerX = -50

def onMouseMove(mouseX, mouseY):
    # Move spiderman to follow mouseX and set the bottom of the group equal
    # to the height of the building it is currently on.
    spiderman.centerX = mouseX
    index = mouseX // 25
    spiderman.bottom = app.buildingHeights[index]
",regular,2
2308,UFO,10.4,"app.background = gradient('indigo', 'royalBlue', start='top')

# hillside
Oval(200, 270, 400, 50, fill='teal')
Rect(0, 270, 400, 150, fill='teal')

def drawStars():
    starX = [ 30, 60, 70, 180, 230, 360, 380, 130, 25, 145, 380, 275 ]
    starY = [ 40, 35, 70, 50, 60, 70, 90, 100, 185, 145, 210, 225 ]

    # Loop over the star coordinates and draw random stars.
    ### (HINT: Look at how each cow is repositioned in the drawCows function
    #          below!)
    ### Place Your Code Here ###
    # x =
    # y =
    starRadius = randrange(3, 7)
    starPoint = randrange(4, 8)
    starColor = choice([ 'cornSilk', 'aliceBlue', 'lavenderBlush' ])
    starRound = randrange(10, 30)
    # Star()

def drawCows():
    cowX = [ 80, 280, 325 ]
    cowY = [ 335, 355, 275 ]

    # Loops over the cow positions and draw the cows.
    for i in range(len(cowX)):
        color = gradient('whiteSmoke', 'lightGrey', start='left')
        cow = Group(
            # legs
            Line(205, 240, 215, 240, fill=color, lineWidth=15, dashes=(3, 2)),
            Line(240, 240, 250, 240, fill=color, lineWidth=15, dashes=(3, 2)),

            # tail
            Star(257, 235, 4, 7, roundness=20),
            Line(253, 215, 257, 235, fill='white', lineWidth=1),

            # body
            Oval(200, 200, 55, 45, fill=color, align='left-top'),
            Oval(195, 205, 8, 4, rotateAngle=-20),
            Oval(215, 205, 8, 3, rotateAngle=20),

            # head
            Oval(220, 230, 25, 20, rotateAngle=-30),
            Arc(245, 205, 20, 25, 130, 160),
            Oval(205, 215, 25, 30, fill=color),
            Circle(200, 210, 3, border='white'),
            Circle(210, 210, 3, border='white'),
            Arc(205, 220, 22, 20, 90, 180, fill='lightCoral')
            )
        cow.centerX = cowX[i]
        cow.centerY = cowY[i]
        cows.add(cow)

drawStars()

cows = Group()
drawCows()

# UFO and light
light = Group(
    Polygon(160, 150, 240, 150, 280, 300, 120, 300, fill='yellow', opacity=50),
    Arc(200, 300, 160, 40, 90, 180, fill='yellow', opacity=50),
    Arc(200, 150, 80, 7, 270, 180, fill='yellow', opacity=50)
    )
UFO = Group(
    Oval(200, 120, 100, 60, opacity=50),
    Polygon(150, 120, 250, 120, 290, 150, 110, 150),
    Oval(200, 150, 180, 20, border='royalBlue'),
    light
    )

def onMouseMove(mouseX, mouseY):
    # Moves the UFO.
    UFO.centerX = mouseX
    UFO.centerY = mouseY

def onStep():
    # If any of the cows are hit by the beam from the UFO, move the cow into
    # the light beam. Also increase the rotate angle of that cow by 5.
    ### Place Your Code Here ###
    pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('indigo', 'royalBlue', start='top')

# hillside
Oval(200, 270, 400, 50, fill='teal')
Rect(0, 270, 400, 150, fill='teal')

def drawStars():
    starX = [ 30, 60, 70, 180, 230, 360, 380, 130, 25, 145, 380, 275 ]
    starY = [ 40, 35, 70, 50, 60, 70, 90, 100, 185, 145, 210, 225 ]

    # Loop over the star coordinates and draw random stars.
    for i in range(len(starX)):
        x = starX[i]
        y = starY[i]
        starRadius = randrange(3, 7)
        starPoint = randrange(4, 8)
        starColor = choice([ 'cornSilk', 'aliceBlue', 'lavenderBlush' ])
        starRound = randrange(10, 30)
        Star(x, y, starRadius, starPoint, fill=starColor, roundness=starRound)

def drawCows():
    cowX = [ 80, 280, 325 ]
    cowY = [ 335, 355, 275 ]

    # Loops over the cow positions and draw the cows.
    for i in range(len(cowX)):
        color = gradient('whiteSmoke', 'lightGrey', start='left')
        cow = Group(
            # legs
            Line(205, 240, 215, 240, fill=color, lineWidth=15, dashes=(3, 2)),
            Line(240, 240, 250, 240, fill=color, lineWidth=15, dashes=(3, 2)),

            # tail
            Star(257, 235, 4, 7, roundness=20),
            Line(253, 215, 257, 235, fill='white', lineWidth=1),

            # body
            Oval(200, 200, 55, 45, fill=color, align='left-top'),
            Oval(195, 205, 8, 4, rotateAngle=-20),
            Oval(215, 205, 8, 3, rotateAngle=20),

            # head
            Oval(220, 230, 25, 20, rotateAngle=-30),
            Arc(245, 205, 20, 25, 130, 160),
            Oval(205, 215, 25, 30, fill=color),
            Circle(200, 210, 3, border='white'),
            Circle(210, 210, 3, border='white'),
            Arc(205, 220, 22, 20, 90, 180, fill='lightCoral')
            )
        cow.centerX = cowX[i]
        cow.centerY = cowY[i]
        cows.add(cow)

drawStars()

cows = Group()
drawCows()

# UFO and light
light = Group(
    Polygon(160, 150, 240, 150, 280, 300, 120, 300, fill='yellow', opacity=50),
    Arc(200, 300, 160, 40, 90, 180, fill='yellow', opacity=50),
    Arc(200, 150, 80, 7, 270, 180, fill='yellow', opacity=50)
    )
UFO = Group(
    Oval(200, 120, 100, 60, opacity=50),
    Polygon(150, 120, 250, 120, 290, 150, 110, 150),
    Oval(200, 150, 180, 20, border='royalBlue'),
    light
    )

def onMouseMove(mouseX, mouseY):
    # Moves the UFO.
    UFO.centerX = mouseX
    UFO.centerY = mouseY

def onStep():
    # If any of the cows are hit by the beam from the UFO, move the cow into
    # the light beam. Also increase the rotate angle of that cow by 5.
    for cow in cows.children:
        if (light.hitsShape(cow) == True):
            cow.centerX = light.centerX
            cow.centerY = light.centerY
            cow.rotateAngle += 5
",regular,2
2310,Grocery list,10.4,"app.background = rgb(200, 170, 130)
app.stepsPerSecond = 1

app.step = 0
app.time = 10

# shelves
Rect(0, 105, 400, 10, fill=rgb(230, 200, 160))
Rect(0, 215, 400, 10, fill=rgb(230, 200, 160))
Rect(0, 330, 400, 70, fill='gainsboro')

# timer
clock = Group(
    Circle(310, 345, 40, fill='white', border='black'),
    Line(310, 345, 310, 320, fill='red', lineWidth=3),
    Circle(310, 345, 3, fill='red')
    )
timer = Label('You have ' + str(app.time) + ' seconds', 310, 270, size=14,
              bold=True)
Label('to finish shopping!', 310, 290, size=14, bold=True)

# produce
orange = Group(
    Circle(80, 75, 30, fill='orange'),
    Star(80, 50, 4, 7, fill='olive')
    )
orange.name = 'orange'

apple = Group(
    Oval(190, 75, 50, 60, fill='red'),
    Oval(210, 75, 50, 60, fill='red'),
    Oval(207, 44, 8, 15, fill='green', rotateAngle=60)
    )
apple.name = 'apple'

pear = Group(
    Circle(320, 80, 25, fill='yellowGreen'),
    Circle(320, 60, 15, fill='yellowGreen'),
    Rect(320, 40, 6, 9, fill='olive', align='top')
    )
pear.name = 'pear'

milk = Group(
    Rect(55, 155, 50, 60, fill='white'),
    Rect(55, 197, 50, 8, fill='skyBlue'),
    Polygon(55, 155, 105, 155, 100, 140, 60, 140, fill='skyBlue'),
    Rect(60, 133, 40, 7, fill='white')
    )
milk.name = 'milk'

bread = Group(
    Rect(160, 175, 80, 40, fill='peru'),
    Circle(160, 195, 20, fill='peru'),
    Circle(240, 195, 20, fill='peru'),
    Polygon(170, 175, 180, 175, 175, 190, fill='wheat'),
    Polygon(230, 175, 220, 175, 225, 190, fill='wheat'),
    Polygon(195, 175, 205, 175, 200, 190, fill='wheat')
    )
bread.name = 'bread'

eggs = Group(
    Oval(320, 195, 15, 20, fill='white'),
    Oval(300, 195, 15, 20, fill='white'),
    Oval(340, 195, 15, 20, fill='white'),
    Polygon(285, 195, 355, 195, 350, 215, 290, 215, fill='gainsboro')
    )
eggs.name = 'eggs'

produce = Group(orange, apple, pear, milk, bread, eggs)

def drawGroceryList():
    produceNames = [ 'orange', 'apple', 'pear', 'milk', 'bread', 'eggs' ]

    # Loop over the produce names and add a label to the grocery list group.
    ### Place Your Code Here ###
    pass

# grocery list
Polygon(20, 410, 40, 280, 200, 280, 220, 410, fill='white', border='black')
Label('Shopping List', 120, 300, size=16)
Line(120, 320, 120, 400, fill='lightBlue', lineWidth=160, dashes=(2, 17))
groceryList = Group()
drawGroceryList()

def onMousePress(mouseX, mouseY):
    # See if the user clicked on a grocery item. If so, remove
    # the item from the grocery list and the produce group.
    ### (HINT: Loop over groceryList.children and compare the value of each item
    #          to the name of what you clicked on.)
    ### Place Your Code Here ###
    pass

def onStep():
    app.time -= 1
    timer.value = 'You have ' + str(app.time) + ' seconds'
    clock.rotateAngle += 36
    if (app.time <= 0):
        app.stop()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = rgb(200, 170, 130)
app.stepsPerSecond = 1

app.step = 0
app.time = 10

# shelves
Rect(0, 105, 400, 10, fill=rgb(230, 200, 160))
Rect(0, 215, 400, 10, fill=rgb(230, 200, 160))
Rect(0, 330, 400, 70, fill='gainsboro')

# timer
clock = Group(
    Circle(310, 345, 40, fill='white', border='black'),
    Line(310, 345, 310, 320, fill='red', lineWidth=3),
    Circle(310, 345, 3, fill='red')
    )
timer = Label('You have ' + str(app.time) + ' seconds', 310, 270, size=14,
              bold=True)
Label('to finish shopping!', 310, 290, size=14, bold=True)

# produce
orange = Group(
    Circle(80, 75, 30, fill='orange'),
    Star(80, 50, 4, 7, fill='olive')
    )
orange.name = 'orange'

apple = Group(
    Oval(190, 75, 50, 60, fill='red'),
    Oval(210, 75, 50, 60, fill='red'),
    Oval(207, 44, 8, 15, fill='green', rotateAngle=60)
    )
apple.name = 'apple'

pear = Group(
    Circle(320, 80, 25, fill='yellowGreen'),
    Circle(320, 60, 15, fill='yellowGreen'),
    Rect(320, 40, 6, 9, fill='olive', align='top')
    )
pear.name = 'pear'

milk = Group(
    Rect(55, 155, 50, 60, fill='white'),
    Rect(55, 197, 50, 8, fill='skyBlue'),
    Polygon(55, 155, 105, 155, 100, 140, 60, 140, fill='skyBlue'),
    Rect(60, 133, 40, 7, fill='white')
    )
milk.name = 'milk'

bread = Group(
    Rect(160, 175, 80, 40, fill='peru'),
    Circle(160, 195, 20, fill='peru'),
    Circle(240, 195, 20, fill='peru'),
    Polygon(170, 175, 180, 175, 175, 190, fill='wheat'),
    Polygon(230, 175, 220, 175, 225, 190, fill='wheat'),
    Polygon(195, 175, 205, 175, 200, 190, fill='wheat')
    )
bread.name = 'bread'

eggs = Group(
    Oval(320, 195, 15, 20, fill='white'),
    Oval(300, 195, 15, 20, fill='white'),
    Oval(340, 195, 15, 20, fill='white'),
    Polygon(285, 195, 355, 195, 350, 215, 290, 215, fill='gainsboro')
    )
eggs.name = 'eggs'

produce = Group(orange, apple, pear, milk, bread, eggs)

def drawGroceryList():
    produceNames = [ 'orange', 'apple', 'pear', 'milk', 'bread', 'eggs' ]

    # Loop over the produce names and add a label to the grocery list group.
    for i in range(len(produceNames)):
        if (i % 2 == 0):
            grocery = Label(produceNames[i], 75, 10 * i + 330, size=12)
        else:
            grocery = Label(produceNames[i], 160, 10 * (i - 1) + 330, size=12)
        groceryList.add(grocery)
# grocery list
Polygon(20, 410, 40, 280, 200, 280, 220, 410, fill='white', border='black')
Label('Shopping List', 120, 300, size=16)
Line(120, 320, 120, 400, fill='lightBlue', lineWidth=160, dashes=(2, 17))
groceryList = Group()
drawGroceryList()

def onMousePress(mouseX, mouseY):
    # See if the user clicked on a grocery item. If so, remove
    # the item from the grocery list and the produce group.
    target = produce.hitTest(mouseX, mouseY)
    if (target != None):
        for item in groceryList.children:
            if (item.value == target.name):
                groceryList.remove(item)
        produce.remove(target)

def onStep():
    app.time -= 1
    timer.value = 'You have ' + str(app.time) + ' seconds'
    clock.rotateAngle += 36
    if (app.time <= 0):
        app.stop()
",regular,3
2304,Weather app,10.4,"app.background = gradient('azure', rgb(0, 205, 255), rgb(0, 205, 255),
                          start='left-top')

# background and text
Label('Pittsburgh', 200, 110, fill='white', size=35)
Label('Sunny', 200, 145, fill='white', size=20)
Label('12:05', 200, 10, fill='white', size=15)
Label('47%', 350, 10, fill='white', size=15)
Rect(372, 5, 23, 10, fill=None, border='white')
Rect(372, 5, 11, 10, fill='white')
Star(50, 345, 20, 8, fill='yellow', roundness=20)
Star(150, 345, 20, 8, fill='yellow', roundness=20)
Star(250, 345, 20, 8, fill='yellow', roundness=20)
Star(350, 345, 20, 8, fill='yellow', roundness=20)
Oval(360, 350, 25, 20, fill='gray')
Oval(370, 350, 25, 20, fill='gray')
Oval(365, 345, 20, 20, fill='gray')
Label('1PM', 50, 315, fill='white', size=16)
Label('2PM', 150, 315, fill='white', size=16)
Label('3PM', 250, 315, fill='white', size=16)
Label('4PM', 350, 315, fill='white', size=16)
Line(0, 300, 400, 300, fill='white')

# units toggle
unitLabel = Label('C', 40, 280, fill='goldenrod', bold=True)
unitCircle = Group(
    Circle(40, 280, 8, fill='white'),
    unitLabel
    )
unitBase = Group(
    Rect(40, 270, 20, 20, fill='goldenrod'),
    Circle(40, 280, 10, fill='goldenrod'),
    Circle(60, 280, 10, fill='goldenrod'),
    unitCircle
    )

temperatures = Group(
    Label(24, 350, 285, fill='white', size=16),
    Label(32, 380, 285, fill='white', size=16),
    Label(24, 200, 210, fill='white', size=70),
    Label(25, 50, 380, fill='white', size=18),
    Label(27, 150, 380, fill='white', size=18),
    Label(28, 250, 380, fill='white', size=18),
    Label(30, 350, 380, fill='white', size=18)
    )
temperatures.isCelsius = True

def changeUnits(temp, isCelsius):
    # Changes the units of the temperature from Celsius to Fahrenheit or back
    # using the formula: celsius = fahrenheit * 9/5 + 32.
    if (isCelsius == True):
        newTemp = rounded(temp.value * (9 / 5) + 32)
    else:
        newTemp = rounded((temp.value - 32) * (5 / 9))

    # Return newTemp.
    ### Place Your Code Here ###

def onMousePress(mouseX, mouseY):
    # Checks to see if the toggle was clicked.
    if (unitBase.hits(mouseX, mouseY) == True):
        # Change the units of each temperature.
        ### (HINT: Use the custom property temperatures.isCelsius when calling
        #          changeUnits.)
        ### Place Your Code Here ###

        # Toggles the label and the custom property.
        if (unitLabel.value == 'C'):
            unitLabel.value = 'F'
            unitCircle.centerX += 20
            temperatures.isCelsius = False
        else:
            unitLabel.value = 'C'
            unitCircle.centerX -= 20
            temperatures.isCelsius = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('azure', rgb(0, 205, 255), rgb(0, 205, 255),
                          start='left-top')

# background and text
Label('Pittsburgh', 200, 110, fill='white', size=35)
Label('Sunny', 200, 145, fill='white', size=20)
Label('12:05', 200, 10, fill='white', size=15)
Label('47%', 350, 10, fill='white', size=15)
Rect(372, 5, 23, 10, fill=None, border='white')
Rect(372, 5, 11, 10, fill='white')
Star(50, 345, 20, 8, fill='yellow', roundness=20)
Star(150, 345, 20, 8, fill='yellow', roundness=20)
Star(250, 345, 20, 8, fill='yellow', roundness=20)
Star(350, 345, 20, 8, fill='yellow', roundness=20)
Oval(360, 350, 25, 20, fill='gray')
Oval(370, 350, 25, 20, fill='gray')
Oval(365, 345, 20, 20, fill='gray')
Label('1PM', 50, 315, fill='white', size=16)
Label('2PM', 150, 315, fill='white', size=16)
Label('3PM', 250, 315, fill='white', size=16)
Label('4PM', 350, 315, fill='white', size=16)
Line(0, 300, 400, 300, fill='white')

# units toggle
unitLabel = Label('C', 40, 280, fill='goldenrod', bold=True)
unitCircle = Group(
    Circle(40, 280, 8, fill='white'),
    unitLabel
    )
unitBase = Group(
    Rect(40, 270, 20, 20, fill='goldenrod'),
    Circle(40, 280, 10, fill='goldenrod'),
    Circle(60, 280, 10, fill='goldenrod'),
    unitCircle
    )

temperatures = Group(
    Label(24, 350, 285, fill='white', size=16),
    Label(32, 380, 285, fill='white', size=16),
    Label(24, 200, 210, fill='white', size=70),
    Label(25, 50, 380, fill='white', size=18),
    Label(27, 150, 380, fill='white', size=18),
    Label(28, 250, 380, fill='white', size=18),
    Label(30, 350, 380, fill='white', size=18)
    )
temperatures.isCelsius = True

def changeUnits(temp, isCelsius):
    # Changes the units of the temperature from Celsius to Fahrenheit or back
    # using the formula: celsius = fahrenheit * 9/5 + 32.
    if (isCelsius == True):
        newTemp = rounded(temp.value * (9 / 5) + 32)
    else:
        newTemp = rounded((temp.value - 32) * (5 / 9))

    # Return newTemp.
    return newTemp

def onMousePress(mouseX, mouseY):
    # Checks to see if the toggle was clicked.
    if (unitBase.hits(mouseX, mouseY) == True):
        # Change the units of each temperature.
        for temp in temperatures.children:
            temp.value = changeUnits(temp, temperatures.isCelsius)

        # Toggles the label and the custom property.
        if (unitLabel.value == 'C'):
            unitLabel.value = 'F'
            unitCircle.centerX += 20
            temperatures.isCelsius = False
        else:
            unitLabel.value = 'C'
            unitCircle.centerX -= 20
            temperatures.isCelsius = True
",regular,1
2311,UFO Drawing,10.5,"app.background = 'black'
app.stepsPerSecond = 20

# background stars
Star(320, 50, 2, 5, fill='white')
Star(230, 115, 3, 5, fill='white')
Star(380, 315, 2, 5, fill='white')
Star(150, 190, 2, 5, fill='white')
Star(285, 290, 3, 5, fill='white')
Star(50, 325, 2, 5, fill='white')
Star(210, 375, 2, 5, fill='white')
Star(10, 25, 2, 5, fill='white')

# moon
Circle(50, 100, 30, fill=gradient('black', 'grey', start='left'))
Circle(40, 80, 3, fill=rgb(50, 50, 50))
Circle(65, 85, 4, fill=rgb(85, 85, 85))
Circle(70, 110, 3, fill=rgb(85, 85, 85))
Circle(40, 115, 4, fill=rgb(45, 45, 45))
Circle(45, 95, 4, fill=rgb(55, 55, 55))
Circle(60, 100, 4, fill=rgb(75, 75, 75))
Circle(30, 95, 3, fill=rgb(15, 15, 15))

app.UFOs = [ ]
app.points = [ ]

def createUFOs(n):
    # trails
    for i in range(n):
        color = rgb(randrange(0, 256), randrange(0, 256), randrange(0, 256))
        trail = Line(8, 10, 10, 10, fill=gradient(color, 'black'), lineWidth=5)
        ufo = Circle(10, 10, 5, fill=gradient('lightGrey', 'grey'))
        ufo.targetX = 0
        ufo.targetY = 0
        app.UFOs.append(ufo)
        app.UFOs.append(trail)

def moveFighter(fighter):
    fighter.centerX = fighter.targetX
    fighter.centerY = fighter.targetY

def moveTrail(fighter, trail):
    trail.x1 = trail.x2
    trail.y1 = trail.y2

    trail.x2 = fighter.centerX
    trail.y2 = fighter.centerY


def onMousePress(mouseX, mouseY):
    app.points.append(mouseX)
    app.points.append(mouseY)

def onKeyPress(key):
    if (key == 'space'):
        app.paused = False

def onStep():
    firstUFO = app.UFOs[0]
    firstTrail = app.UFOs[1]
    distToTarget = distance(firstUFO.centerX, firstUFO.centerY,
                            firstUFO.targetX, firstUFO.targetY)
    if (distToTarget < 15):
        nextPointX = app.points.pop(0)
        nextPointY = app.points.pop(0)
        firstUFO.targetX = nextPointX
        firstUFO.targetY = nextPointY
        app.points.append(nextPointX)
        app.points.append(nextPointY)

    angle = angleTo(firstUFO.centerX, firstUFO.centerY,
                    firstUFO.targetX, firstUFO.targetY)
    newX, newY = getPointInDir(firstUFO.centerX, firstUFO.centerY, angle,
                               randrange(10, 30))
    firstUFO.centerX = newX
    firstUFO.centerY = newY
    moveTrail(firstUFO, firstTrail)

    oldX = firstTrail.x1
    oldY = firstTrail.y1
    i = 0
    for index in range(2, len(app.UFOs), 2):
        fighter = app.UFOs[index]
        trail = app.UFOs[index + 1]
        moveFighter(fighter)
        moveTrail(fighter, trail)
        fighter.targetX = oldX
        fighter.targetY = oldY
        oldX = trail.x1
        oldY = trail.y1
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 20

# background stars
Star(320, 50, 2, 5, fill='white')
Star(230, 115, 3, 5, fill='white')
Star(380, 315, 2, 5, fill='white')
Star(150, 190, 2, 5, fill='white')
Star(285, 290, 3, 5, fill='white')
Star(50, 325, 2, 5, fill='white')
Star(210, 375, 2, 5, fill='white')
Star(10, 25, 2, 5, fill='white')

# moon
Circle(50, 100, 30, fill=gradient('black', 'grey', start='left'))
Circle(40, 80, 3, fill=rgb(50, 50, 50))
Circle(65, 85, 4, fill=rgb(85, 85, 85))
Circle(70, 110, 3, fill=rgb(85, 85, 85))
Circle(40, 115, 4, fill=rgb(45, 45, 45))
Circle(45, 95, 4, fill=rgb(55, 55, 55))
Circle(60, 100, 4, fill=rgb(75, 75, 75))
Circle(30, 95, 3, fill=rgb(15, 15, 15))

app.UFOs = [ ]
app.points = [ ]

def createUFOs(n):
    # trails
    for i in range(n):
        color = rgb(randrange(0, 256), randrange(0, 256), randrange(0, 256))
        trail = Line(8, 10, 10, 10, fill=gradient(color, 'black'), lineWidth=5)
        ufo = Circle(10, 10, 5, fill=gradient('lightGrey', 'grey'))
        ufo.targetX = 0
        ufo.targetY = 0
        app.UFOs.append(ufo)
        app.UFOs.append(trail)

def moveFighter(fighter):
    fighter.centerX = fighter.targetX
    fighter.centerY = fighter.targetY

def moveTrail(fighter, trail):
    trail.x1 = trail.x2
    trail.y1 = trail.y2

    trail.x2 = fighter.centerX
    trail.y2 = fighter.centerY


def onMousePress(mouseX, mouseY):
    app.points.append(mouseX)
    app.points.append(mouseY)

def onKeyPress(key):
    if (key == 'space'):
        app.paused = False

def onStep():
    firstUFO = app.UFOs[0]
    firstTrail = app.UFOs[1]
    distToTarget = distance(firstUFO.centerX, firstUFO.centerY,
                            firstUFO.targetX, firstUFO.targetY)
    if (distToTarget < 15):
        nextPointX = app.points.pop(0)
        nextPointY = app.points.pop(0)
        firstUFO.targetX = nextPointX
        firstUFO.targetY = nextPointY
        app.points.append(nextPointX)
        app.points.append(nextPointY)

    angle = angleTo(firstUFO.centerX, firstUFO.centerY,
                    firstUFO.targetX, firstUFO.targetY)
    newX, newY = getPointInDir(firstUFO.centerX, firstUFO.centerY, angle,
                               randrange(10, 30))
    firstUFO.centerX = newX
    firstUFO.centerY = newY
    moveTrail(firstUFO, firstTrail)

    oldX = firstTrail.x1
    oldY = firstTrail.y1
    i = 0
    for index in range(2, len(app.UFOs), 2):
        fighter = app.UFOs[index]
        trail = app.UFOs[index + 1]
        moveFighter(fighter)
        moveTrail(fighter, trail)
        fighter.targetX = oldX
        fighter.targetY = oldY
        oldX = trail.x1
        oldY = trail.y1
",sample,1
2317,Collaborative task,10.5,# Fill me in!,,creative,30
2315,Creative task 4,10.5,# Fill me in!,,creative,30
2316,Creative task 5,10.5,# Fill me in!,,creative,30
2312,Creative task 1,10.5,# Fill me in!,,creative,30
2313,Creative task 2,10.5,# Fill me in!,,creative,30
2314,Creative task 3,10.5,# Fill me in!,,creative,30
2320,Animate polygons,11.1.3,"app.background = 'black'
app.stepsPerSecond = 2
app.points = makeList(5, 2)

Label('Add 5 points to animate the polygon', 200, 15, fill='white', size=18,
      bold=True)
Label('Points Added: ', 190, 40, fill='white', size=18, bold=True)
pointsAdded = Label(0, 255, 40, fill='white', size=18, bold=True)
p = Polygon(fill=gradient('salmon', 'cornflowerBlue', start='bottom'))


def onMousePress(mouseX, mouseY):
    # Only adds up to 5 points.
    if (pointsAdded.value < 5):
        # Gets the index for the next point.
        index = pointsAdded.value

        # Use the index to get an inner list from app.points. Set the 0th
        # value of that inner list to mouseX and set the 1st value of the
        # inner list to mouseY. Also draw a dot and update the value of
        # pointsAdded.
        ### Place Your Code Here ###

def onStep():
    # Animates if all 5 points are added and the polygon is not yet complete.
    if ((pointsAdded.value == 5) and (len(app.points) > 0)):
        coords = app.points.pop()
        x = coords[0]
        y = coords[1]
        Circle(x, y, 5, fill='royalBlue')
        p.addPoint(x, y)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'
app.stepsPerSecond = 2
app.points = makeList(5, 2)

Label('Add 5 points to animate the polygon', 200, 15, fill='white', size=18,
      bold=True)
Label('Points Added: ', 190, 40, fill='white', size=18, bold=True)
pointsAdded = Label(0, 255, 40, fill='white', size=18, bold=True)
p = Polygon(fill=gradient('salmon', 'cornflowerBlue', start='bottom'))


def onMousePress(mouseX, mouseY):
    # Only adds up to 5 points.
    if (pointsAdded.value < 5):
        # Gets the index for the next point.
        index = pointsAdded.value

        # Use the index to get an inner list from app.points. Set the 0th
        # value of that inner list to mouseX and set the 1st value of the
        # inner list to mouseY. Also draw a dot and update the value of
        # pointsAdded.
        app.points[index][0] = mouseX
        app.points[index][1] = mouseY
        Circle(mouseX, mouseY, 4, fill='white')
        pointsAdded.value += 1

def onStep():
    # Animates if all 5 points are added and the polygon is not yet complete.
    if ((pointsAdded.value == 5) and (len(app.points) > 0)):
        coords = app.points.pop()
        x = coords[0]
        y = coords[1]
        Circle(x, y, 5, fill='royalBlue')
        p.addPoint(x, y)
",regular,1
2321,Color blocks,11.1.3,"app.rows = 4
app.cols = 4
app.board = makeList(app.rows, app.cols)
app.selectedRow = -1
app.selectedCol = -1

def makeBoard():
    for row in range(app.rows):
        for col in range(app.cols):
            # Gets a random blue value and the required x, y coordinates.
            blue = randrange(0, 256)
            x = 25 + col * 90
            y = 25 + row * 90

            # Create a rectangle with the correct blue value and store it in
            # the list.
            ### (HINT: Store the blue value in a .blue custom property!)
            ### Fix Your Code Here ###
            block = Rect(x, y, 70, 70, fill=rgb(0, 0, 0), borderWidth=5)
            # app.board[row][col] =

makeBoard()

def swap(row1, col1, row2, col2):
    # Swaps the fills of the blocks at (row1, col1) and (row2, col2).
    color1 = app.board[row1][col1].blue
    color2 = app.board[row2][col2].blue
    app.board[row1][col1].blue = color2
    app.board[row2][col2].blue = color1
    app.board[row1][col1].fill = rgb(0, 0, color2)
    app.board[row2][col2].fill = rgb(0, 0, color1)

def findBlock(x, y):
    # Find which block was clicked.
    for row in range(app.rows):
        for col in range(app.cols):
            block = app.board[row][col]

            # If the block was clicked, set the selectedRow and selectedCol
            # and return the block.
            ### Place Your Code Here ###

    return None

def checkWin():
    # Checks each row to see if it is in decreasing order.
    for row in range(app.rows):
        for col in range(0, app.cols):
            if (col == 0):
                app.board[row][col].border = 'green'

            # Correct blocks are highlighted in green.
            elif (app.board[row][col].blue <= app.board[row][col - 1].blue):
                app.board[row][col].border = 'green'

            # Incorrect blocks are highlighted in red.
            else:
                app.board[row][col].border = 'red'

def onMousePress(mouseX, mouseY):
    row1 = -1
    col1 = -1

    # If a block was already clicked, stores its values.
    if (app.selectedRow != -1):
        row1 = app.selectedRow
        col1 = app.selectedCol
    block = findBlock(mouseX, mouseY)

    # Second time a block was clicked.
    if ((block != None) and (row1 != -1)):
        # Swaps the colors.
        swap(row1, col1, app.selectedRow, app.selectedCol)

        # Resets the selected row and col and update the correct blocks.
        app.selectedRow = -1
        app.selectedCol = -1
        checkWin()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.rows = 4
app.cols = 4
app.board = makeList(app.rows, app.cols)
app.selectedRow = -1
app.selectedCol = -1

def makeBoard():
    for row in range(app.rows):
        for col in range(app.cols):
            # Gets a random blue value and the required x, y coordinates.
            blue = randrange(0, 256)
            x = 25 + col * 90
            y = 25 + row * 90

            # Create a rectangle with the correct blue value and store it in
            # the list.
            block = Rect(x, y, 70, 70, fill=rgb(0, 0, blue), borderWidth=5)
            block.blue = blue
            app.board[row][col] = block

makeBoard()

def swap(row1, col1, row2, col2):
    # Swaps the fills of the blocks at (row1, col1) and (row2, col2).
    color1 = app.board[row1][col1].blue
    color2 = app.board[row2][col2].blue
    app.board[row1][col1].blue = color2
    app.board[row2][col2].blue = color1
    app.board[row1][col1].fill = rgb(0, 0, color2)
    app.board[row2][col2].fill = rgb(0, 0, color1)

def findBlock(x, y):
    # Find which block was clicked.
    for row in range(app.rows):
        for col in range(app.cols):
            block = app.board[row][col]

            # If the block was clicked, set the selectedRow and selectedCol
            # and return the block.
            if (block.hits(x, y) == True):
                app.selectedRow = row
                app.selectedCol = col
                return block

    return None

def checkWin():
    # Checks each row to see if it is in decreasing order.
    for row in range(app.rows):
        for col in range(0, app.cols):
            if (col == 0):
                app.board[row][col].border = 'green'

            # Correct blocks are highlighted in green.
            elif (app.board[row][col].blue <= app.board[row][col - 1].blue):
                app.board[row][col].border = 'green'

            # Incorrect blocks are highlighted in red.
            else:
                app.board[row][col].border = 'red'

def onMousePress(mouseX, mouseY):
    row1 = -1
    col1 = -1

    # If a block was already clicked, stores its values.
    if (app.selectedRow != -1):
        row1 = app.selectedRow
        col1 = app.selectedCol
    block = findBlock(mouseX, mouseY)

    # Second time a block was clicked.
    if ((block != None) and (row1 != -1)):
        # Swaps the colors.
        swap(row1, col1, app.selectedRow, app.selectedCol)

        # Resets the selected row and col and update the correct blocks.
        app.selectedRow = -1
        app.selectedCol = -1
        checkWin()
",regular,1
2322,Essay editor,11.1.3,"app.synonyms = [ [ 'like', 'love' ],
                 [ 'code.', 'program.' ],
                 [ 'very', 'super' ],
                 [ 'fun.', 'cool.' ],
                 [ 'happy.', 'excited.' ],
                 [ 'great.', 'awesome.' ],
                 [ 'program', 'code' ] ]

# paper
Line(60, 0, 60, 400, fill=rgb(240, 205, 205))
Line(200, 50, 200, 350, fill='dimGray', lineWidth=400, dashes=(2, 57))

essay = Group()

def drawSentence():
    newX = 120
    newY = 40
    sentence = [ 'I', 'like', 'to', 'code.', 'It', 'is', 'very', 'fun.', 'When',
                 'I', 'program', 'I', 'feel', 'very', 'happy.', 'Python', 'is',
                 'great.' ]

    # Draws each word in the sentence and add it to the sentenceGroup.
    for i in range(len(sentence)):
        essay.add(
            Label(sentence[i], newX, newY, size=30, align='bottom')
            )

        # Gets the starting location of the next word.
        if (i != len(sentence) - 1):
            newX += 15 * (len(sentence[i]) + len(sentence[i + 1])) // 2 + 40
        else:
            newX += 15 * len(sentence[i]) + 50

        # Wraparound.
        if (newX >= 340):
            newY += 60
            newX = 120

drawSentence()

def onMousePress(mouseX, mouseY):
    # Check if we clicked on a word in the essay.
    wordLabel = essay.hitTest(mouseX, mouseY)
    if (wordLabel != None):
        # Check if the word has a synonym. If so, change its value and fill.
        ### (HINT: A word has a synonym if it is a word in one of the lists in
        #          app.synonyms. Use a loop!)
        ### Place Your Code Here ###
        pass
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.synonyms = [ [ 'like', 'love' ],
                 [ 'code.', 'program.' ],
                 [ 'very', 'super' ],
                 [ 'fun.', 'cool.' ],
                 [ 'happy.', 'excited.' ],
                 [ 'great.', 'awesome.' ],
                 [ 'program', 'code' ] ]

# paper
Line(60, 0, 60, 400, fill=rgb(240, 205, 205))
Line(200, 50, 200, 350, fill='dimGray', lineWidth=400, dashes=(2, 57))

essay = Group()

def drawSentence():
    newX = 120
    newY = 40
    sentence = [ 'I', 'like', 'to', 'code.', 'It', 'is', 'very', 'fun.', 'When',
                 'I', 'program', 'I', 'feel', 'very', 'happy.', 'Python', 'is',
                 'great.' ]

    # Draws each word in the sentence and add it to the sentenceGroup.
    for i in range(len(sentence)):
        essay.add(
            Label(sentence[i], newX, newY, size=30, align='bottom')
            )

        # Gets the starting location of the next word.
        if (i != len(sentence) - 1):
            newX += 15 * (len(sentence[i]) + len(sentence[i + 1])) // 2 + 40
        else:
            newX += 15 * len(sentence[i]) + 50

        # Wraparound.
        if (newX >= 340):
            newY += 60
            newX = 120

drawSentence()

def onMousePress(mouseX, mouseY):
    # Check if we clicked on a word in the essay.
    wordLabel = essay.hitTest(mouseX, mouseY)
    if (wordLabel != None):
        # Check if the word has a synonym. If so, change its value and fill.
        for i in range(len(app.synonyms)):
            if (app.synonyms[i][0] == wordLabel.value):
                wordLabel.value = app.synonyms[i][1]
                wordLabel.fill = 'dodgerBlue'
            elif (app.synonyms[i][1] == wordLabel.value):
                wordLabel.value = app.synonyms[i][0]
                wordLabel.fill = 'dodgerBlue'
",regular,1
2323,Advanced forest maker,11.1.3,"app.size = 40
app.rows = 10
app.cols = 10
app.land = makeList(app.rows, app.cols)
app.count = 0

def makeLand():
    # Loop over the rows and cols and create rectangles for each value in
    # app.land to draw the initial desert.
    for row in range(app.rows):
        for col in range(app.cols):
            ### Place Your Code Here ###
            # x =
            # y =
            # landRect =
            # app.land[row][col] =
            pass

makeLand()

gameOverMessage = Label('You have turned a desert into a forest!', 200, 180,
                        fill='honeydew', size=20, bold=True, visible=False)

def plantATree(x, y):
    # Draws a tree centered at (x, y).
    Rect(x, y + 15, 10, 15,
         fill=gradient('sienna', rgb(120, 50, 30), start='top'), align='center')
    RegularPolygon(x, y, 20, 3,
                   fill=gradient('green', rgb(0, 80, 0), start='top'))
    RegularPolygon(x, y - 15, 15, 3,
                   fill=gradient('lightGreen', 'darkGreen', start='top'))

def getForestColor(distance):
    # The closer the distance to the tree, the greener the color.
    if (distance <= 100):
        color = 'green'
    elif (distance <= 150):
        color = 'limeGreen'
    elif (distance <= 250):
        color = 'yellowGreen'
    else:
        color = 'khaki'
    return color

def isGameOver():
    # Check if the land is all covered with forest.
    ### (HINT: The land is all covered with forest if every rectangle
    #          is colored green.)
    ### Place Your Code Here ###

    return True

def onMousePress(mouseX, mouseY):
    # Plants a tree where you pressed and increments the count.
    plantATree(mouseX, mouseY)
    app.count += 1

    # Updates the ground type to account for the new tree.
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * app.size
            y = row * app.size

            # Gets the distance between the click and every cell in the grid.
            d = distance(mouseX, mouseY, x, y)

            # Uses the distance to get the new color for the cell.
            color = getForestColor(d)

            # If the land isn't already green, change its color.
            ### Place Your Code Here ###

    # When the game is over, displays the message and pauses the app.
    if (isGameOver() == True):
        gameOverMessage.visible = True
        gameOverMessage.toFront()
        Label('Trees planted: ' + str(app.count), 200, 220, fill='white',
              size=20, bold=True)
        app.paused = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.size = 40
app.rows = 10
app.cols = 10
app.land = makeList(app.rows, app.cols)
app.count = 0

def makeLand():
    # Loop over the rows and cols and create rectangles for each value in
    # app.land to draw the initial desert.
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * app.size
            y = row * app.size
            landRect = Rect(x, y, app.size, app.size, fill='khaki', opacity=90)
            app.land[row][col] = landRect

makeLand()

gameOverMessage = Label('You have turned a desert into a forest!', 200, 180,
                        fill='honeydew', size=20, bold=True, visible=False)

def plantATree(x, y):
    # Draws a tree centered at (x, y).
    Rect(x, y + 15, 10, 15,
         fill=gradient('sienna', rgb(120, 50, 30), start='top'), align='center')
    RegularPolygon(x, y, 20, 3,
                   fill=gradient('green', rgb(0, 80, 0), start='top'))
    RegularPolygon(x, y - 15, 15, 3,
                   fill=gradient('lightGreen', 'darkGreen', start='top'))

def getForestColor(distance):
    # The closer the distance to the tree, the greener the color.
    if (distance <= 100):
        color = 'green'
    elif (distance <= 150):
        color = 'limeGreen'
    elif (distance <= 250):
        color = 'yellowGreen'
    else:
        color = 'khaki'
    return color

def isGameOver():
    # Check if the land is all covered with forest.
    for row in range(app.rows):
        for col in range(app.cols):
            if (app.land[row][col].fill != 'green'):
                return False

    return True

def onMousePress(mouseX, mouseY):
    # Plants a tree where you pressed and increments the count.
    plantATree(mouseX, mouseY)
    app.count += 1

    # Updates the ground type to account for the new tree.
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * app.size
            y = row * app.size

            # Gets the distance between the click and every cell in the grid.
            d = distance(mouseX, mouseY, x, y)

            # Uses the distance to get the new color for the cell.
            color = getForestColor(d)

            # If the land isn't already green, change its color.
            if (app.land[row][col].fill != 'green'):
                app.land[row][col].fill = color

    # When the game is over, displays the message and pauses the app.
    if (isGameOver() == True):
        gameOverMessage.visible = True
        gameOverMessage.toFront()
        Label('Trees planted: ' + str(app.count), 200, 220, fill='white',
              size=20, bold=True)
        app.paused = True
",regular,2
2324,Lights out,11.1.3,"app.background = 'black'

# Define the rows and cols properties to properly define the 2D lightbulb
# list so it can hold the proper number of lightbulbs.
### Fix Your Code Here ###
app.rows = 0
app.cols = 0

app.lights = makeList(app.rows, app.cols)
app.lightsOut = False

Label('Moves:', 190, 40, fill='white', size=20)
moves = Label(0, 240, 40, fill='white', size=20)

def createLightBulb(x, y):
    lightBulb = Group(
        Circle(x, y, 29, fill='gainsboro'),
        Oval(x + 15, y - 15, 8, 20, fill='white', rotateAngle=-50, opacity=70),
        Polygon(x - 27, y + 10, x + 27, y + 10, x + 12, y + 50, x - 12, y + 50,
                fill='gainsboro'),
        Polygon(x - 7, y + 52, x - 12, y + 5, x - 6, y + 10, x, y + 5,
                x + 6, y + 10, x + 12, y + 5, x + 7, y + 52, fill=None,
                border='dimGray'),
        Oval(x, y + 65, 10, 5, fill='gray'),
        Polygon(x - 10, y + 50, x + 10, y + 50, x + 6, y + 65, x - 6, y + 65,
                fill='goldenrod'),
        Line(x, y + 55, x, y + 65, fill='white', lineWidth=15, dashes=(1, 2))
        )

    # Adds a custom property that references a circle and return the lightBulb.
    lightBulb.light = Circle(x, y, 45, fill=gradient('yellow', 'cornSilk'),
                             opacity=75)
    return lightBulb

def drawLights():
    startX = 100
    startY = 120
    lightSize = 100

    # Loop over rows and cols and calculate the x and y values. For each
    # position, create a lightbulb and store its return value in app.lights.
    ### Place Your Code Here ###

drawLights()

def turnLight(row, col):
    # This allows us to access the lightbulbs above, below, to the left, and to
    # the right of the lightbulb we clicked on.
    rowChange = [ 0, -1, 1, 0, 0 ]
    colChange = [ 0, 0, 0, -1, 1 ]

    # Changes lights near the row, col from on to off or off to on.
    for i in range(len(rowChange)):
        # These are either +1, 0, or -1.
        dRow, dCol = rowChange[i], colChange[i]

        # As long as row + dRow and col + dCol are valid indices for app.lights,
        # switches the visibility of the light at those indices.
        if ((row + dRow >= 0) and (row + dRow <= 2) and
            (col + dCol >= 0) and (col + dCol <= 2)):
            lightBulb = app.lights[row + dRow][col + dCol]
            lightBulb.light.visible = not lightBulb.light.visible

def checkWin():
    # Check if all the lights are off.
    for row in range(app.rows):
        for col in range(app.cols):
            lightbulb = app.lights[row][col]
            light = lightbulb.light

            # If the light is visible return False.
            ### Place Your Code Here ###

    return True

def findLight(mouseX, mouseY):
    # Check each light to see if it was clicked. If it was, call turnLight
    # and return the light.
    ### Place Your Code Here ###
    pass

def onMousePress(mouseX, mouseY):
    # Only changes the state of the lights when the player hasn't won.
    if (app.lightsOut == False):
       light = findLight(mouseX, mouseY)
       if (light != None):
            moves.value += 1

    # Draws the winning screen when the player wins.
    if (checkWin() == True):
        app.lightsOut = True
        Rect(0, 0, 400, 400, opacity=70)
        Label('Lights Out!', 200, 200, fill='gold', size=40, font='monospace',
              bold=True)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

# Define the rows and cols properties to properly define the 2D lightbulb
# list so it can hold the proper number of lightbulbs.
app.rows = 3
app.cols = 3

app.lights = makeList(app.rows, app.cols)
app.lightsOut = False

Label('Moves:', 190, 40, fill='white', size=20)
moves = Label(0, 240, 40, fill='white', size=20)

def createLightBulb(x, y):
    lightBulb = Group(
        Circle(x, y, 29, fill='gainsboro'),
        Oval(x + 15, y - 15, 8, 20, fill='white', rotateAngle=-50, opacity=70),
        Polygon(x - 27, y + 10, x + 27, y + 10, x + 12, y + 50, x - 12, y + 50,
                fill='gainsboro'),
        Polygon(x - 7, y + 52, x - 12, y + 5, x - 6, y + 10, x, y + 5,
                x + 6, y + 10, x + 12, y + 5, x + 7, y + 52, fill=None,
                border='dimGray'),
        Oval(x, y + 65, 10, 5, fill='gray'),
        Polygon(x - 10, y + 50, x + 10, y + 50, x + 6, y + 65, x - 6, y + 65,
                fill='goldenrod'),
        Line(x, y + 55, x, y + 65, fill='white', lineWidth=15, dashes=(1, 2))
        )

    # Adds a custom property that references a circle and return the lightBulb.
    lightBulb.light = Circle(x, y, 45, fill=gradient('yellow', 'cornSilk'),
                             opacity=75)
    return lightBulb

def drawLights():
    startX = 100
    startY = 120
    lightSize = 100

    # Loop over rows and cols and calculate the x and y values. For each
    # position, create a lightbulb and store its return value in app.lights.
    for row in range(app.rows):
        for col in range(app.cols):
            x = startX + col * lightSize
            y = startY + row * lightSize
            app.lights[row][col] = createLightBulb(x, y)

drawLights()

def turnLight(row, col):
    # This allows us to access the lightbulbs above, below, to the left, and to
    # the right of the lightbulb we clicked on.
    rowChange = [ 0, -1, 1, 0, 0 ]
    colChange = [ 0, 0, 0, -1, 1 ]

    # Changes lights near the row, col from on to off or off to on.
    for i in range(len(rowChange)):
        # These are either +1, 0, or -1.
        dRow, dCol = rowChange[i], colChange[i]

        # As long as row + dRow and col + dCol are valid indices for app.lights,
        # switches the visibility of the light at those indices.
        if ((row + dRow >= 0) and (row + dRow <= 2) and
            (col + dCol >= 0) and (col + dCol <= 2)):
            lightBulb = app.lights[row + dRow][col + dCol]
            lightBulb.light.visible = not lightBulb.light.visible

def checkWin():
    # Check if all the lights are off.
    for row in range(app.rows):
        for col in range(app.cols):
            lightbulb = app.lights[row][col]
            light = lightbulb.light

            # If the light is visible return False.
            if (light.visible == True):
                return False

    return True

def findLight(mouseX, mouseY):
    # Check each light to see if it was clicked. If it was, call turnLight
    # and return the light.
    for row in range(app.rows):
        for col in range(app.cols):
            light = app.lights[row][col]
            if (light.hits(mouseX, mouseY) == True):
                turnLight(row, col)
                return light

    return None

def onMousePress(mouseX, mouseY):
    # Only changes the state of the lights when the player hasn't won.
    if (app.lightsOut == False):
       light = findLight(mouseX, mouseY)
       if (light != None):
            moves.value += 1

    # Draws the winning screen when the player wins.
    if (checkWin() == True):
        app.lightsOut = True
        Rect(0, 0, 400, 400, opacity=70)
        Label('Lights Out!', 200, 200, fill='gold', size=40, font='monospace',
              bold=True)
",regular,3
2325,Notes exercise 1,11.2.1.1,"# Most of the code for Concentration has been given to you.
# You will only write the code for onStep.
# A detailed explanation of how to write this code is provided in the notes!
# (1) Write the code to check if two cards match.
# (2) Write the code to check if the game is over.
# That's it, let's code!

app.rows = 3
app.cols = 4
app.cards = makeList(app.rows, app.cols)
app.firstCard = None
app.secondCard = None
app.stepsPerSecond = 1

Label('Concentration', 200, 20, size=30, bold=True)
Label('Time Remaining: ', 180, 50, size=20)
timer = Label(30, 270, 50, size=20)
Label('Try to match all of the cards before time runs out', 200, 80, size=16)

def setColor(color):
    row = randrange(0, app.rows)
    col = randrange(0, app.cols)
    while (app.cards[row][col] != None):
        row = randrange(0, app.rows)
        col = randrange(0, app.cols)
    x = 20 + col * 100
    y = 100 + row * 100
    r = Rect(x, y, 60, 80, fill='darkGray', border='black', borderWidth=4)
    r.color = color
    app.cards[row][col] = r

def initializeCards():
    colors = [ 'red', 'lightBlue', 'blue', 'orange', 'pink', 'purple' ]
    for color in colors:
        setColor(color)
        setColor(color)

initializeCards()

def findCard(x, y):
    for row in range(app.rows):
        for col in range(app.cols):
            card = app.cards[row][col]
            if (card.hits(x, y) == True):
                return card
    return None

def onMousePress(mouseX, mouseY):
    card = findCard(mouseX, mouseY)
    if ((card != None) and (card.fill == 'darkGray')):
        if (app.firstCard == None):
            app.firstCard = card
            card.fill = card.color
        elif (app.secondCard == None):
            app.secondCard = card
            card.fill = card.color

def checkWin():
    for row in range(app.rows):
        for col in range(app.cols):
            if (app.cards[row][col].fill == 'darkGray'):
                return False
    return True

def onStep():
    timer.value -= 1
    # Check if we've clicked on two cards.
    if (app.secondCard != None):
        # Compare the fills of the cards.
        # If they don't match, set the fills to darkGray.
        # If they do match, set the borders to lime.
        # Either way, reset both card variables to None.
        ### Place Your Code Here ###
        pass

    # Check if the game has been won by calling the checkWin function and
    # draw the game win screen.
    if (checkWin() == True):
        Rect(0, 100, 400, 200, opacity=50)
        Label('YOU WIN', 200, 200, fill='white', size=40)
        app.stop()

    # Check if the game has been lost by checking timer.value and
    # draw the game lose screen.
    ### Place Your Code Here ###
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Most of the code for Concentration has been given to you.
# You will only write the code for onStep.
# A detailed explanation of how to write this code is provided in the notes!
# (1) Write the code to check if two cards match.
# (2) Write the code to check if the game is over.
# That's it, let's code!

app.rows = 3
app.cols = 4
app.cards = makeList(app.rows, app.cols)
app.firstCard = None
app.secondCard = None
app.stepsPerSecond = 1

Label('Concentration', 200, 20, size=30, bold=True)
Label('Time Remaining: ', 180, 50, size=20)
timer = Label(30, 270, 50, size=20)
Label('Try to match all of the cards before time runs out', 200, 80, size=16)

def setColor(color):
    row = randrange(0, app.rows)
    col = randrange(0, app.cols)
    while (app.cards[row][col] != None):
        row = randrange(0, app.rows)
        col = randrange(0, app.cols)
    x = 20 + col * 100
    y = 100 + row * 100
    r = Rect(x, y, 60, 80, fill='darkGray', border='black', borderWidth=4)
    r.color = color
    app.cards[row][col] = r

def initializeCards():
    colors = [ 'red', 'lightBlue', 'blue', 'orange', 'pink', 'purple' ]
    for color in colors:
        setColor(color)
        setColor(color)

initializeCards()

def findCard(x, y):
    for row in range(app.rows):
        for col in range(app.cols):
            card = app.cards[row][col]
            if (card.hits(x, y) == True):
                return card
    return None

def onMousePress(mouseX, mouseY):
    card = findCard(mouseX, mouseY)
    if ((card != None) and (card.fill == 'darkGray')):
        if (app.firstCard == None):
            app.firstCard = card
            card.fill = card.color
        elif (app.secondCard == None):
            app.secondCard = card
            card.fill = card.color

def checkWin():
    for row in range(app.rows):
        for col in range(app.cols):
            if (app.cards[row][col].fill == 'darkGray'):
                return False
    return True

def onStep():
    timer.value -= 1
    # Check if we've clicked on two cards.
    if (app.secondCard != None):
        # Compare the fills of the cards.
        # If they don't match, set the fills to darkGray.
        # If they do match, set the borders to lime.
        # Either way, reset both card variables to None.
        if (app.firstCard.fill != app.secondCard.fill):
            app.firstCard.fill = 'darkGray'
            app.secondCard.fill = 'darkGray'
        else:
            app.firstCard.border = 'lime'
            app.secondCard.border = 'lime'

        app.firstCard = None
        app.secondCard = None

    # Check if the game has been won by calling the checkWin function and
    # draw the game win screen.
    if (checkWin() == True):
        Rect(0, 100, 400, 200, opacity=50)
        Label('YOU WIN', 200, 200, fill='white', size=40)
        app.stop()

    # Check if the game has been lost by checking timer.value and
    # draw the game lose screen.
    if (timer.value == 0):
        Rect(0, 100, 400, 200, opacity=50)
        Label('GAME OVER', 200, 200, fill='white', size=40)
        app.stop()
",regular,1
2326,Tic Tac Toe Demo,11.2.2,"app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            # Calculate x, y for each row, col and add a rectangle to
            # the board group.
            x = col * cellSize
            y = row * cellSize
            board.add(
                Rect(x, y, cellSize, cellSize, fill='skyBlue',
                     border='lightCyan', borderWidth=5)
                )

            # Calculate the center of each cell and add a label there.
            # Also assign the label into app.board and add it to the board Group.
            cx = x + cellSize / 2
            cy = y + cellSize / 2
            move = Label('', cx, cy, size=90, bold=True)
            app.board[row][col] = move
            board.add(move)

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draw the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Define gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draw and set gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False

def onKeyPress(key):
    # When space is pressed and the game is not already playing,
    # make the newGameScreen invisible and set isGamePlaying.
    if (key == 'space'):
        if (app.isGamePlaying == False):
            newGameScreen.visible = False
            app.isGamePlaying = True

    # When r is pressed, restart the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True

def isValidMove(row, col):
    # Check if the grid for the next step is empty.
    if (app.board[row][col].value == ''):
        return True
    else:
        return False

def makeMove(row, col):
    # Update current move.
    app.board[row][col].value = app.player
    if (app.player == 'O'):
        color = 'steelBlue'
    else:
        color = 'white'

    app.board[row][col].fill = color

def findCell(mouseX, mouseY):
    size = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * size
            y = row * size

            # If the mouseX, mouseY is between the boundaries of a cell,
            # return the coordinates of that cell.
            if ((x <= mouseX) and (mouseX <= x + size) and
                (y <= mouseY) and (mouseY <= y + size)):
                return [ row, col ]

def onMousePress(mouseX, mouseY):
    if (app.isGamePlaying == True):
        # If the cell clicked on is empty, make that move.
        position = findCell(mouseX, mouseY)
        row = position[0]
        col = position[1]

        if (isValidMove(row,col) == True):
            makeMove(row, col)

            # If the game ends, update gameOver screen.
            if (checkGameWin() == True):
                gameOver('Win')
            elif (checkTie() == True):
                gameOver('Tie')

            # Change player turn.
            if (app.player == 'O'):
                app.player = 'X'
            else:
                app.player = 'O'

            # Update nextPlayer value.
            nextPlayer.value = app.player

def getColumn(board, col):
    # Return a list of all values in the column.
    colList = [ ]
    for row in range(app.rows):
        colList.append(board[row][col])
    return colList

def checkWin(colRowOrDiag):
    # The input is either a row, column, or diagonal list that a win could
    # be on. Return a boolean that states whether or not there is a winning
    # condition given the input.
    count = 0
    for label in colRowOrDiag:
        if (label.value == app.player):
            count += 1

    if (count == 3):
        return True
    else:
        return False

def checkTie():
    # If there are no empty spaces left, there's a tie.
    for row in range(app.rows):
        for col in range(app.cols):
            if (app.board[row][col].value == ''):
                return False
    return True

def checkGameWin():
    # Check if there is a winning row.
    for row in app.board:
        if (checkWin(row) == True):
            return True

    # Check if there is a winning column.
    for col in range(3):
        colList = getColumn(app.board, col)
        if (checkWin(colList) == True):
            return True

    # Get top-left to bottom-right diagonal.
    diagonalLeftToRight = [ app.board[0][0], app.board[1][1], app.board[2][2] ]

    # Get top-right to bottom-left diagonal.
    diagonalRightToLeft = [ app.board[0][2], app.board[1][1], app.board[2][0] ]

    # Check if there is a winning diagonal.
    if (checkWin(diagonalLeftToRight) == True):
        return True
    if (checkWin(diagonalRightToLeft) == True):
        return True

    return False

def gameOver(winOrTie):
    if (winOrTie == 'Win'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Winner: ' + app.player + ' !'
    elif (winOrTie == 'Tie'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Tie!'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            # Calculate x, y for each row, col and add a rectangle to
            # the board group.
            x = col * cellSize
            y = row * cellSize
            board.add(
                Rect(x, y, cellSize, cellSize, fill='skyBlue',
                     border='lightCyan', borderWidth=5)
                )

            # Calculate the center of each cell and add a label there.
            # Also assign the label into app.board and add it to the board Group.
            cx = x + cellSize / 2
            cy = y + cellSize / 2
            move = Label('', cx, cy, size=90, bold=True)
            app.board[row][col] = move
            board.add(move)

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draw the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Define gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draw and set gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False

def onKeyPress(key):
    # When space is pressed and the game is not already playing,
    # make the newGameScreen invisible and set isGamePlaying.
    if (key == 'space'):
        if (app.isGamePlaying == False):
            newGameScreen.visible = False
            app.isGamePlaying = True

    # When r is pressed, restart the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True

def isValidMove(row, col):
    # Check if the grid for the next step is empty.
    if (app.board[row][col].value == ''):
        return True
    else:
        return False

def makeMove(row, col):
    # Update current move.
    app.board[row][col].value = app.player
    if (app.player == 'O'):
        color = 'steelBlue'
    else:
        color = 'white'

    app.board[row][col].fill = color

def findCell(mouseX, mouseY):
    size = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * size
            y = row * size

            # If the mouseX, mouseY is between the boundaries of a cell,
            # return the coordinates of that cell.
            if ((x <= mouseX) and (mouseX <= x + size) and
                (y <= mouseY) and (mouseY <= y + size)):
                return [ row, col ]

def onMousePress(mouseX, mouseY):
    if (app.isGamePlaying == True):
        # If the cell clicked on is empty, make that move.
        position = findCell(mouseX, mouseY)
        row = position[0]
        col = position[1]

        if (isValidMove(row,col) == True):
            makeMove(row, col)

            # If the game ends, update gameOver screen.
            if (checkGameWin() == True):
                gameOver('Win')
            elif (checkTie() == True):
                gameOver('Tie')

            # Change player turn.
            if (app.player == 'O'):
                app.player = 'X'
            else:
                app.player = 'O'

            # Update nextPlayer value.
            nextPlayer.value = app.player

def getColumn(board, col):
    # Return a list of all values in the column.
    colList = [ ]
    for row in range(app.rows):
        colList.append(board[row][col])
    return colList

def checkWin(colRowOrDiag):
    # The input is either a row, column, or diagonal list that a win could
    # be on. Return a boolean that states whether or not there is a winning
    # condition given the input.
    count = 0
    for label in colRowOrDiag:
        if (label.value == app.player):
            count += 1

    if (count == 3):
        return True
    else:
        return False

def checkTie():
    # If there are no empty spaces left, there's a tie.
    for row in range(app.rows):
        for col in range(app.cols):
            if (app.board[row][col].value == ''):
                return False
    return True

def checkGameWin():
    # Check if there is a winning row.
    for row in app.board:
        if (checkWin(row) == True):
            return True

    # Check if there is a winning column.
    for col in range(3):
        colList = getColumn(app.board, col)
        if (checkWin(colList) == True):
            return True

    # Get top-left to bottom-right diagonal.
    diagonalLeftToRight = [ app.board[0][0], app.board[1][1], app.board[2][2] ]

    # Get top-right to bottom-left diagonal.
    diagonalRightToLeft = [ app.board[0][2], app.board[1][1], app.board[2][0] ]

    # Check if there is a winning diagonal.
    if (checkWin(diagonalLeftToRight) == True):
        return True
    if (checkWin(diagonalRightToLeft) == True):
        return True

    return False

def gameOver(winOrTie):
    if (winOrTie == 'Win'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Winner: ' + app.player + ' !'
    elif (winOrTie == 'Tie'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Tie!'
",demo,0
2328,Tic Tac Toe Part 2,11.2.2,"app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            #_BLOCK_INITIALIZE_GAME

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draws the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Defines gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draws and sets gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False


def isValidMove(row, col):
    #### START OF BLOCK VALID_MOVE ####

    # Check if the grid for the next step is empty.
    ### Place Your Code Here ###
    pass

    #### END OF BLOCK ####

def makeMove(row, col):
    #### START OF BLOCK MAKE_MOVE ####

    # Set the value at row, col to app.player and set the color depending on
    # if the player is 'X' or 'O'.
    ### Place Your Code Here ###
    pass

    #### END OF BLOCK ####

def findCell(mouseX, mouseY):
    size = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * size
            y = row * size

            # If the mouseX, mouseY is between the boundaries of a cell,
            # returns the coordinates of that cell.
            if ((x <= mouseX) and (mouseX <= x + size) and
                (y <= mouseY) and (mouseY <= y + size)):
                return [ row, col ]

def onMousePress(mouseX, mouseY):
    if (app.isGamePlaying == True):
        position = findCell(mouseX, mouseY)
        row = position[0]
        col = position[1]
        if (isValidMove(row, col) == True):
            makeMove(row, col)

            # Changes the player turn.
            if (app.player == 'O'):
                app.player = 'X'
            else:
                app.player = 'O'

            # Updates the nextPlayer value.
            nextPlayer.value = app.player

def onKeyPress(key):
    #_BLOCK_KEY_PRESS

    # When r is pressed, restarts the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            # Calculate x, y for each row, col and add a rectangle to
            # the board group.
            x = col * cellSize
            y = row * cellSize
            board.add(
                Rect(x, y, cellSize, cellSize, fill='skyBlue',
                    border='lightCyan', borderWidth=5)
                )

            # Calculate the center of each cell and add a label there.
            # Also assign the label into app.board and add it to the board Group.
            cx = x + cellSize / 2
            cy = y + cellSize / 2
            move = Label('', cx, cy, size=90, bold=True)
            app.board[row][col] = move
            board.add(move)

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draws the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Defines gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draws and sets gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False


def isValidMove(row, col):
    #### START OF BLOCK VALID_MOVE ####
    # Check if the grid for the next step is empty.
    if (app.board[row][col].value == ''):
        return True
    else:
        return False

    #### END OF BLOCK ####

def makeMove(row, col):
    #### START OF BLOCK MAKE_MOVE ####
    # Set the value at row, col to app.player and set the color depending on
    # if the player is 'X' or 'O'.
    app.board[row][col].value = app.player
    if (app.player == 'O'):
        color = 'steelBlue'
    else:
        color = 'white'

    app.board[row][col].fill = color

    #### END OF BLOCK ####

def findCell(mouseX, mouseY):
    size = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * size
            y = row * size

            # If the mouseX, mouseY is between the boundaries of a cell,
            # returns the coordinates of that cell.
            if ((x <= mouseX) and (mouseX <= x + size) and
                (y <= mouseY) and (mouseY <= y + size)):
                return [ row, col ]

def onMousePress(mouseX, mouseY):
    if (app.isGamePlaying == True):
        position = findCell(mouseX, mouseY)
        row = position[0]
        col = position[1]
        if (isValidMove(row, col) == True):
            makeMove(row, col)

            # Changes the player turn.
            if (app.player == 'O'):
                app.player = 'X'
            else:
                app.player = 'O'

            # Updates the nextPlayer value.
            nextPlayer.value = app.player

def onKeyPress(key):
    # Start a new game or restart the game.
    # When space is pressed and the game is not already playing,
    # make the newGameScreen invisible and set isGamePlaying.
    if (key == 'space'):
        if (app.isGamePlaying == False):
            newGameScreen.visible = False
            app.isGamePlaying = True

    # When r is pressed, restarts the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True
",chain,1
2329,Tic Tac Toe Part 3,11.2.2,"app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            #_BLOCK_INITIALIZE_GAME

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draws the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Defines gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draws and setss gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False


def isValidMove(row, col):
    #_BLOCK_VALID_MOVE

def makeMove(row, col):
    #_BLOCK_MAKE_MOVE

def findCell(mouseX, mouseY):
    size = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * size
            y = row * size

            # If the mouseX, mouseY is between the boundaries of a cell,
            # returns the coordinates of that cell.
            if ((x <= mouseX) and (mouseX <= x + size) and
                (y <= mouseY) and (mouseY <= y + size)):
                return [ row, col ]

def getColumn(board, col):
    # Return a list of all values in the column.
    colList = [ ]
    ### (HINT: Append the element at col for each row in the board.)
    ### Place Your Code Here ###

    return colList

def checkWin(colRowOrDiag):
    # The input is either a row, column, or diagonal list that a win could
    # be on. Return a boolean that states whether or not there is a winning
    # condition given the input.
    count = 0
    ### (HINT: There is a winning condition if every cell in the input has
    #          the same label as the player!)
    ### Place Your Code Here ###

def checkTie():
    # If there are no empty spaces left, there's a tie.
    for row in range(app.rows):
        for col in range(app.cols):
            if (app.board[row][col].value == ''):
                return False
    return True

def checkGameWin():
    # Checks if there is a winning row.
    for row in app.board:
        if (checkWin(row) == True):
            return True

    # Checks if there is a winning column.
    for col in range(3):
        colList = getColumn(app.board, col)
        if (checkWin(colList) == True):
            return True

    # Gets the top-left to bottom-right diagonal.
    diagonalLeftToRight = [ app.board[0][0], app.board[1][1], app.board[2][2] ]

    # Gets the top-right to bottom-left diagonal.
    diagonalRightToLeft = [ app.board[0][2], app.board[1][1], app.board[2][0] ]

    # Checks if there is a winning diagonal.
    if (checkWin(diagonalLeftToRight) == True):
        return True
    if (checkWin(diagonalRightToLeft) == True):
        return True

    return False

def gameOver(winOrTie):
    if (winOrTie == 'Win'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Winner: ' + app.player + ' !'
    elif (winOrTie == 'Tie'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Tie!'

def onMousePress(mouseX, mouseY):
    if (app.isGamePlaying == True):
        position = findCell(mouseX, mouseY)
        row = position[0]
        col = position[1]
        if (isValidMove(row, col) == True):
            makeMove(row, col)

            # If the game ends, update gameOver screen.
            if (checkGameWin() == True):
                gameOver('Win')
            elif (checkTie() == True):
                gameOver('Tie')

            # Changes the player turn.
            if (app.player == 'O'):
                app.player = 'X'
            else:
                app.player = 'O'

            # Updates the nextPlayer value.
            nextPlayer.value = app.player

def onKeyPress(key):
    #_BLOCK_KEY_PRESS

    # When r is pressed, restarts the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            # Calculate x, y for each row, col and add a rectangle to
            # the board group.
            x = col * cellSize
            y = row * cellSize
            board.add(
                Rect(x, y, cellSize, cellSize, fill='skyBlue',
                    border='lightCyan', borderWidth=5)
                )

            # Calculate the center of each cell and add a label there.
            # Also assign the label into app.board and add it to the board Group.
            cx = x + cellSize / 2
            cy = y + cellSize / 2
            move = Label('', cx, cy, size=90, bold=True)
            app.board[row][col] = move
            board.add(move)

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draws the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Defines gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draws and setss gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False


def isValidMove(row, col):
    # Check if the grid for the next step is empty.
    if (app.board[row][col].value == ''):
        return True
    else:
        return False

def makeMove(row, col):
    # Set the value at row, col to app.player and set the color depending on
    # if the player is 'X' or 'O'.
    app.board[row][col].value = app.player
    if (app.player == 'O'):
        color = 'steelBlue'
    else:
        color = 'white'

    app.board[row][col].fill = color

def findCell(mouseX, mouseY):
    size = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            x = col * size
            y = row * size

            # If the mouseX, mouseY is between the boundaries of a cell,
            # returns the coordinates of that cell.
            if ((x <= mouseX) and (mouseX <= x + size) and
                (y <= mouseY) and (mouseY <= y + size)):
                return [ row, col ]

def getColumn(board, col):
    # Return a list of all values in the column.
    colList = [ ]
    for row in range(app.rows):
        colList.append(board[row][col])

    return colList

def checkWin(colRowOrDiag):
    # The input is either a row, column, or diagonal list that a win could
    # be on. Return a boolean that states whether or not there is a winning
    # condition given the input.
    count = 0
    for label in colRowOrDiag:
        if (label.value == app.player):
            count += 1

    if (count == 3):
        return True
    else:
        return False

def checkTie():
    # If there are no empty spaces left, there's a tie.
    for row in range(app.rows):
        for col in range(app.cols):
            if (app.board[row][col].value == ''):
                return False
    return True

def checkGameWin():
    # Checks if there is a winning row.
    for row in app.board:
        if (checkWin(row) == True):
            return True

    # Checks if there is a winning column.
    for col in range(3):
        colList = getColumn(app.board, col)
        if (checkWin(colList) == True):
            return True

    # Gets the top-left to bottom-right diagonal.
    diagonalLeftToRight = [ app.board[0][0], app.board[1][1], app.board[2][2] ]

    # Gets the top-right to bottom-left diagonal.
    diagonalRightToLeft = [ app.board[0][2], app.board[1][1], app.board[2][0] ]

    # Checks if there is a winning diagonal.
    if (checkWin(diagonalLeftToRight) == True):
        return True
    if (checkWin(diagonalRightToLeft) == True):
        return True

    return False

def gameOver(winOrTie):
    if (winOrTie == 'Win'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Winner: ' + app.player + ' !'
    elif (winOrTie == 'Tie'):
        app.isGameOn = False
        gameOverScreen.visible = True
        winningMessage.value = 'Tie!'

def onMousePress(mouseX, mouseY):
    if (app.isGamePlaying == True):
        position = findCell(mouseX, mouseY)
        row = position[0]
        col = position[1]
        if (isValidMove(row, col) == True):
            makeMove(row, col)

            # If the game ends, update gameOver screen.
            if (checkGameWin() == True):
                gameOver('Win')
            elif (checkTie() == True):
                gameOver('Tie')

            # Changes the player turn.
            if (app.player == 'O'):
                app.player = 'X'
            else:
                app.player = 'O'

            # Updates the nextPlayer value.
            nextPlayer.value = app.player

def onKeyPress(key):
    # Start a new game or restart the game.
    # When space is pressed and the game is not already playing,
    # make the newGameScreen invisible and set isGamePlaying.
    if (key == 'space'):
        if (app.isGamePlaying == False):
            newGameScreen.visible = False
            app.isGamePlaying = True

    # When r is pressed, restarts the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True
",chain,2
2327,Tic Tac Toe Part 1,11.2.2,"app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            #### START OF BLOCK INITIALIZE_GAME ####

            # Calculate x, y for each row, col and add a rectangle to
            # the board group.
            ### Place Your Code Here ###

            # Calculate the center of each cell and add a label there. Also
            # assign the label into app.board and add it to the board Group.
            ### (HINT: Add cellSize / 2 to x to get the center of the cell.)
            ### Place Your Code Here ###
            pass

            #### END OF BLOCK ####

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draws the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Defines gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draws and setss gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False

def onKeyPress(key):
    #### START OF BLOCK KEY_PRESS ####

    # Start a new game or restart the game.
    # When space is pressed and the game is not already playing,
    # make the newGameScreen invisible and set isGamePlaying.
    ### Place Your Code Here ###

    #### END OF BLOCK ####

    # When r is pressed, restarts the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.rows = 3
app.cols = 3
app.board = makeList(app.rows, app.cols)
board = Group()

def initializeGame():
    # Create the board and initialize game properties.
    cellSize = 400 / 3
    for row in range(app.rows):
        for col in range(app.cols):
            #### START OF BLOCK INITIALIZE_GAME ####
            # Calculate x, y for each row, col and add a rectangle to
            # the board group.
            x = col * cellSize
            y = row * cellSize
            board.add(
                Rect(x, y, cellSize, cellSize, fill='skyBlue',
                    border='lightCyan', borderWidth=5)
                )

            # Calculate the center of each cell and add a label there. Also
            # assign the label into app.board and add it to the board Group.
            cx = x + cellSize / 2
            cy = y + cellSize / 2
            move = Label('', cx, cy, size=90, bold=True)
            app.board[row][col] = move
            board.add(move)

            #### END OF BLOCK ####

    # The current player: 'O' or 'X'.
    app.player = 'O'

    # The game status.
    app.isGamePlaying = False

initializeGame()

# Draws the label indicating nextPlayer.
Rect(120, 5, 160, 30, fill='hotPink', opacity=50)
Label('Next Player: ', 190, 20, fill='white', size=15, bold=True)
nextPlayer = Label(app.player, 250, 20, fill='white', size=15, bold=True)

# Defines gameOver and newGame screens.
newGameScreen = Group(
    Rect(0, 100, 400, 200, fill='aliceBlue', opacity=70),
    Label('Welcome to Tic-Tac-Toe!', 200, 190, fill='darkOrange', size=30,
          bold=True),
    Label('press space to start a new game', 200, 220, fill='darkOrange',
          size=15, bold=True)
    )

# Draws and setss gameOverScreen.
gameOverScreen = Group(
    Rect(0, 0, 400, 400, fill='aliceBlue', opacity=70),
    Label('press ""r"" to restart', 200, 250, fill='darkOrange', size=20, bold=True)
    )

winningMessage = Label('', 200, 200, fill='darkOrange', size=50, bold=True)
gameOverScreen.add(winningMessage)
gameOverScreen.visible = False

def onKeyPress(key):
    #### START OF BLOCK KEY_PRESS ####
    # Start a new game or restart the game.
    # When space is pressed and the game is not already playing,
    # make the newGameScreen invisible and set isGamePlaying.
    if (key == 'space'):
        if (app.isGamePlaying == False):
            newGameScreen.visible = False
            app.isGamePlaying = True

    #### END OF BLOCK ####

    # When r is pressed, restarts the game.
    if (key == 'r'):
        gameOverScreen.visible = False
        board.clear()
        initializeGame()
        nextPlayer.value = app.player
        app.isGamePlaying = True
",chain,1
2330,Battleship Demo,11.2.3,"app.background = 'black'

app.gameState = 'setup'

Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            # Draw a rectangular cell for this row and column.
            x0 = startX + col * gridSize
            y0 = startY + row * gridSize
            cell = Rect(x0, y0, gridSize, gridSize, fill='mediumBlue',
                        border='white', borderWidth=1)

            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    # Find the cell that the point (x, y) lies in.
    for row in range(8):
        for col in range(8):
            cell = board[row][col]
            if (cell.hits(x, y) == True):
                return cell

def isAdjacent(cell, cellClicked):
    # Check if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    # If either rows are equal and the columns are within 1, or
    # columns are equal and the rows are within 1, they are adjacent.
    if (((cellRow == clickedRow) and (abs(cellCol - clickedCol) == 1)) or
        ((cellCol == clickedCol) and (abs(cellRow - clickedRow) == 1))):
        return True
    else:
        return False

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    # Place a player ship at the location if it will be a legal move.
    cell = findCell(mouseX, mouseY, app.playerBoard)
    if (isLegalShip(cell, app.playerBoard, app.shipPartsPlaced) == True):
        # Place the ship.
        cell.status = 'hiddenShip'
        cell.fill = 'grey'
        app.shipPartsPlaced += 1

def placeEnemies():
    # Randomly place enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Place the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then create 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enter playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'

    # Otherwise play a turn.
    elif (app.gameState == 'play'):
        playTurn(mouseX, mouseY)

def playTurn(mouseX, mouseY):
    # On each turn, see if the cell clicked was valid.
    cell = findCell(mouseX, mouseY, app.enemyBoard)
    if (sinkOrMiss(cell) == True):
        enemyTurn()

    # Then check if the game ends.
    if (checkWin(app.enemyBoard) == True):
        Rect(0, 160, 400, 90, fill='green')
        Label('YOU WON!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def enemyTurn():
    # On an enemy turn, randomly pick a new cell to attack.
    newSpot = False
    while (newSpot == False):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.playerBoard[randomRow][randomCol]

        # If the cell has not be attacked yet, end the loop.
        if ((randomCell.status == 'ocean') or (randomCell.status == 'hiddenShip')):
            newSpot = True

    # Check if the attacked cell is a ship then check if the game ends.
    sinkOrMiss(randomCell)
    if (checkWin(app.playerBoard) == True):
        Rect(0, 160, 400, 90, fill='red')
        Label('YOU LOST!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def sinkOrMiss(cell):
    if (cell != None):
        # If the cell has no ship, draw a ripple.
        if (cell.status == 'ocean'):
            cell.status = 'missed'
            drawRipple(cell)
            return True

        # If the cell has a ship, draw a hit.
        elif (cell.status == 'hiddenShip'):
            cell.status = 'hit'
            drawHit(cell)
            return True

        else:
            return False

def drawRipple(cell):
    # Draws a ripple in the cell.
    radiusList = [ 11, 7, 3 ]
    for radius in radiusList:
        Circle(cell.centerX, cell.centerY, radius,
               fill='aqua', border='blue', borderWidth=0.5)

def drawHit(cell):
    # Draw a hit as a star at the center of the cell.
    Star(cell.centerX, cell.centerY, 15, 6,
         fill=gradient('yellow', 'red', 'red'), roundness=30)

def checkWin(opponentBoard):
    # If any cell still has a hidden ship, return False.
    for row in range(8):
        for col in range(8):
            cell = opponentBoard[row][col]
            if (cell.status == 'hiddenShip'):
                return False
    return True

def onKeyPress(key):
    # Don't change this function! It is for testing purposes.
    if (key == 's'):
        for position in range(8):
            onMousePress(15 + position * 24, 115)

    if (key == 'e'):
        for col in range(8):
            cell = app.playerBoard[0][col]
            sinkOrMiss(cell)
        enemyTurn()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

app.gameState = 'setup'

Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            # Draw a rectangular cell for this row and column.
            x0 = startX + col * gridSize
            y0 = startY + row * gridSize
            cell = Rect(x0, y0, gridSize, gridSize, fill='mediumBlue',
                        border='white', borderWidth=1)

            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    # Find the cell that the point (x, y) lies in.
    for row in range(8):
        for col in range(8):
            cell = board[row][col]
            if (cell.hits(x, y) == True):
                return cell

def isAdjacent(cell, cellClicked):
    # Check if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    # If either rows are equal and the columns are within 1, or
    # columns are equal and the rows are within 1, they are adjacent.
    if (((cellRow == clickedRow) and (abs(cellCol - clickedCol) == 1)) or
        ((cellCol == clickedCol) and (abs(cellRow - clickedRow) == 1))):
        return True
    else:
        return False

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    # Place a player ship at the location if it will be a legal move.
    cell = findCell(mouseX, mouseY, app.playerBoard)
    if (isLegalShip(cell, app.playerBoard, app.shipPartsPlaced) == True):
        # Place the ship.
        cell.status = 'hiddenShip'
        cell.fill = 'grey'
        app.shipPartsPlaced += 1

def placeEnemies():
    # Randomly place enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Place the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then create 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enter playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'

    # Otherwise play a turn.
    elif (app.gameState == 'play'):
        playTurn(mouseX, mouseY)

def playTurn(mouseX, mouseY):
    # On each turn, see if the cell clicked was valid.
    cell = findCell(mouseX, mouseY, app.enemyBoard)
    if (sinkOrMiss(cell) == True):
        enemyTurn()

    # Then check if the game ends.
    if (checkWin(app.enemyBoard) == True):
        Rect(0, 160, 400, 90, fill='green')
        Label('YOU WON!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def enemyTurn():
    # On an enemy turn, randomly pick a new cell to attack.
    newSpot = False
    while (newSpot == False):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.playerBoard[randomRow][randomCol]

        # If the cell has not be attacked yet, end the loop.
        if ((randomCell.status == 'ocean') or (randomCell.status == 'hiddenShip')):
            newSpot = True

    # Check if the attacked cell is a ship then check if the game ends.
    sinkOrMiss(randomCell)
    if (checkWin(app.playerBoard) == True):
        Rect(0, 160, 400, 90, fill='red')
        Label('YOU LOST!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def sinkOrMiss(cell):
    if (cell != None):
        # If the cell has no ship, draw a ripple.
        if (cell.status == 'ocean'):
            cell.status = 'missed'
            drawRipple(cell)
            return True

        # If the cell has a ship, draw a hit.
        elif (cell.status == 'hiddenShip'):
            cell.status = 'hit'
            drawHit(cell)
            return True

        else:
            return False

def drawRipple(cell):
    # Draws a ripple in the cell.
    radiusList = [ 11, 7, 3 ]
    for radius in radiusList:
        Circle(cell.centerX, cell.centerY, radius,
               fill='aqua', border='blue', borderWidth=0.5)

def drawHit(cell):
    # Draw a hit as a star at the center of the cell.
    Star(cell.centerX, cell.centerY, 15, 6,
         fill=gradient('yellow', 'red', 'red'), roundness=30)

def checkWin(opponentBoard):
    # If any cell still has a hidden ship, return False.
    for row in range(8):
        for col in range(8):
            cell = opponentBoard[row][col]
            if (cell.status == 'hiddenShip'):
                return False
    return True

def onKeyPress(key):
    # Don't change this function! It is for testing purposes.
    if (key == 's'):
        for position in range(8):
            onMousePress(15 + position * 24, 115)

    if (key == 'e'):
        for col in range(8):
            cell = app.playerBoard[0][col]
            sinkOrMiss(cell)
        enemyTurn()
",demo,0
2332,Battleship Part 2,11.2.3,"app.background = 'black'

app.gameState = 'setup'

# background
Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            #_BLOCK_MAKE_BOARD

            # Sets the cell properties and add it to the board.
            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    #_BLOCK_FIND_CELL

    return None

def isAdjacent(cell, cellClicked):
    # Checks if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    #_BLOCK_IS_ADJACENT

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    cell = findCell(mouseX, mouseY, app.playerBoard)

    #_BLOCK_PLACE_PLAYER

def placeEnemies():
    # Randomly places enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Places the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def playTurn(mouseX, mouseY):
    # Fire at the enemy.
    cell = findCell(mouseX, mouseY, app.enemyBoard)
    sinkOrMiss(cell)

    # Check if the game ends.
    if (checkWin(app.enemyBoard) == True):
        Rect(0, 160, 400, 90, fill='green')
        Label('YOU WON!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def sinkOrMiss(cell):
    if (cell != None):
        # If the cell has no ship, draws a ripple.
        if (cell.status == 'ocean'):
            cell.status = 'missed'
            drawRipple(cell)
            return True

        # If the cell has a ship, draws a hit.
        elif (cell.status == 'hiddenShip'):
            cell.status = 'hit'
            drawHit(cell)
            return True

        else:
            return False

def drawRipple(cell):
    radiusList = [ 11, 7, 3 ]

    #### START OF BLOCK DRAW_RIPPLE ####

    # Draw a ripple in the cell.
    ### Place Your Code Here ###

    #### END OF BLOCK ####

def drawHit(cell):
    #### START OF BLOCK DRAW_HIT ####

    # Draw a hit as a star at the center of the cell.
    ### Place Your Code Here ###
    pass

    #### END OF BLOCK ####

def checkWin(opponentBoard):
    #### START OF BLOCK CHECK_WIN ####

    # If any cell still has a hidden ship, return False.
    ### Place Your Code Here ###
    pass

    #### END OF BLOCK ####

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then creates 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enters playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'

    # Otherwise play a turn.
    elif (app.gameState == 'play'):
        playTurn(mouseX, mouseY)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

app.gameState = 'setup'

# background
Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            # Draw a rectangular cell for this row and column.
            x0 = startX + col * gridSize
            y0 = startY + row * gridSize
            cell = Rect(x0, y0, gridSize, gridSize, fill='mediumBlue',
                        border='white', borderWidth=1)

            # Sets the cell properties and add it to the board.
            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    # Find the cell that the point (x, y) lies in.
    for row in range(8):
        for col in range(8):
            cell = board[row][col]
            if (cell.hits(x, y) == True):
                return cell

    return None

def isAdjacent(cell, cellClicked):
    # Checks if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    # If either the rows are equal and the columns are within 1, or
    # the columns are equal and the rows are within 1, they are adjacent.
    if (((cellRow == clickedRow) and (abs(cellCol - clickedCol) == 1)) or
        ((cellCol == clickedCol) and (abs(cellRow - clickedRow) == 1))):
        return True
    else:
        return False

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    cell = findCell(mouseX, mouseY, app.playerBoard)

    # Place a player ship in the cell if it will be a legal move.
    if (isLegalShip(cell, app.playerBoard, app.shipPartsPlaced) == True):
        cell.status = 'hiddenShip'
        cell.fill = 'grey'
        app.shipPartsPlaced += 1

def placeEnemies():
    # Randomly places enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Places the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def playTurn(mouseX, mouseY):
    # Fire at the enemy.
    cell = findCell(mouseX, mouseY, app.enemyBoard)
    sinkOrMiss(cell)

    # Check if the game ends.
    if (checkWin(app.enemyBoard) == True):
        Rect(0, 160, 400, 90, fill='green')
        Label('YOU WON!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def sinkOrMiss(cell):
    if (cell != None):
        # If the cell has no ship, draws a ripple.
        if (cell.status == 'ocean'):
            cell.status = 'missed'
            drawRipple(cell)
            return True

        # If the cell has a ship, draws a hit.
        elif (cell.status == 'hiddenShip'):
            cell.status = 'hit'
            drawHit(cell)
            return True

        else:
            return False

def drawRipple(cell):
    radiusList = [ 11, 7, 3 ]

    #### START OF BLOCK DRAW_RIPPLE ####
    # Draw a ripple in the cell.
    for radius in radiusList:
        Circle(cell.centerX, cell.centerY, radius,
               fill='aqua', border='blue', borderWidth=0.5)

    #### END OF BLOCK ####

def drawHit(cell):
    #### START OF BLOCK DRAW_HIT ####
    # Draw a hit as a star at the center of the cell.
    Star(cell.centerX, cell.centerY, 15, 6,
         fill=gradient('yellow', 'red', 'red'), roundness=30)

    #### END OF BLOCK ####

def checkWin(opponentBoard):
    #### START OF BLOCK CHECK_WIN ####
    # If any cell still has a hidden ship, return False.
    for row in range(8):
        for col in range(8):
            cell = opponentBoard[row][col]
            if (cell.status == 'hiddenShip'):
                return False
    return True

    #### END OF BLOCK ####

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then creates 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enters playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'

    # Otherwise play a turn.
    elif (app.gameState == 'play'):
        playTurn(mouseX, mouseY)
",chain,2
2333,Battleship Part 3,11.2.3,"app.background = 'black'

app.gameState = 'setup'

# background
Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            #_BLOCK_MAKE_BOARD

            # Sets the cell properties and add it to the board.
            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    #_BLOCK_FIND_CELL

    return None

def isAdjacent(cell, cellClicked):
    # Checks if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    #_BLOCK_IS_ADJACENT

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    cell = findCell(mouseX, mouseY, app.playerBoard)

    #_BLOCK_PLACE_PLAYER

def placeEnemies():
    # Randomly places enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Places the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def playTurn(mouseX, mouseY):
    # On each turn, see if the cell clicked was valid.
    cell = findCell(mouseX, mouseY, app.enemyBoard)
    if (sinkOrMiss(cell) == True):
        enemyTurn()

    # Check if the game ends.
    if (checkWin(app.enemyBoard) == True):
        Rect(0, 160, 400, 90, fill='green')
        Label('YOU WON!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def enemyTurn():
    # On an enemy turn, randomly pick a new cell to attack.
    newSpot = False
    while (newSpot == False):
        # Pick a random cell by choosing a row and column.
        ### (HINT: Choose the row first in order to autograde properly.)
        ### Place Your Code Here ###

        # If the cell has not been attacked yet, end the loop.
        ### Place Your Code Here ###
        pass

    # Checks if the attacked cell is a ship then check if the game ends.
    sinkOrMiss(randomCell)
    if (checkWin(app.playerBoard) == True):
        # Draw the game lost screen.
        ### Place Your Code Here ###
        pass

def sinkOrMiss(cell):
    if (cell != None):
        # If the cell has no ship, draws a ripple.
        if (cell.status == 'ocean'):
            cell.status = 'missed'
            drawRipple(cell)
            return True

        # If the cell has a ship, draws a hit.
        elif (cell.status == 'hiddenShip'):
            cell.status = 'hit'
            drawHit(cell)
            return True

        else:
            return False

def drawRipple(cell):
    radiusList = [ 11, 7, 3 ]

    #_BLOCK_DRAW_RIPPLE

def drawHit(cell):
    #_BLOCK_DRAW_HIT

def checkWin(opponentBoard):
    #_BLOCK_CHECK_WIN

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then creates 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enters playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'

    # Otherwise play a turn.
    elif (app.gameState == 'play'):
        playTurn(mouseX, mouseY)

def onKeyPress(key):
    # Don't change this function! It is for testing purposes.
    if (key == 's'):
        for position in range(8):
            onMousePress(15 + position * 24, 115)

    if (key == 'e'):
        for col in range(8):
            cell = app.playerBoard[0][col]
            sinkOrMiss(cell)

        enemyTurn()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

app.gameState = 'setup'

# background
Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            # Draw a rectangular cell for this row and column.
            x0 = startX + col * gridSize
            y0 = startY + row * gridSize
            cell = Rect(x0, y0, gridSize, gridSize, fill='mediumBlue',
                        border='white', borderWidth=1)

            # Sets the cell properties and add it to the board.
            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    # Find the cell that the point (x, y) lies in.
    for row in range(8):
        for col in range(8):
            cell = board[row][col]
            if (cell.hits(x, y) == True):
                return cell

    return None

def isAdjacent(cell, cellClicked):
    # Checks if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    # If either the rows are equal and the columns are within 1, or
    # the columns are equal and the rows are within 1, they are adjacent.
    if (((cellRow == clickedRow) and (abs(cellCol - clickedCol) == 1)) or
        ((cellCol == clickedCol) and (abs(cellRow - clickedRow) == 1))):
        return True
    else:
        return False

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    cell = findCell(mouseX, mouseY, app.playerBoard)

    # Place a player ship in the cell if it will be a legal move.
    if (isLegalShip(cell, app.playerBoard, app.shipPartsPlaced) == True):
        cell.status = 'hiddenShip'
        cell.fill = 'grey'
        app.shipPartsPlaced += 1

def placeEnemies():
    # Randomly places enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Places the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def playTurn(mouseX, mouseY):
    # On each turn, see if the cell clicked was valid.
    cell = findCell(mouseX, mouseY, app.enemyBoard)
    if (sinkOrMiss(cell) == True):
        enemyTurn()

    # Check if the game ends.
    if (checkWin(app.enemyBoard) == True):
        Rect(0, 160, 400, 90, fill='green')
        Label('YOU WON!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def enemyTurn():
    # On an enemy turn, randomly pick a new cell to attack.
    newSpot = False
    while (newSpot == False):
        # Pick a random cell by choosing a row and column.
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.playerBoard[randomRow][randomCol]

        # If the cell has not been attacked yet, end the loop.
        if ((randomCell.status == 'ocean') or
            (randomCell.status == 'hiddenShip')):
            newSpot = True

    # Checks if the attacked cell is a ship then check if the game ends.
    sinkOrMiss(randomCell)
    if (checkWin(app.playerBoard) == True):
        # Draw the game lost screen.
        Rect(0, 160, 400, 90, fill='red')
        Label('YOU LOST!', 200, 200, fill='white', size=30)
        app.gameState = 'over'
        app.stop()

def sinkOrMiss(cell):
    if (cell != None):
        # If the cell has no ship, draws a ripple.
        if (cell.status == 'ocean'):
            cell.status = 'missed'
            drawRipple(cell)
            return True

        # If the cell has a ship, draws a hit.
        elif (cell.status == 'hiddenShip'):
            cell.status = 'hit'
            drawHit(cell)
            return True

        else:
            return False

def drawRipple(cell):
    radiusList = [ 11, 7, 3 ]

    # Draw a ripple in the cell.
    for radius in radiusList:
        Circle(cell.centerX, cell.centerY, radius,
               fill='aqua', border='blue', borderWidth=0.5)

def drawHit(cell):
    # Draw a hit as a star at the center of the cell.
    Star(cell.centerX, cell.centerY, 15, 6,
         fill=gradient('yellow', 'red', 'red'), roundness=30)

def checkWin(opponentBoard):
    # If any cell still has a hidden ship, return False.
    for row in range(8):
        for col in range(8):
            cell = opponentBoard[row][col]
            if (cell.status == 'hiddenShip'):
                return False
    return True

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then creates 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enters playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'

    # Otherwise play a turn.
    elif (app.gameState == 'play'):
        playTurn(mouseX, mouseY)

def onKeyPress(key):
    # Don't change this function! It is for testing purposes.
    if (key == 's'):
        for position in range(8):
            onMousePress(15 + position * 24, 115)

    if (key == 'e'):
        for col in range(8):
            cell = app.playerBoard[0][col]
            sinkOrMiss(cell)

        enemyTurn()
",chain,1
2331,Battleship Part 1,11.2.3,"app.background = 'black'

app.gameState = 'setup'

# background
Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            #### START OF BLOCK MAKE_BOARD ####

            # Draw a rectangular cell for this row and column.
            ### Fix Your Code Here ###
            x0 = startX
            y0 = startY
            cell = Rect(x0, y0, gridSize, gridSize)

            #### END OF BLOCK ####

            # Sets the cell properties and add it to the board.
            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    #### START OF BLOCK FIND_CELL ####

    # Find the cell that the point (x, y) lies in.
    ### (HINT: Try using the hits method on each cell!)
    ### Place Your Code Here ###

    #### END OF BLOCK ####

    return None

def isAdjacent(cell, cellClicked):
    # Checks if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    #### START OF BLOCK IS_ADJACENT ####

    # If either the rows are equal and the columns are within 1, or
    # the columns are equal and the rows are within 1, they are adjacent.
    ### Place Your Code Here ###

    #### END OF BLOCK ####

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    cell = findCell(mouseX, mouseY, app.playerBoard)

    #### START OF BLOCK PLACE_PLAYER ####

    # Place a player ship in the cell if it will be a legal move.
    ### (HINT: To place a ship, change the cell's status to 'hiddenShip'.
    #          Also change the fill and increment app.shipsPartsPlaced.)
    ### Place Your Code Here ###

    #### END OF BLOCK ####

def placeEnemies():
    # Randomly places enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Places the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then creates 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enters playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'black'

app.gameState = 'setup'

# background
Polygon(0, 80, 50, 50, 150, 50, 200, 80, 250, 50, 350, 50, 400, 80,
        400, 320, 350, 350, 250, 350, 200, 320, 150, 350, 50, 350, 0, 320,
        fill='mediumSeaGreen', border='limeGreen', borderWidth=6)
Label('PLAYER', 100, 330, size=25, font='monospace')
Label('ENEMY', 300, 330, size=25, font='monospace')

instructions = Label('Click to place four ships of size two', 200, 94,
                     fill='white', size=17, font='monospace', bold=True)

def makeBoard(startX, startY):
    rows = 8
    cols = 8
    gridSize = 24
    board = makeList(rows, cols)
    for row in range(rows):
        for col in range(cols):
            #### START OF BLOCK MAKE_BOARD ####
            # Draw a rectangular cell for this row and column.
            x0 = startX + col * gridSize
            y0 = startY + row * gridSize
            cell = Rect(x0, y0, gridSize, gridSize, fill='mediumBlue',
                        border='white', borderWidth=1)

            #### END OF BLOCK ####

            # Sets the cell properties and add it to the board.
            cell.status = 'ocean'
            cell.row = row
            cell.col = col
            board[row][col] = cell

    return board

app.playerBoard = makeBoard(3, 110)
app.enemyBoard = makeBoard(205, 110)
app.shipPartsPlaced = 0
app.lastClicked = None

def findCell(x, y, board):
    #### START OF BLOCK FIND_CELL ####
    # Find the cell that the point (x, y) lies in.
    for row in range(8):
        for col in range(8):
            cell = board[row][col]
            if (cell.hits(x, y) == True):
                return cell

    #### END OF BLOCK ####

    return None

def isAdjacent(cell, cellClicked):
    # Checks if two cells are adjacent.
    clickedRow = cellClicked.row
    clickedCol = cellClicked.col
    cellRow = cell.row
    cellCol = cell.col

    #### START OF BLOCK IS_ADJACENT ####
    # If either the rows are equal and the columns are within 1, or
    # the columns are equal and the rows are within 1, they are adjacent.
    if (((cellRow == clickedRow) and (abs(cellCol - clickedCol) == 1)) or
        ((cellCol == clickedCol) and (abs(cellRow - clickedRow) == 1))):
        return True
    else:
        return False

    #### END OF BLOCK ####

def isLegalShip(cell, board, numParts):
    # If the location is not an ocean, it is not legal.
    if ((cell == None) or (cell.status != 'ocean')):
        return False

    # Every ship has length 2 so if this is a new ship, it is legal.
    if (numParts % 2 == 0):
        app.lastClicked = cell
        return True
    else:
        # If we already placed the first part of a ship, make sure the second
        # part is next to the first.
        if (isAdjacent(cell, app.lastClicked) == True):
            return True
        else:
            return False

def placePlayer(mouseX, mouseY):
    cell = findCell(mouseX, mouseY, app.playerBoard)

    #### START OF BLOCK PLACE_PLAYER ####
    # Place a player ship in the cell if it will be a legal move.
    if (isLegalShip(cell, app.playerBoard, app.shipPartsPlaced) == True):
        cell.status = 'hiddenShip'
        cell.fill = 'grey'
        app.shipPartsPlaced += 1

    #### END OF BLOCK ####

def placeEnemies():
    # Randomly places enemy ships until there are 4 ships of size 2 on the board.
    numShipParts = 0
    while (numShipParts < 8):
        randomRow = randrange(0, 8)
        randomCol = randrange(0, 8)
        randomCell = app.enemyBoard[randomRow][randomCol]
        if (isLegalShip(randomCell, app.enemyBoard, numShipParts) == True):
            # Places the ship.
            randomCell.status = 'hiddenShip'
            numShipParts += 1

def onMousePress(mouseX, mouseY):
    # If on the start screen, place ship parts until the player has
    # 4 ships. Then creates 4 enemy ships.
    if (app.gameState == 'setup'):
        placePlayer(mouseX, mouseY)
        if (app.shipPartsPlaced == 8):
            placeEnemies()

            # Enters playing mode.
            app.gameState = 'play'
            instructions.value = 'Guess the location of the enemy ships'
",chain,3
2335,2048 Part 1,11.2.4,"app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    #### START OF BLOCK DRAW_BOARD ####

    # Create a rectangle cell for each row and column of the board.
    ### Place Your Code Here ###
    pass

    #### END OF BLOCK ####

drawBoard()

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    #### START OF BLOCK GENERATE_TILE ####

    # Loop until a new spot has been found to place a tile.
    ### Place Your Code Here ###

    # Each pass of the loop, pick a random cell by choosing the row and col
    # (in that order to autograde correctly).
    ### Place Your Code Here ###

    # If row, col give an empty cell, set its label to 2 and end the loop.
    ### Place Your Code Here ###

    #### END OF BLOCK ####
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    #### START OF BLOCK DRAW_BOARD ####
    # Create a rectangle cell for each row and column of the board.
    for row in range(len(app.board)):
        for col in range(len(app.board[row])):
            x = 10 + col * 100
            y = 10 + row * 100
            Rect(x, y, 80, 80, fill=rgb(205, 195, 180))

    #### END OF BLOCK ####

drawBoard()

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    #### START OF BLOCK GENERATE_TILE ####
    # Loop until a new spot has been found to place a tile.
    while (newSpotFound == False):
        # Pick a random cell by choosing the row and col.
        randRow = randrange(0, 4)
        randCol = randrange(0, 4)

        # If row, col give an empty cell, set its label to 2 and end the loop.
        if (app.board[randRow][randCol] == None):
            app.board[randRow][randCol] = 2
            newSpotFound = True

    #### END OF BLOCK ####
",chain,2
2336,2048 Part 2,11.2.4,"app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    #_BLOCK_DRAW_BOARD

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    #_BLOCK_GENERATE_TILE

def reverse(cellBlock):
    reversedCellBlock = [ ]

    #### START OF BLOCK REVERSE_CELL ####

    # cellBlock is either a row or a column. Reverse the order of the elements
    # in the 1D list cellBlock.
    ### (HINT: Pop the last value and add it to the reversed list.)
    ### Place Your Code Here ###
    pass

    #### END OF BLOCK ####

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellBlock to one side and combine similar values.

    # First, creates a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combines them and doubles the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index + 1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fills the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            #### START OF BLOCK MOVE_RIGHT ####

            # Reverse the row then slide left using move. Then reverse the
            # resulting row.
            ### Fix Your Code Here ###
            # row =
            # newRow =
            # app.board[rowIndex] =
            pass

            #### END OF BLOCK ####

        elif (direction == 'left'):
            #### START OF BLOCK MOVE_LEFT ####

            # Slide to the left using move.
            ### Fix Your Code Here ###
            # row =
            # newRow =
            # app.board[rowIndex] =
            pass

            #### END OF BLOCK ####

def onKeyPress(key):
    # If on the start screen, begins the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, makes moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    # Create a rectangle cell for each row and column of the board.
    for row in range(len(app.board)):
        for col in range(len(app.board[row])):
            x = 10 + col * 100
            y = 10 + row * 100
            Rect(x, y, 80, 80, fill=rgb(205, 195, 180))

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    # Loop until a new spot has been found to place a tile.
    while (newSpotFound == False):
        # Pick a random cell by choosing the row and col.
        randRow = randrange(0, 4)
        randCol = randrange(0, 4)

        # If row, col give an empty cell, set its label to 2 and end the loop.
        if (app.board[randRow][randCol] == None):
            app.board[randRow][randCol] = 2
            newSpotFound = True

def reverse(cellBlock):
    reversedCellBlock = [ ]

    #### START OF BLOCK REVERSE_CELL ####
    # cellBlock is either a row or a column. Reverse the order of the elements
    # in the 1D list cellBlock.
    for elem in range(len(cellBlock)):
        lastVal = cellBlock.pop()
        reversedCellBlock.append(lastVal)

    return reversedCellBlock

    #### END OF BLOCK ####

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellBlock to one side and combine similar values.

    # First, creates a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combines them and doubles the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index + 1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fills the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            #### START OF BLOCK MOVE_RIGHT ####
            # Reverse the row then slide left using move. Then reverse the
            # resulting row.
            row = reverse(app.board[rowIndex])
            app.board[rowIndex] = row
            newRow = move(app.board[rowIndex])
            app.board[rowIndex] = reverse(newRow)

            #### END OF BLOCK ####

        elif (direction == 'left'):
            #### START OF BLOCK MOVE_LEFT ####
            # Slide to the left using move.
            row = app.board[rowIndex]
            newRow = move(row)
            app.board[rowIndex] = newRow

            #### END OF BLOCK ####

def onKeyPress(key):
    # If on the start screen, begins the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, makes moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
",chain,3
2337,2048 Part 3,11.2.4,"app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    #_BLOCK_DRAW_BOARD

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    #_BLOCK_GENERATE_TILE

def reverse(cellBlock):
    reversedCellBlock = [ ]

    #_BLOCK_REVERSE_CELL

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellBlock to one side and combine similar values.

    # First, creates a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combines them and doubles the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index + 1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fills the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            #_BLOCK_MOVE_RIGHT

        elif (direction == 'left'):
            #_BLOCK_MOVE_LEFT

def getCol(board, colIndex):
    colList = [ ]

    #### START OF BLOCK GET_COL ####

    # Go through the rows of the board and add each element at the colIndex
    # to colList.
    ### Place Your Code Here ###

    #### END OF BLOCK ####

def moveCols(board):
    for colIndex in range(len(board[0])):
        #### START OF BLOCK MOVE_COLS ####

        # For every column, slide the elements up using the move function.
        ### Place Your Code Here ###

        # Then copy the values to the board.
        ### Place Your Code Here ###
        pass

        #### END OF BLOCK ####

def moveVertical(direction):
    if (direction == 'up'):
        # Slides up.
        moveCols(app.board)
    elif (direction == 'down'):
        # Reverses the columns then slides up. Then reverses the resulting columns.
        board = reverse(app.board)
        app.board = board
        moveCols(board)
        app.board = reverse(board)

def onKeyPress(key):
    # If on the start screen, begin the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, make moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)
        elif ((key == 'up') or (key == 'down')):
            moveVertical(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    # Create a rectangle cell for each row and column of the board.
    for row in range(len(app.board)):
        for col in range(len(app.board[row])):
            x = 10 + col * 100
            y = 10 + row * 100
            Rect(x, y, 80, 80, fill=rgb(205, 195, 180))

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    # Loop until a new spot has been found to place a tile.
    while (newSpotFound == False):
        # Pick a random cell by choosing the row and col.
        randRow = randrange(0, 4)
        randCol = randrange(0, 4)

        # If row, col give an empty cell, set its label to 2 and end the loop.
        if (app.board[randRow][randCol] == None):
            app.board[randRow][randCol] = 2
            newSpotFound = True

def reverse(cellBlock):
    reversedCellBlock = [ ]

    # cellBlock is either a row or a column. Reverse the order of the elements
    # in the 1D list cellBlock.
    for elem in range(len(cellBlock)):
        lastVal = cellBlock.pop()
        reversedCellBlock.append(lastVal)

    return reversedCellBlock

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellBlock to one side and combine similar values.

    # First, creates a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combines them and doubles the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index + 1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fills the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            # Reverse the row then slide left using move. Then reverse the
            # resulting row.
            row = reverse(app.board[rowIndex])
            app.board[rowIndex] = row
            newRow = move(app.board[rowIndex])
            app.board[rowIndex] = reverse(newRow)

        elif (direction == 'left'):
            # Slide to the left using move.
            row = app.board[rowIndex]
            newRow = move(row)
            app.board[rowIndex] = newRow

def getCol(board, colIndex):
    colList = [ ]

    #### START OF BLOCK GET_COL ####
    # Go through the rows of the board and add each element at the colIndex
    # to colList.
    for row in board:
        colList.append(row[colIndex])

    return colList

    #### END OF BLOCK ####

def moveCols(board):
    for colIndex in range(len(board[0])):
        #### START OF BLOCK MOVE_COLS ####
        # For every column, slide the elements up using the move function.
        colList = getCol(board, colIndex)
        newCol = move(colList)

        # Then copy the values to the board.
        for rowIndex in range(len(board)):
            board[rowIndex][colIndex] = newCol[rowIndex]

        #### END OF BLOCK ####

def moveVertical(direction):
    if (direction == 'up'):
        # Slides up.
        moveCols(app.board)
    elif (direction == 'down'):
        # Reverses the columns then slides up. Then reverses the resulting columns.
        board = reverse(app.board)
        app.board = board
        moveCols(board)
        app.board = reverse(board)

def onKeyPress(key):
    # If on the start screen, begin the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, make moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)
        elif ((key == 'up') or (key == 'down')):
            moveVertical(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
",chain,3
2338,2048 Part 4,11.2.4,"app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    #_BLOCK_DRAW_BOARD

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    #_BLOCK_GENERATE_TILE

def reverse(cellBlock):
    reversedCellBlock = [ ]

    #_BLOCK_REVERSE_CELL

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellBlock to one side and combine similar values.

    # First, creates a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combines them and doubles the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index + 1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fills the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            #_BLOCK_MOVE_RIGHT

        elif (direction == 'left'):
            #_BLOCK_MOVE_LEFT

def getCol(board, colIndex):
    colList = [ ]

    #_BLOCK_GET_COL

def moveCols(board):
    for colIndex in range(len(board[0])):
        #_BLOCK_MOVE_COLS

def moveVertical(direction):
    if (direction == 'up'):
        # Slides up.
        moveCols(app.board)
    elif (direction == 'down'):
        # Reverses the columns then slides up. Then reverses the resulting columns.
        board = reverse(app.board)
        app.board = board
        moveCols(board)
        app.board = reverse(board)

def gameOver():
    fullRowCount = 0
    for row in range(len(app.board)):
        # Check if any row contains 2048 and end the game as a win if so.
        ### (HINT: Don't forget to call app.stop())
        ### Place Your Code Here ###

        # If every cell has a tile on it, the row is full.
        if (None not in app.board[row]):
            fullRowCount += 1

    # If every row is full, end the game as a loss.
    ### Place Your Code Here ###


def onKeyPress(key):
    # If on the start screen, begin the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, make moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)
        elif ((key == 'up') or (key == 'down')):
            moveVertical(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
        gameOver()

def onMousePress(mouseX, mouseY):
    # Don't change this function! It is for testing purposes.
    if ((mouseX == -1) and (mouseY == -1)):
        app.board[0][0] = 2048
        gameOver()
    elif ((mouseX == 400) and (mouseY == 400)):
        for row in range(4):
            for col in range(4):
                app.board[row][col] = 2
                gameOver()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    # Create a rectangle cell for each row and column of the board.
    for row in range(len(app.board)):
        for col in range(len(app.board[row])):
            x = 10 + col * 100
            y = 10 + row * 100
            Rect(x, y, 80, 80, fill=rgb(205, 195, 180))

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def drawTile(value, row, col):
    # Creates a tile piece at the row and column and labels it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (col * 100), 10 + (row * 100), 80, 80, fill=color),
        Label(value, 50 + (col * 100), 50 + (row * 100), fill=app.textColor,
              size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    newSpotFound = False

    # Loop until a new spot has been found to place a tile.
    while (newSpotFound == False):
        # Pick a random cell by choosing the row and col.
        randRow = randrange(0, 4)
        randCol = randrange(0, 4)

        # If row, col give an empty cell, set its label to 2 and end the loop.
        if (app.board[randRow][randCol] == None):
            app.board[randRow][randCol] = 2
            newSpotFound = True

def reverse(cellBlock):
    reversedCellBlock = [ ]

    # cellBlock is either a row or a column. Reverse the order of the elements
    # in the 1D list cellBlock.
    for elem in range(len(cellBlock)):
        lastVal = cellBlock.pop()
        reversedCellBlock.append(lastVal)

    return reversedCellBlock

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellBlock to one side and combine similar values.

    # First, creates a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combines them and doubles the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index + 1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fills the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            # Reverse the row then slide left using move. Then reverse the
            # resulting row.
            row = reverse(app.board[rowIndex])
            app.board[rowIndex] = row
            newRow = move(app.board[rowIndex])
            app.board[rowIndex] = reverse(newRow)

        elif (direction == 'left'):
            # Slide to the left using move.
            row = app.board[rowIndex]
            newRow = move(row)
            app.board[rowIndex] = newRow

def getCol(board, colIndex):
    colList = [ ]

    # Go through the rows of the board and add each element at the colIndex
    # to colList.
    for row in board:
        colList.append(row[colIndex])

    return colList

def moveCols(board):
    for colIndex in range(len(board[0])):
        # For every column, slide the elements up using the move function.
        colList = getCol(board, colIndex)
        newCol = move(colList)

        # Then copy the values to the board.
        for rowIndex in range(len(board)):
            board[rowIndex][colIndex] = newCol[rowIndex]

def moveVertical(direction):
    if (direction == 'up'):
        # Slides up.
        moveCols(app.board)
    elif (direction == 'down'):
        # Reverses the columns then slides up. Then reverses the resulting columns.
        board = reverse(app.board)
        app.board = board
        moveCols(board)
        app.board = reverse(board)

def gameOver():
    fullRowCount = 0
    for row in range(len(app.board)):
        # Check if any row contains 2048 and end the game as a win if so.
        if (2048 in app.board[row]):
            Rect(0, 100, 400, 100, fill=app.colors[len(app.colors) - 1])
            message = Label('You win!', 200, 150, fill=app.textColor, size=30)
            app.stop()

        # If every cell has a tile on it, the row is full.
        if (None not in app.board[row]):
            fullRowCount += 1

    # If every row is full, end the game as a loss.
    if (fullRowCount == len(app.board)):
        Rect(0, 100, 400, 100, fill=app.colors[len(app.colors) - 1])
        message = Label('Game Over!', 200, 150, fill=app.textColor,
                        size=30)
        app.stop()
def onKeyPress(key):
    # If on the start screen, begin the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, make moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)
        elif ((key == 'up') or (key == 'down')):
            moveVertical(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
        gameOver()

def onMousePress(mouseX, mouseY):
    # Don't change this function! It is for testing purposes.
    if ((mouseX == -1) and (mouseY == -1)):
        app.board[0][0] = 2048
        gameOver()
    elif ((mouseX == 400) and (mouseY == 400)):
        for row in range(4):
            for col in range(4):
                app.board[row][col] = 2
                gameOver()
",chain,1
2334,2048 Demo,11.2.4,"# Set up board and colors.
app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    # Create a rectangle cell for each row and column of the board.
    for row in range(len(app.board)):
        for col in range(len(app.board[row])):
            x = 10 + col * 100
            y = 10 + row * 100
            Rect(x, y, 80, 80, fill=rgb(205, 195, 180))

def drawTile(value, rowIndex, colIndex):
    # Creates a tile piece at the row and column and label it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (colIndex * 100), 10 + (rowIndex * 100), 80, 80, fill=color),
        Label(value, 50 + (colIndex * 100), 50 + (rowIndex * 100),
              fill=app.textColor, size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    # Loop until an empty cell is randomly chosen.
    newSpotFound = False
    while (newSpotFound == False):
        # Pick a random cell by choosing the row and col.
        randRow = randrange(0, 4)
        randCol = randrange(0, 4)

        # If row, col give an empty cell, set its label to 2 and end the loop.
        if (app.board[randRow][randCol] == None):
            app.board[randRow][randCol] = 2
            newSpotFound = True

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def reverse(L):
    # Reverse the order of the elements in the list L.
    reversedL = [ ]
    for elem in range(len(L)):
        lastVal = L.pop()
        reversedL.append(lastVal)

    return reversedL

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellblock to one side and combine similar values.

    # First, create a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combine them and double the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index+1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fill the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            # Reverse the row then slide left. Then reverse the resulting row.
            row = reverse(app.board[rowIndex])
            app.board[rowIndex] = row
            newRow = move(app.board[rowIndex])
            app.board[rowIndex] = reverse(newRow)
        elif (direction == 'left'):
            # Slide to the left.
            row = app.board[rowIndex]
            newRow = move(row)
            app.board[rowIndex] = newRow

def getCol(board, colIndex):
    # Go through the rows and add each element at the colIndex to colList.
    colList = [ ]
    for row in board:
        colList.append(row[colIndex])

    return colList

def moveCols(board):
    # For every column, slide the elements up using the move function.
    for colIndex in range(len(board[0])):
        colList = getCol(board, colIndex)
        newCol = move(colList)

        # Then copy the values to the board.
        for rowIndex in range(len(board)):
            board[rowIndex][colIndex] = newCol[rowIndex]

def moveVertical(direction):
    if (direction == 'up'):
        # Slide up.
        moveCols(app.board)
    elif (direction == 'down'):
        # Reverse the columns then slide up. Then reverse the resulting columns.
        board = reverse(app.board)
        app.board = board
        moveCols(board)
        app.board = reverse(board)

def onKeyPress(key):
    # If on the start screen, begin the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, make moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)
        elif ((key == 'up') or (key == 'down')):
            moveVertical(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
        gameOver()

def gameOver():
    fullRowCount = 0
    for row in range(len(app.board)):
        # Check if any row contains 2048 and end the game as a win if so.
        if (2048 in app.board[row]):
            Rect(0, 100, 400, 100, fill=app.colors[len(app.colors) - 1])
            message = Label('You win!', 200, 150, fill=app.textColor, size=30)
            app.stop()

        # If every cell has a tile on it, the row is full.
        elif (None not in app.board[row]):
            fullRowCount += 1

    # If every row is full, end the game as a loss.
    if (fullRowCount == len(app.board)):
        Rect(0, 100, 400, 100, fill=app.colors[len(app.colors) - 1])
        message = Label('Game Over!', 200, 150, fill=app.textColor,
                        size=30)
        app.stop()

def onMousePress(mouseX, mouseY):
    # Don't change this function! It is for testing purposes.
    if ((mouseX == -1) and (mouseY == -1)):
        app.board[0][0] = 2048
        gameOver()
    elif ((mouseX == 400) and (mouseY == 400)):
        for row in range(4):
            for col in range(4):
                app.board[row][col] = 2
                gameOver()
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

# Set up board and colors.
app.board = makeList(4, 4)
app.colors = [ rgb(240, 230, 220), rgb(235, 225, 200), rgb(240, 180, 125),
               rgb(240, 140, 95), rgb(240, 125, 85), rgb(230, 90, 45),
               rgb(245, 215, 105), rgb(240, 210, 65), rgb(230, 200, 30),
               rgb(225, 185, 20), rgb(235, 200, 0) ]
app.textColor = rgb(105, 95, 85)

tiles = Group()

def drawBoard():
    # Create a rectangle cell for each row and column of the board.
    for row in range(len(app.board)):
        for col in range(len(app.board[row])):
            x = 10 + col * 100
            y = 10 + row * 100
            Rect(x, y, 80, 80, fill=rgb(205, 195, 180))

def drawTile(value, rowIndex, colIndex):
    # Creates a tile piece at the row and column and label it with the
    # number value.
    counter = 0
    tempValue = value

    # Finds the index of the colors list.
    while (tempValue > 2):
        tempValue //= 2
        counter += 1

    # Draws a tile.
    color = app.colors[counter]
    tiles.add(
        Rect(10 + (colIndex * 100), 10 + (rowIndex * 100), 80, 80, fill=color),
        Label(value, 50 + (colIndex * 100), 50 + (rowIndex * 100),
              fill=app.textColor, size=50, bold=True)
        )

def drawTiles():
    # For every board cell that has a number value, creates a tile.
    for rowIndex in range(len(app.board)):
        row = app.board[rowIndex]
        for colIndex in range(len(row)):
            value = row[colIndex]
            if (value != None):
                drawTile(value, rowIndex, colIndex)

    tiles.toFront()

def generateNewTile():
    # Loop until an empty cell is randomly chosen.
    newSpotFound = False
    while (newSpotFound == False):
        # Pick a random cell by choosing the row and col.
        randRow = randrange(0, 4)
        randCol = randrange(0, 4)

        # If row, col give an empty cell, set its label to 2 and end the loop.
        if (app.board[randRow][randCol] == None):
            app.board[randRow][randCol] = 2
            newSpotFound = True

drawBoard()

startScreen = Group(
    Rect(0, 0, 400, 400, fill=app.colors[5]),
    Label(""Let's play 2048!"", 200, 130, fill='white', size=40),
    Label(""Press the 'up', 'down', 'right', and 'left' arrow keys"", 200, 160,
          fill='white', size=15),
    Label('to move the tiles on the board', 200, 180, fill='white', size=15),
    Label('If two tiles of the same number collide,', 200, 200, fill='white',
          size=15),
    Label('they will combine into one tile!', 200, 220, fill='white', size=15),
    Label('Try to get to 2048!!!', 200, 250, fill='white', size=35),
    Label('Press space to start.', 200, 280, fill='white', size=15)
    )

def reverse(L):
    # Reverse the order of the elements in the list L.
    reversedL = [ ]
    for elem in range(len(L)):
        lastVal = L.pop()
        reversedL.append(lastVal)

    return reversedL

def move(cellBlock):
    # cellBlock is either a row or a column. move will slide all of the values
    # in the cellblock to one side and combine similar values.

    # First, create a copy of the list by copying elements over one by one.
    cellBlockCopy = [ ]
    for cellIndex in range(len(cellBlock)):
        if (cellBlock[cellIndex] != None):
            cellBlockCopy.append(cellBlock[cellIndex])

    index = 0
    while (index < len(cellBlockCopy) - 1):
        # If two cells in the copy are next to each other and have the same
        # number, combine them and double the numer.
        if (cellBlockCopy[index] == cellBlockCopy[index+1]):
            val = cellBlockCopy.pop(index)
            cellBlockCopy[index] = val * 2
        else:
            index += 1

    # Fill the remainder of the copy with None tiles.
    for remainingCells in range(len(cellBlock) - len(cellBlockCopy)):
        cellBlockCopy.append(None)

    return cellBlockCopy

def moveHorizontal(direction):
    # For each row, slide it in the direction.
    for rowIndex in range(len(app.board)):
        if (direction == 'right'):
            # Reverse the row then slide left. Then reverse the resulting row.
            row = reverse(app.board[rowIndex])
            app.board[rowIndex] = row
            newRow = move(app.board[rowIndex])
            app.board[rowIndex] = reverse(newRow)
        elif (direction == 'left'):
            # Slide to the left.
            row = app.board[rowIndex]
            newRow = move(row)
            app.board[rowIndex] = newRow

def getCol(board, colIndex):
    # Go through the rows and add each element at the colIndex to colList.
    colList = [ ]
    for row in board:
        colList.append(row[colIndex])

    return colList

def moveCols(board):
    # For every column, slide the elements up using the move function.
    for colIndex in range(len(board[0])):
        colList = getCol(board, colIndex)
        newCol = move(colList)

        # Then copy the values to the board.
        for rowIndex in range(len(board)):
            board[rowIndex][colIndex] = newCol[rowIndex]

def moveVertical(direction):
    if (direction == 'up'):
        # Slide up.
        moveCols(app.board)
    elif (direction == 'down'):
        # Reverse the columns then slide up. Then reverse the resulting columns.
        board = reverse(app.board)
        app.board = board
        moveCols(board)
        app.board = reverse(board)

def onKeyPress(key):
    # If on the start screen, begin the game when space is pressed.
    if ((startScreen.visible == True) and (key == 'space')):
        startScreen.visible = False

    # If the game is playing, make moves on the key presses.
    elif (startScreen.visible == False):
        if ((key == 'right') or (key == 'left')):
            moveHorizontal(key)
        elif ((key == 'up') or (key == 'down')):
            moveVertical(key)

        tiles.clear()
        generateNewTile()
        drawTiles()
        gameOver()

def gameOver():
    fullRowCount = 0
    for row in range(len(app.board)):
        # Check if any row contains 2048 and end the game as a win if so.
        if (2048 in app.board[row]):
            Rect(0, 100, 400, 100, fill=app.colors[len(app.colors) - 1])
            message = Label('You win!', 200, 150, fill=app.textColor, size=30)
            app.stop()

        # If every cell has a tile on it, the row is full.
        elif (None not in app.board[row]):
            fullRowCount += 1

    # If every row is full, end the game as a loss.
    if (fullRowCount == len(app.board)):
        Rect(0, 100, 400, 100, fill=app.colors[len(app.colors) - 1])
        message = Label('Game Over!', 200, 150, fill=app.textColor,
                        size=30)
        app.stop()

def onMousePress(mouseX, mouseY):
    # Don't change this function! It is for testing purposes.
    if ((mouseX == -1) and (mouseY == -1)):
        app.board[0][0] = 2048
        gameOver()
    elif ((mouseX == 400) and (mouseY == 400)):
        for row in range(4):
            for col in range(4):
                app.board[row][col] = 2
                gameOver()
",demo,0
2341,Flip book,12.1.4,"app.background = 'lightYellow'
app.stepsPerSecond = 8

app.shouldAnimate = False
app.frameIndex = 0

# Stores the last position the mouse was dragged at.
app.x = None
app.y = None

# Stores the different frames to animate.
app.currFrame = Group()
app.frames = [ ]
app.frameNumber = 1

directions = Group(Label('Flip Book', 10, 20, size=20, align='left'))

def makeDirections():
    i = 0
    directionList = [ 'Change pen color by clicking on the colorBar',
                      ""Press 'n' to add a new frame"",
                      ""Press 'a' to animate"",
                      ""Press 'z' to clear the current frame"",
                      ""Press 'space' to hide/unhide this guide."" ]

    for direction in directionList:
        directions.add(
            Label(direction, 10, 50 +  i * 25, size=15, opacity=80, align='left')
            )
        i += 1

makeDirections()

colorBar = Group()
colors = [ 'crimson', 'darkOrange', 'gold', 'mediumSeaGreen',
           'lightSkyBlue', 'midnightBlue', 'lightYellow', 'black' ]
for i in range(8):
    colorBar.add(
        Rect(350, i * 50, 50, 50, fill=colors[i], border='black')
        )

penBar = Group()
smallestRadius = 2
for i in range(4):
    penBar.add(Circle(20 + i * 50, 380, smallestRadius + i * 4))

penTool = Group(
    Rect(275, 375, 10, 15, border='black'),
    Polygon(275, 375, 285, 375, 280, 370, border='black')
    )
penTool.rotateAngle = -30
penTool.drawSize = 2

def startAnimation():
    # Adds the current frame to the list of frames to animate.
    app.frames.append(app.currFrame)

    # Hides the toolbars, indicates that animation should begin, and sets all
    # the opacities to 100.
    colorBar.visible = False
    penBar.visible = False
    directions.visible = False
    app.shouldAnimate = True
    for frame in app.frames:
        frame.opacity = 100

def startNewFrame():
    # Adds the current frame to the list of frames.
    app.frames.append(app.currFrame)

    # Lowers the opacity of the previous frames.
    for frame in app.frames:
        frame.opacity = max(frame.opacity - 45, 0)

    # Creates a new frame.
    app.currFrame = Group()
    app.frameNumber += 1

def onKeyPress(key):
    if (key == 'n'):
        startNewFrame()
    elif (key == 'a'):
        startAnimation()
    elif (key == 'z'):
        app.currFrame.clear()
    elif (key == 'space'):
        directions.visible = not directions.visible

def onMousePress(mouseX, mouseY):
    # If the mouse is pressed on the color bar, changes the pen's color.
    targetColor = colorBar.hitTest(mouseX, mouseY)
    if (targetColor != None):
        penTool.fill = targetColor.fill

    # If the mouse is pressed on the size bar, changes the pen's size.
    targetPen = penBar.hitTest(mouseX, mouseY)
    if (targetPen != None):
        penTool.drawSize = targetPen.radius

def onMouseRelease(mouseX, mouseY):
    app.x = None
    app.y = None

def onMouseMove(mouseX, mouseY):
    # Moves the pen.
    penTool.left = mouseX
    penTool.top = mouseY

def onMouseDrag(mouseX, mouseY):
    # Draws at the mouse position onto the current frame.
    onMouseMove(mouseX, mouseY)
    if (app.x == None):
        app.x, app.y = mouseX, mouseY
    else:
        app.currFrame.add(
            Line(app.x, app.y, mouseX, mouseY, fill=penTool.fill,
                 lineWidth=penTool.drawSize)
            )
        app.x, app.y = mouseX, mouseY

def onStep():
    if (app.shouldAnimate == True):
        # For each of the frames, sets them invisble, then displays only the
        # current frame.
        for frame in app.frames:
            frame.visible = False
        app.frames[app.frameIndex].visible = True

        # Cycles through which frame is visible.
        app.frameIndex += 1
        if (app.frameIndex >= app.frameNumber):
            app.frameIndex = 0
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = 'lightYellow'
app.stepsPerSecond = 8

app.shouldAnimate = False
app.frameIndex = 0

# Stores the last position the mouse was dragged at.
app.x = None
app.y = None

# Stores the different frames to animate.
app.currFrame = Group()
app.frames = [ ]
app.frameNumber = 1

directions = Group(Label('Flip Book', 10, 20, size=20, align='left'))

def makeDirections():
    i = 0
    directionList = [ 'Change pen color by clicking on the colorBar',
                      ""Press 'n' to add a new frame"",
                      ""Press 'a' to animate"",
                      ""Press 'z' to clear the current frame"",
                      ""Press 'space' to hide/unhide this guide."" ]

    for direction in directionList:
        directions.add(
            Label(direction, 10, 50 +  i * 25, size=15, opacity=80, align='left')
            )
        i += 1

makeDirections()

colorBar = Group()
colors = [ 'crimson', 'darkOrange', 'gold', 'mediumSeaGreen',
           'lightSkyBlue', 'midnightBlue', 'lightYellow', 'black' ]
for i in range(8):
    colorBar.add(
        Rect(350, i * 50, 50, 50, fill=colors[i], border='black')
        )

penBar = Group()
smallestRadius = 2
for i in range(4):
    penBar.add(Circle(20 + i * 50, 380, smallestRadius + i * 4))

penTool = Group(
    Rect(275, 375, 10, 15, border='black'),
    Polygon(275, 375, 285, 375, 280, 370, border='black')
    )
penTool.rotateAngle = -30
penTool.drawSize = 2

def startAnimation():
    # Adds the current frame to the list of frames to animate.
    app.frames.append(app.currFrame)

    # Hides the toolbars, indicates that animation should begin, and sets all
    # the opacities to 100.
    colorBar.visible = False
    penBar.visible = False
    directions.visible = False
    app.shouldAnimate = True
    for frame in app.frames:
        frame.opacity = 100

def startNewFrame():
    # Adds the current frame to the list of frames.
    app.frames.append(app.currFrame)

    # Lowers the opacity of the previous frames.
    for frame in app.frames:
        frame.opacity = max(frame.opacity - 45, 0)

    # Creates a new frame.
    app.currFrame = Group()
    app.frameNumber += 1

def onKeyPress(key):
    if (key == 'n'):
        startNewFrame()
    elif (key == 'a'):
        startAnimation()
    elif (key == 'z'):
        app.currFrame.clear()
    elif (key == 'space'):
        directions.visible = not directions.visible

def onMousePress(mouseX, mouseY):
    # If the mouse is pressed on the color bar, changes the pen's color.
    targetColor = colorBar.hitTest(mouseX, mouseY)
    if (targetColor != None):
        penTool.fill = targetColor.fill

    # If the mouse is pressed on the size bar, changes the pen's size.
    targetPen = penBar.hitTest(mouseX, mouseY)
    if (targetPen != None):
        penTool.drawSize = targetPen.radius

def onMouseRelease(mouseX, mouseY):
    app.x = None
    app.y = None

def onMouseMove(mouseX, mouseY):
    # Moves the pen.
    penTool.left = mouseX
    penTool.top = mouseY

def onMouseDrag(mouseX, mouseY):
    # Draws at the mouse position onto the current frame.
    onMouseMove(mouseX, mouseY)
    if (app.x == None):
        app.x, app.y = mouseX, mouseY
    else:
        app.currFrame.add(
            Line(app.x, app.y, mouseX, mouseY, fill=penTool.fill,
                 lineWidth=penTool.drawSize)
            )
        app.x, app.y = mouseX, mouseY

def onStep():
    if (app.shouldAnimate == True):
        # For each of the frames, sets them invisble, then displays only the
        # current frame.
        for frame in app.frames:
            frame.visible = False
        app.frames[app.frameIndex].visible = True

        # Cycles through which frame is visible.
        app.frameIndex += 1
        if (app.frameIndex >= app.frameNumber):
            app.frameIndex = 0
",sample,1
2342,Avalanche,12.1.4,"app.background = gradient('steelBlue', 'lightCyan', start='top')
app.stepsPerSecond = 100

app.steps = 0
app.stepHeight = 250

player = Group(
    Circle(190, 315, 5, fill='white', border='black'),
    Circle(210, 315, 5, fill='white', border='black'),
    Circle(190, 345, 5, fill='white', border='black'),
    Circle(210, 345, 5, fill='white', border='black'),
    Rect(190, 310, 20, 40, fill='white', border='black'),
    Rect(185, 315, 30, 30, fill='white', border='black'),
    Rect(187, 312, 26, 36, fill='white'),
    )
player.dy = 0
player.isJumping = False
player.hitBlock = False
player.tooHigh = False

floor = Rect(0, 350, 400, 50, fill=rgb(35, 35, 35))

blocks = Group()
groundBlocks = Group()
groundBlocks.dy = 0

lava = Group(
    Rect(0, 400, 400, 400, fill=gradient('red', 'yellow', start='top'), opacity=90),
    Rect(0, 395, 400, 10,
         fill=gradient('lightYellow', 'yellow', 'white', start='top'), opacity=70)
    )

score = Label(0, 350, 30, fill='red', size=30)

instructions = Group(
    Rect(0, 0, 400, 400, fill=app.background),
    Label('Hold the right and left keys to move', 200, 150, size=20),
    Label('Press the up key to jump', 200, 175, size=20),
    Label('Try to jump on top of blocks', 200, 200, size=20),
    Label('Avoid getting hit by blocks', 200, 225, size=20),
    Label('Press space to start', 200, 250, size=20)
    )

def gameOver():
    Rect(80, 80, 240, 150, fill='deepSkyBlue')
    Label('Game Over!', 200, 120, size=30)
    Label('Score: ' + str(score.value) + ' feet', 200, 200, size=20)
    app.stop()

def makeBlock():
    size = randrange(30, 70)
    x = randrange(0, 360)
    y = (-1) * size
    color = rgb(randrange(100, 256), randrange(0, 200), randrange(100, 256))
    newBlock = Group(
        Rect(x + 5, y, size - 10, size, fill=color, border='black'),
        Rect(x, y + 5, size, size - 10, fill=color, border='black'),
        Circle(x + 5, y + 5, 5, fill=color, border='black'),
        Circle(x + size - 5, y + 5, 5, fill=color, border='black'),
        Circle(x + 5, y + size - 5, 5, fill=color, border='black'),
        Circle(x + size - 5, y + size - 5, 5, fill=color, border='black'),
        Rect(x + 3, y + 3, size - 6, size - 6, fill=color),
        Circle(x + size // 2, y // 2, size // 4, fill='steelBlue', border='black')
        )
    blocks.add(newBlock)

def checkHitsGroundBlock():
    # If the player hits a block on the ground, it cant move into it.
    if (player.hitsShape(groundBlocks) == True):
        blockRight = groundBlocks.hitTest(player.right, player.centerY)
        blockLeft = groundBlocks.hitTest(player.left, player.centerY)
        if (blockRight != None):
            player.right = blockRight.left
        elif (blockLeft != None):
            player.left = blockLeft.right

def checkHitsFallingBlock():
    for block in blocks:
        if (player.hitsShape(block) == True):
            return True
    return False

def onKeyPress(key):
    # Starts the jumping animation.
    if ((key == 'up') and (player.isJumping == False)):
        player.isJumping = True
        player.dy = -3

    if (key == 'space'):
        instructions.visible = False

def onKeyHold(keys):
    # Moves the players.
    if ('right' in keys):
        player.centerX += 6
    elif ('left' in keys):
        player.centerX -= 6

    # Wraparound.
    if (player.centerX >= 400):
        player.centerX = 0
    elif (player.centerX <= 0):
        player.centerX = 400

    checkHitsGroundBlock()
    checkHitsFallingBlock()

def tryLandedOnBlock():
    # If the player is falling, and slightly inside of and above a landed block,
    # then lands on top of that block.
    for block in groundBlocks:
        if ((player.bottom >= block.top) and (player.bottom - 5 <= block.top) and
            (player.right > block.left) and (player.left < block.right) and
            (player.dy > 0)):
            player.dy = 0
            player.isJumping = False
            player.tooHigh = False
            player.bottom = block.top
            if (abs(app.stepHeight - player.bottom) > 5):
                if (app.stepHeight - player.bottom > 0):
                   groundBlocks.needToMove = abs(app.stepHeight -
                                                 player.bottom)

def onStep():
    # If the instructions are visible, don't do the rest of onStep.
    if (instructions.visible == True):
        return None

    app.steps += 1
    score.value = int(floor.top - player.bottom)

    # Moves the lava.
    lava.centerY -= 0.075
    if ((player.hitsShape(lava) == True) or (player.centerY >= 400)):
        gameOver()

    # Creates new blocks.
    if (app.steps % 75 == 0):
        rand = randrange(0, 2)
        if (rand == 1):
            makeBlock()

    # Jumping animation.
    player.centerY += player.dy
    player.dy += 0.05
    if (player.bottom >= floor.top):
        player.tooHigh = False
        player.isJumping = False
        player.dy = 0
        player.bottom = floor.top
    else:
        tryLandedOnBlock()

    # Moves the screen down if the player gets high enough.
    if ((app.stepHeight - player.bottom > 5) and (player.tooHigh == False)):
        groundBlocks.dy = 15
        player.tooHigh = True

    if (groundBlocks.dy > 0):
        groundBlocks.centerY += groundBlocks.dy
        floor.centerY += groundBlocks.dy
        lava.centerY += groundBlocks.dy
        groundBlocks.dy = 0

    # Moves all the blocks down.
    for block in blocks:
        if (block.hitsShape(player) == True):
            gameOver()

        if ((block.bottom <= floor.top) and
            (groundBlocks.hitsShape(block) == False)):
            block.centerY += 2
        else:
            blocks.remove(block)
            groundBlocks.add(block)

        # Removes any blocks that have fallen off the canvas.
        if (block.top >= 400):
            blocks.remove(block)

    # Removes any blocks that have landed on the ground and are below the canvas.
    for block in groundBlocks:
        if (block.top >= 400):
            groundBlocks.remove(block)
","# Carnegie Mellon University Computer Science Academy
# This file is private and provided only to teachers.
# Do not share, post, or otherwise make this file public.

app.background = gradient('steelBlue', 'lightCyan', start='top')
app.stepsPerSecond = 100

app.steps = 0
app.stepHeight = 250

player = Group(
    Circle(190, 315, 5, fill='white', border='black'),
    Circle(210, 315, 5, fill='white', border='black'),
    Circle(190, 345, 5, fill='white', border='black'),
    Circle(210, 345, 5, fill='white', border='black'),
    Rect(190, 310, 20, 40, fill='white', border='black'),
    Rect(185, 315, 30, 30, fill='white', border='black'),
    Rect(187, 312, 26, 36, fill='white'),
    )
player.dy = 0
player.isJumping = False
player.hitBlock = False
player.tooHigh = False

floor = Rect(0, 350, 400, 50, fill=rgb(35, 35, 35))

blocks = Group()
groundBlocks = Group()
groundBlocks.dy = 0

lava = Group(
    Rect(0, 400, 400, 400, fill=gradient('red', 'yellow', start='top'), opacity=90),
    Rect(0, 395, 400, 10,
         fill=gradient('lightYellow', 'yellow', 'white', start='top'), opacity=70)
    )

score = Label(0, 350, 30, fill='red', size=30)

instructions = Group(
    Rect(0, 0, 400, 400, fill=app.background),
    Label('Hold the right and left keys to move', 200, 150, size=20),
    Label('Press the up key to jump', 200, 175, size=20),
    Label('Try to jump on top of blocks', 200, 200, size=20),
    Label('Avoid getting hit by blocks', 200, 225, size=20),
    Label('Press space to start', 200, 250, size=20)
    )

def gameOver():
    Rect(80, 80, 240, 150, fill='deepSkyBlue')
    Label('Game Over!', 200, 120, size=30)
    Label('Score: ' + str(score.value) + ' feet', 200, 200, size=20)
    app.stop()

def makeBlock():
    size = randrange(30, 70)
    x = randrange(0, 360)
    y = (-1) * size
    color = rgb(randrange(100, 256), randrange(0, 200), randrange(100, 256))
    newBlock = Group(
        Rect(x + 5, y, size - 10, size, fill=color, border='black'),
        Rect(x, y + 5, size, size - 10, fill=color, border='black'),
        Circle(x + 5, y + 5, 5, fill=color, border='black'),
        Circle(x + size - 5, y + 5, 5, fill=color, border='black'),
        Circle(x + 5, y + size - 5, 5, fill=color, border='black'),
        Circle(x + size - 5, y + size - 5, 5, fill=color, border='black'),
        Rect(x + 3, y + 3, size - 6, size - 6, fill=color),
        Circle(x + size // 2, y // 2, size // 4, fill='steelBlue', border='black')
        )
    blocks.add(newBlock)

def checkHitsGroundBlock():
    # If the player hits a block on the ground, it cant move into it.
    if (player.hitsShape(groundBlocks) == True):
        blockRight = groundBlocks.hitTest(player.right, player.centerY)
        blockLeft = groundBlocks.hitTest(player.left, player.centerY)
        if (blockRight != None):
            player.right = blockRight.left
        elif (blockLeft != None):
            player.left = blockLeft.right

def checkHitsFallingBlock():
    for block in blocks:
        if (player.hitsShape(block) == True):
            return True
    return False

def onKeyPress(key):
    # Starts the jumping animation.
    if ((key == 'up') and (player.isJumping == False)):
        player.isJumping = True
        player.dy = -3

    if (key == 'space'):
        instructions.visible = False

def onKeyHold(keys):
    # Moves the players.
    if ('right' in keys):
        player.centerX += 6
    elif ('left' in keys):
        player.centerX -= 6

    # Wraparound.
    if (player.centerX >= 400):
        player.centerX = 0
    elif (player.centerX <= 0):
        player.centerX = 400

    checkHitsGroundBlock()
    checkHitsFallingBlock()

def tryLandedOnBlock():
    # If the player is falling, and slightly inside of and above a landed block,
    # then lands on top of that block.
    for block in groundBlocks:
        if ((player.bottom >= block.top) and (player.bottom - 5 <= block.top) and
            (player.right > block.left) and (player.left < block.right) and
            (player.dy > 0)):
            player.dy = 0
            player.isJumping = False
            player.tooHigh = False
            player.bottom = block.top
            if (abs(app.stepHeight - player.bottom) > 5):
                if (app.stepHeight - player.bottom > 0):
                   groundBlocks.needToMove = abs(app.stepHeight -
                                                 player.bottom)

def onStep():
    # If the instructions are visible, don't do the rest of onStep.
    if (instructions.visible == True):
        return None

    app.steps += 1
    score.value = int(floor.top - player.bottom)

    # Moves the lava.
    lava.centerY -= 0.075
    if ((player.hitsShape(lava) == True) or (player.centerY >= 400)):
        gameOver()

    # Creates new blocks.
    if (app.steps % 75 == 0):
        rand = randrange(0, 2)
        if (rand == 1):
            makeBlock()

    # Jumping animation.
    player.centerY += player.dy
    player.dy += 0.05
    if (player.bottom >= floor.top):
        player.tooHigh = False
        player.isJumping = False
        player.dy = 0
        player.bottom = floor.top
    else:
        tryLandedOnBlock()

    # Moves the screen down if the player gets high enough.
    if ((app.stepHeight - player.bottom > 5) and (player.tooHigh == False)):
        groundBlocks.dy = 15
        player.tooHigh = True

    if (groundBlocks.dy > 0):
        groundBlocks.centerY += groundBlocks.dy
        floor.centerY += groundBlocks.dy
        lava.centerY += groundBlocks.dy
        groundBlocks.dy = 0

    # Moves all the blocks down.
    for block in blocks:
        if (block.hitsShape(player) == True):
            gameOver()

        if ((block.bottom <= floor.top) and
            (groundBlocks.hitsShape(block) == False)):
            block.centerY += 2
        else:
            blocks.remove(block)
            groundBlocks.add(block)

        # Removes any blocks that have fallen off the canvas.
        if (block.top >= 400):
            blocks.remove(block)

    # Removes any blocks that have landed on the ground and are below the canvas.
    for block in groundBlocks:
        if (block.top >= 400):
            groundBlocks.remove(block)
",sample,1
2343,Final Project,12.1.4,# Fill me in!,,creative,30
